<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.15" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme='dark'] {
        --vp-c-bg: #22272e;
      }

      html,
      body {
        background-color: var(--vp-c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme')
      const systemDarkMode =
        'matchMedia' in window
          ? window.matchMedia('(prefers-color-scheme: dark)').matches
          : false

      if (userMode === 'light') {
        document.documentElement.dataset.theme = 'light'
      } else if (userMode === 'dark' || systemDarkMode) {
        document.documentElement.dataset.theme = 'dark'
      }
    </script>
    <title>The STORMM View of Coding for Molecular Science | STORMM</title><meta name="description" content="Structure and TOpology Replica Molecular Mechanics">
    <link rel="preload" href="/assets/style-pcP7kX5l.css" as="style"><link rel="stylesheet" href="/assets/style-pcP7kX5l.css">
    <link rel="modulepreload" href="/assets/app-Dme5-0ir.js"><link rel="modulepreload" href="/assets/dev-philosophy.html-D5F86QU7.js">
    <link rel="prefetch" href="/assets/index.html-BJ0bgZIo.js" as="script"><link rel="prefetch" href="/assets/contents.html-C0SSMtCQ.js" as="script"><link rel="prefetch" href="/assets/dev-tutorials.html-CT0c6tzX.js" as="script"><link rel="prefetch" href="/assets/get-started.html-AW75shtN.js" as="script"><link rel="prefetch" href="/assets/stormm-md.html-C7WcH1w9.js" as="script"><link rel="prefetch" href="/assets/why-stormm.html-COzEkGy0.js" as="script"><link rel="prefetch" href="/assets/docker.html-CaUV9EC8.js" as="script"><link rel="prefetch" href="/assets/tutorial_i.html-QhSx1e9B.js" as="script"><link rel="prefetch" href="/assets/404.html-BKtrofl6.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="vp-theme-container external-link-icon" vp-container><!--[--><header class="vp-navbar" vp-navbar><div class="vp-toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a class="route-link" href="/"><!----><span class="vp-site-name" aria-hidden="true">STORMM</span></a></span><div class="vp-navbar-items-wrapper" style=""><!--[--><!--]--><nav class="vp-navbar-items vp-hide-mobile" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/" aria-label="Home"><!---->Home<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/get-started.html" aria-label="Getting Started with STORMM"><!---->Getting Started with STORMM<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/contents.html" aria-label="Table of Contents"><!---->Table of Contents<!----></a></div><!--]--></nav><!--[--><!--]--><button type="button" class="vp-toggle-color-mode-button" title="toggle color mode"><svg class="light-icon" viewbox="0 0 32 32" style=""><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg class="dark-icon" viewbox="0 0 32 32" style="display:none;"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="vp-sidebar-mask"></div><!--[--><aside class="vp-sidebar" vp-sidebar><nav class="vp-navbar-items" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/" aria-label="Home"><!---->Home<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/get-started.html" aria-label="Getting Started with STORMM"><!---->Getting Started with STORMM<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/contents.html" aria-label="Table of Contents"><!---->Table of Contents<!----></a></div><!--]--></nav><!--[--><!--]--><ul class="vp-sidebar-items"><!--[--><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">The STORMM View of Coding for Molecular Science <!----></p><!----></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="vp-page"><!--[--><!--]--><div class="theme-default-content" vp-content><!--[--><!--]--><div><h1 id="the-stormm-view-of-coding-for-molecular-science" tabindex="-1"><a class="header-anchor" href="#the-stormm-view-of-coding-for-molecular-science"><span>The STORMM View of Coding for Molecular Science</span></a></h1><p>Computational science is a practice of applying theory to scientific questions through numerical models and simulations. As such, it is best that scientists who want to develop methods have a connection to the underlying numbers, and this is best achieved with a collection of modular and open-source data structures tailored to the elemental operations of the simulation. For molecular modeling, the basic data structures are molecular topologies and coordinates, but most codes for such computations mount the data in a series of individual arrays and are built for doing one or a set number of such calculations at a time.</p><p>STORMM starts by creating its own unique classes for collecting molecular parameters and coordinates, then makes these first-class C++ classes to take advantage of all functionality in the <a href="https://en.cppreference.com/w/cpp/standard_library" target="_blank" rel="noopener noreferrer">C++ Standard Library</a>: objects of these classes may be used in dynamic array allocation, passed to functions, returned by functions, copied, and named as the developer likes. The next step is to elaborate on the parameters and coordinates with classes to interact with them, enabling simulations, evaluate the textbook chemical structures out of thousands of atoms, and optimize compute-intensive aspects of a simulation.</p><p>For more than a decade, computational science has been transformed by vectorized, general-purpose graphics processors (GPUs). The degree of efficiency afforded by this end point of non-uniform memory access computing is staggering: a single consumer-grade card running on a few hundred watts can perform more calculations than megawatt supercomputers of the past built around single-core or multicore processors. The cards also deliver a much greater degree of parallel scaling: a supercomputer in 2005 might have delieverd as little as 5-10% efficiency on a parallel simulation sprawling over hundreds of processors. A GPU in 2025 may utilize upwards of 50% of its available floating point instructions when propagating the same simulation.</p><p>In the modern computing environment, connecting scientists to the numbers in their calculations also means providing a transparent and simple way to transfer that information to the GPU to support kernels (functions) which carry out the algorithm of interest. GPU programming is difficult due to the nature of finding errors among thousands of threads accessing a single block of memory, designing the information layout so that cache overturn and memory traffic remain at the lowest possible levels, and managing all of the pointers that the kernels need in order to access relevant data. STORMM solves these problems with the style and standards of its C++ classes, letting them produce abstracts of pointers and critical array sizes which can be submitted to GPU kernels with much the same appearance as a function call in a C program. Furthermore, all C++ classes are built on a built-in dynamic memory format which manages allocations on both the GPU device and CPU host, as well as transfers between them. The C++ layer provides a means of organizing data and testing its veracity with minimal obfuscation as might be encountered in something like a Python program. The class abstract convention in STORMM ensures that the algorithms and ideas carry over to the GPU.</p><h2 id="keep-dependencies-minimal" tabindex="-1"><a class="header-anchor" href="#keep-dependencies-minimal"><span>Keep Dependencies Minimal</span></a></h2><p>STORMM&#39;s compilation is fast and robust due to careful construction of the CMake scripts and a low dependence on external software packages. Planning for compatibility in trajectories that it will write and other data it might store, STORMM compiles with NetCDF. For speed in CPU computations as well as versatility in a fundamental mathematical operation STORMM compiles with PocketFFT. Otherwise, rather than bring in <a href="https://developer.nvidia.com/thrust" target="_blank" rel="noopener noreferrer">NVIDIA&#39;s CUDA Thrust</a> or <a href="https://github.com/ROCm/rocThrust" target="_blank" rel="noopener noreferrer">AMD&#39;s RocThrust</a>, STORMM uses its own <a class="route-link" href="/doxygen/hybrid_8h_source.html"><code>Hybrid&lt;T&gt;</code></a> dynamic memory class to manage corresponding data on the CPU host and the GPU device. Features of the <code>Hybrid&lt;T&gt;</code> class are entwined with exception handling to expedite backtracing. Another built-in dependency bypass is the unit testing library, including the <a class="route-link" href="/doxygen/classstormm_1_1testing_1_1TestEnvironment.html"><code>TestEnvironment</code></a> class which rolls together customizable command line input with runtime success and failure tallies as well as test summary output. The testing functions replicate the essential features of popular unit testing packages with specializations for the sorts of computations common to computational chemistry. Having all of these features rolled into a single code base also presents developers with a unified resource, the <a class="route-link" href="/doxygen/">STORMM doxygen documentation</a>, to delve through when looking for particular methods and data structures.</p><h2 id="c-to-c-and-then-to-cuda" tabindex="-1"><a class="header-anchor" href="#c-to-c-and-then-to-cuda"><span>C++ to C, and then to CUDA</span></a></h2><p>STORMM is built to run <a href="https://developer.nvidia.com/cuda-toolkit" target="_blank" rel="noopener noreferrer">NVIDIA&#39;s CUDA</a> for the time being, although the code is prepared for a transition to some agnostic state with respect to the high-performance computing language in the future. The workflow for porting a new algorithm or memory structure to the GPU is illustrated in the following diagram. Starting with a C++ <code>class</code> containing data in <a class="route-link" href="/doxygen/hybrid_8h_source.html"><code>Hybrid&lt;T&gt;</code></a> dynamically allocated arrays (as opposed to the C++ Standard Template Library <a href="https://cplusplus.com/reference/vector/vector/" target="_blank" rel="noopener noreferrer"><code>std::vector&lt;T&gt;</code></a> dynamic memory allocation system), a class method is written to return a <code>struct</code> containing critical array size constants and pointers to the relevant memory. If the <code>class</code> contained <code>std::vector&lt;T&gt;</code> arrays for its memory, a set of pointers to each array&#39;s <code>.data()</code> member variable and constants for its <code>.size()</code> would, in effect, allow the developer to traverse the <code>class</code> object&#39;s data as if it were a C <code>struct</code> object. In STORMM, there is an additional choice to make: while the size of any given array will be the same on the CPU or on the GPU, the pointers can refer to data on the CPU host or on the GPU device. The developer can still traverse the host-side data as if it were a C <code>struct</code>, but also take the abstract with pointers to memory on the device and traverse it with C-like CUDA.</p><p><img src="/assets/class_abs-BhVuNlIX.png" alt="ClassAbstracting"></p><p>In the above diagram, a hypothetical STORMM class contains five <code>Hybrid</code> arrays in two different data types, e.g. <code>int</code> and <code>double</code>. It also contains a pointer to another object of the STORMM topology type (this is called <a class="route-link" href="/doxygen/classstormm_1_1topology_1_1AtomGraph.html"><code>AtomGraph</code></a> in the code, but that detail is irrelevant here), as a way to trace the original inputs used to create / calculate its contents. This pointer is only valid for the CPU, and therefore doesn&#39;t become part of the abstract. Each of the <code>Hybrid</code> arrays, however, hold valid pointers to data on the CPU host as well as on the GPU device, so the abstract is created based on a choice of whether pointers should be directed towards data on either resource to facilitate computations there. The <code>StormmClass</code> also contains a tuple of three extra parameters, i.e. three <code>double</code> values, which are included in the abstract as constants. The abstract is a key to the data in the <code>class</code>--if the values of the tuple are changing over time, the convention in most STORMM classes is to have the abstract be a snapshot of the class at any given time, with <code>const</code> qualifiers on such values to treat them as constants.</p><h2 id="syntheses-not-just-arrays-of-topologies-or-coordinate-sets" tabindex="-1"><a class="header-anchor" href="#syntheses-not-just-arrays-of-topologies-or-coordinate-sets"><span>Syntheses: Not Just Arrays of Topologies or Coordinate Sets</span></a></h2><p>It&#39;s easy to think that the way to stage multiple problems on the GPU is to create arrays of the basic <a class="route-link" href="/doxygen/classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> topology or <a class="route-link" href="/doxygen/classstormm_1_1trajectory_1_1PhaseSpace.html">PhaseSpace</a> coordinate and force-holding objects. However, this is bad for two reasons: first, for engineering safety, the <code>Hybrid&lt;T&gt;</code> data type is restricted to various elemental data types, e.g. <code>double</code>, <code>char</code>, or <code>unsigned int</code>. It cannot be used to create an array of topologies or coordinate objects, and even if it was then there would be host- and device-level pointers to the host- and device-level elements of each topology or coordinate set in the list, which would only be valid if accessed in particular ways. A more mundane form of pointer acrobatics gives rise to the second, performance-centric reason: a list of objects with their own sub-arrays would require threads in a GPU kernel to de-reference the list pointer and then the array pointers of the underlying objects. A list of abstracts would do no better. It&#39;s a cost to de-reference a pointer, which is why optimized codes like to get into an array and then go straight down all of its elements to utilize all of the vectorization the chip can muster. In C++ code, it&#39;s easy enough to store a temporary pointer to the location of interest and cut through a series of pointers in that manner, but <em>storing</em> a temporary pointer exacts a cost in registers which are in short supply on the GPU (this, more than cache rationing, is perhaps the most significant distinction in GPU program optimization). The GPU should be directed to as few arrays as possible, and a always given means of striding through them from start to finish.</p><p>A <em>synthesis</em> of topologies or coordinates is therefore a new class which has similar numbers of member variables to the corresponding classes for a single system, but collates all systems&#39; data of a particular type, e.g. all <em>x</em> coordinates or all atomic partial charges, into a single array. Padding is applied between systems to ensure that one warp accessing the data will read a single cache line. The synthesis of topologies, <a class="route-link" href="/doxygen/classstormm_1_1synthesis_1_1AtomGraphSynthesis.html"><code>AtomGraphSynthesis</code></a>, stores a series of integer markers to indicate where each system&#39;s details start and stop, as does the coordinate synthesis, the <a class="route-link" href="/doxygen/classstormm_1_1synthesis_1_1PhaseSpaceSynthesis.html"><code>PhaseSpaceSynthesis</code></a>. The arrangement, and the contrast between a synthesis and an array of objects, is illustrated in the following diagram:</p><img src="/assets/synth_layout-BgDqYR0V.png" alt="Synthesis Distinction" style="width:60%;margin:auto;"><p>Above, a series of molecular coordinate objects is first arranged in a traditional array. It could be a <code>std::vector&lt;Coordinates&gt;</code>, but this would be cumbersome to port data to and from the GPU for reasons already mentioned. The essential elements are the allocated data for the array elements, the sub-allocations for atomic positions and the number of atoms within each coordinate object, and the number of molecular systems in the array. In contrast, the synthesis of such systems arranges all Cartesian <em>x</em>, <em>y</em>, and <em>z</em> coordinates into their own arrays, and might store an additional array of tuples containing the first and final array elements at which to find the positions of atoms in each system. The number of systems <em>K</em>, dictating the length of the bounds array, is likewise stored. While the above example reduces the number of pointers three-fold, in principle any number of systems&#39; coordinates can be stored in a synthesis of the same format, whereas the array of coordinate objects continues to require 3<em>K</em> + 1 pointers.</p><p>The purpose of a synthesis is to establish a framework for the GPU thread blocks to stride down contiguous arrays of data in order to perfomr the same calculation on every system in the series. The individual steps taken by the GPU are also planned by the CPU, often assembled into arrays of their own class objects, as described in the final section.</p><h2 id="work-units-the-cpu-delegates-to-a-gpu-vector-engine" tabindex="-1"><a class="header-anchor" href="#work-units-the-cpu-delegates-to-a-gpu-vector-engine"><span>Work Units: The CPU Delegates to a GPU Vector Engine</span></a></h2><p>In order for the GPU to function efficiently on a heterogeneous set of problems, not just a stated number of replicas of a similar problem but a diverse set of simulations that could range in size from 500 to a million atoms, STORMM breaks down all problems into the smallest common element, the lowest common denominator. In our <a href="https://pubs.aip.org/aip/jcp/article/161/3/032501/3303330/STORMM-Structure-and-topology-replica-molecular" target="_blank" rel="noopener noreferrer">paper</a>, these elements are termed <em>work units</em>. One of the most intricate examples of work units in the code base, dicussed in the introductory publication, is the valence work unit, with several classes devoted to its construction. Other work units may be tuples of even bit-packed arrays of <code>unsigned int</code>. Work units are instructions to GPU kernels, detailing what information to access in order to perform the next iteration of the kernel&#39;s main loop, whether that is to evaluate a particular dihedral interaction between four adjacent atoms or all pairwise interactions among two lists of atoms subject to exclusions enumerated in an array beginning at a specified index.</p></div><!--[--><!--]--></div><footer class="vp-page-meta"><!----><div class="vp-meta-item git-info"><div class="vp-meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><!----></div></footer><!----><!--[--><!--]--></main><!--]--></div><!--[--><!----><!--]--><!--]--></div>
    <script type="module" src="/assets/app-Dme5-0ir.js" defer></script>
  </body>
</html>
