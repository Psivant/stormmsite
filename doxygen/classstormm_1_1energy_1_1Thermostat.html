<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>STORMM Source Documentation: stormm::energy::Thermostat Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">STORMM Source Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>stormm</b></li><li class="navelem"><b>energy</b></li><li class="navelem"><a class="el" href="classstormm_1_1energy_1_1Thermostat.html">Thermostat</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classstormm_1_1energy_1_1Thermostat-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">stormm::energy::Thermostat Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Store the parameters for a simulation thermostat. Includes Berendsen, Andersen, and Langevin methods. This class can be assembled like many of the control objects, i.e. MinimizationControls, based on namelists.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="thermostat_8h_source.html">thermostat.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5302257151734b0105d6ddfa4dd4c0d2" id="r_a5302257151734b0105d6ddfa4dd4c0d2"><td class="memItemLeft" align="right" valign="top"><a id="a5302257151734b0105d6ddfa4dd4c0d2" name="a5302257151734b0105d6ddfa4dd4c0d2"></a>
ThermostatKind&#160;</td><td class="memItemRight" valign="bottom"><b>getKind</b> () const</td></tr>
<tr class="memdesc:a5302257151734b0105d6ddfa4dd4c0d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the kind of thermostat. <br /></td></tr>
<tr class="separator:a5302257151734b0105d6ddfa4dd4c0d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b972eb2231ba14bad86c24a4f93a18b" id="r_a2b972eb2231ba14bad86c24a4f93a18b"><td class="memItemLeft" align="right" valign="top"><a id="a2b972eb2231ba14bad86c24a4f93a18b" name="a2b972eb2231ba14bad86c24a4f93a18b"></a>
ThermostatPartition&#160;</td><td class="memItemRight" valign="bottom"><b>getBathPartitions</b> () const</td></tr>
<tr class="memdesc:a2b972eb2231ba14bad86c24a4f93a18b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate whether this thermostat applies a common target temperature to all atoms, to individual systems, or to some finer compartmentalization based on individual atoms. <br /></td></tr>
<tr class="separator:a2b972eb2231ba14bad86c24a4f93a18b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f5efc528dabbbf173dde55e0832e04" id="r_ad2f5efc528dabbbf173dde55e0832e04"><td class="memItemLeft" align="right" valign="top"><a id="ad2f5efc528dabbbf173dde55e0832e04" name="ad2f5efc528dabbbf173dde55e0832e04"></a>
PrecisionModel&#160;</td><td class="memItemRight" valign="bottom"><b>getCacheConfiguration</b> () const</td></tr>
<tr class="memdesc:ad2f5efc528dabbbf173dde55e0832e04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the random number caching precision. <br /></td></tr>
<tr class="separator:ad2f5efc528dabbbf173dde55e0832e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a3ff0e4b31889f9a64d46a8b247008d" id="r_a3a3ff0e4b31889f9a64d46a8b247008d"><td class="memItemLeft" align="right" valign="top"><a id="a3a3ff0e4b31889f9a64d46a8b247008d" name="a3a3ff0e4b31889f9a64d46a8b247008d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getAtomCount</b> () const</td></tr>
<tr class="memdesc:a3a3ff0e4b31889f9a64d46a8b247008d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of atoms that this thermostat can serve. <br /></td></tr>
<tr class="separator:a3a3ff0e4b31889f9a64d46a8b247008d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15fba30a8c79a550647c919aaf37bc7" id="r_aa15fba30a8c79a550647c919aaf37bc7"><td class="memItemLeft" align="right" valign="top"><a id="aa15fba30a8c79a550647c919aaf37bc7" name="aa15fba30a8c79a550647c919aaf37bc7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getStepNumber</b> () const</td></tr>
<tr class="memdesc:aa15fba30a8c79a550647c919aaf37bc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the step number according to this thermostat. The thermostat will serve as an official reference for the official simulation step number. <br /></td></tr>
<tr class="separator:aa15fba30a8c79a550647c919aaf37bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc642285744303d7811f8af5775048e" id="r_a1bc642285744303d7811f8af5775048e"><td class="memItemLeft" align="right" valign="top"><a id="a1bc642285744303d7811f8af5775048e" name="a1bc642285744303d7811f8af5775048e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getRandomSeed</b> () const</td></tr>
<tr class="memdesc:a1bc642285744303d7811f8af5775048e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the random seed used to initialize Xoshiro256++ state vectors. <br /></td></tr>
<tr class="separator:a1bc642285744303d7811f8af5775048e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4698e8eb19a902aab3304620b2264a" id="r_a0a4698e8eb19a902aab3304620b2264a"><td class="memItemLeft" align="right" valign="top"><a id="a0a4698e8eb19a902aab3304620b2264a" name="a0a4698e8eb19a902aab3304620b2264a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getRandomCacheDepth</b> () const</td></tr>
<tr class="memdesc:a0a4698e8eb19a902aab3304620b2264a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the random number cache depth. The quantity of random numbers that will be produced and cached for each atom is three times this setting, as it implies values for random perturbations in the Cartesian X, Y, and Z directions. <br /></td></tr>
<tr class="separator:a0a4698e8eb19a902aab3304620b2264a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9795ac24528cd8e8dd0735d41f3cfba" id="r_aa9795ac24528cd8e8dd0735d41f3cfba"><td class="memItemLeft" align="right" valign="top"><a id="aa9795ac24528cd8e8dd0735d41f3cfba" name="aa9795ac24528cd8e8dd0735d41f3cfba"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getInitialEvolutionStep</b> () const</td></tr>
<tr class="memdesc:aa9795ac24528cd8e8dd0735d41f3cfba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the step at which to begin changing the temperature from its initial value T(init) to its final value T(final). This is the last step that the thermostat will pull the system towards a value of T(init). Afterwards, the target will begin to change. <br /></td></tr>
<tr class="separator:aa9795ac24528cd8e8dd0735d41f3cfba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12c68fe3b68741afc05dbcd063f19453" id="r_a12c68fe3b68741afc05dbcd063f19453"><td class="memItemLeft" align="right" valign="top"><a id="a12c68fe3b68741afc05dbcd063f19453" name="a12c68fe3b68741afc05dbcd063f19453"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getFinalEvolutionStep</b> () const</td></tr>
<tr class="memdesc:a12c68fe3b68741afc05dbcd063f19453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the step at which the temperature evolution is expected to be complete. This is the step when the thermostat will begin pulling the system towards T(final), although the system itself may or may not be there by this time. <br /></td></tr>
<tr class="separator:a12c68fe3b68741afc05dbcd063f19453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a570664262bcf5c7808a7bcfaff97ddce" id="r_a570664262bcf5c7808a7bcfaff97ddce"><td class="memItemLeft" align="right" valign="top"><a id="a570664262bcf5c7808a7bcfaff97ddce" name="a570664262bcf5c7808a7bcfaff97ddce"></a>
<a class="el" href="structstormm_1_1data__types_1_1ulonglong4.html">ullint4</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getGeneratorState</b> (int atom_index, HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:a570664262bcf5c7808a7bcfaff97ddce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the generator state for a particular atom. For retrieving large numbers of states, one should used the abstract. <br /></td></tr>
<tr class="separator:a570664262bcf5c7808a7bcfaff97ddce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb2d2bbff483db8b7c25f77c825acac" id="r_a7fb2d2bbff483db8b7c25f77c825acac"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7fb2d2bbff483db8b7c25f77c825acac">getCachedRandomResult</a> (int atom_index, int cache_row, HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:a7fb2d2bbff483db8b7c25f77c825acac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get one of the cached random numbers. This function returns the result as a double-precision real, but if a single-precision result is queried it will be converted to double and can then be put back in a float without changing its value. For retrieving large numbers of results, one should used the abstract.  <br /></td></tr>
<tr class="separator:a7fb2d2bbff483db8b7c25f77c825acac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15bf6daa21a9ecdc04ce470001ef352f" id="r_a15bf6daa21a9ecdc04ce470001ef352f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15bf6daa21a9ecdc04ce470001ef352f">getInitialTemperature</a> (int atom_index=0) const</td></tr>
<tr class="memdesc:a15bf6daa21a9ecdc04ce470001ef352f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the initial target temperature for this thermostat, in units of Kelvin.  <br /></td></tr>
<tr class="separator:a15bf6daa21a9ecdc04ce470001ef352f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27691a9ce7e547296d143deea770c1d4" id="r_a27691a9ce7e547296d143deea770c1d4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27691a9ce7e547296d143deea770c1d4">getFinalTemperature</a> (int atom_index=0) const</td></tr>
<tr class="memdesc:a27691a9ce7e547296d143deea770c1d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the end-point target temperature for this thermostat, in units of Kelvin.  <br /></td></tr>
<tr class="separator:a27691a9ce7e547296d143deea770c1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a783d37481306a98b8f4960af4941e0d6" id="r_a783d37481306a98b8f4960af4941e0d6"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a783d37481306a98b8f4960af4941e0d6"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a783d37481306a98b8f4960af4941e0d6">getTemperatureSpread</a> (int step_number=0) const</td></tr>
<tr class="memdesc:a783d37481306a98b8f4960af4941e0d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the spread of temperature targets for all segments of the thermostat at a specific time step.  <br /></td></tr>
<tr class="separator:a783d37481306a98b8f4960af4941e0d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487254f57bd440bdaee1a75c7924d298" id="r_a487254f57bd440bdaee1a75c7924d298"><td class="memItemLeft" align="right" valign="top"><a id="a487254f57bd440bdaee1a75c7924d298" name="a487254f57bd440bdaee1a75c7924d298"></a>
std::vector&lt; <a class="el" href="structstormm_1_1data__types_1_1int4.html">int4</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getPartitionMap</b> () const</td></tr>
<tr class="memdesc:a487254f57bd440bdaee1a75c7924d298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the partition boundaries between different segments of the thermostat as a vector of integer tuples, with the partition lower and upper boundaries in the "x" and "y" members, the number of constrained degrees of freedom in the "z" member, and the number of unconstrained degrees of freedom in the "w" member of each tuple. <br /></td></tr>
<tr class="separator:a487254f57bd440bdaee1a75c7924d298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a439743a19c6fbe8c0b0bd7212732da" id="r_a3a439743a19c6fbe8c0b0bd7212732da"><td class="memTemplParams" colspan="2">template&lt;typename Tcalc&gt; </td></tr>
<tr class="memitem:a3a439743a19c6fbe8c0b0bd7212732da"><td class="memTemplItemLeft" align="right" valign="top">Tcalc&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3a439743a19c6fbe8c0b0bd7212732da">getAtomTarget</a> (int atom_index=0) const</td></tr>
<tr class="memdesc:a3a439743a19c6fbe8c0b0bd7212732da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current target temperature for this thermostat, in units of Kelvin, for a specific atom.  <br /></td></tr>
<tr class="separator:a3a439743a19c6fbe8c0b0bd7212732da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab068c78f11ccf704848481221169969c" id="r_ab068c78f11ccf704848481221169969c"><td class="memTemplParams" colspan="2">template&lt;typename Tcalc&gt; </td></tr>
<tr class="memitem:ab068c78f11ccf704848481221169969c"><td class="memTemplItemLeft" align="right" valign="top">Tcalc&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab068c78f11ccf704848481221169969c">getPartitionTarget</a> (int index=0) const</td></tr>
<tr class="memdesc:ab068c78f11ccf704848481221169969c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current target temperature for a specific partition within this thermostat, in units of Kelvin.  <br /></td></tr>
<tr class="separator:ab068c78f11ccf704848481221169969c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24855ca9ac0af8b01b8c67a3c9217324" id="r_a24855ca9ac0af8b01b8c67a3c9217324"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24855ca9ac0af8b01b8c67a3c9217324">getPartitionConstrainedDoF</a> (int index=0) const</td></tr>
<tr class="memdesc:a24855ca9ac0af8b01b8c67a3c9217324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of constrained degrees of freedom for a particular partition of this thermostat.  <br /></td></tr>
<tr class="separator:a24855ca9ac0af8b01b8c67a3c9217324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd98a37bfb7a96809f546c49b8909c0" id="r_a5cd98a37bfb7a96809f546c49b8909c0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5cd98a37bfb7a96809f546c49b8909c0">getPartitionFreeDoF</a> (int index=0) const</td></tr>
<tr class="memdesc:a5cd98a37bfb7a96809f546c49b8909c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of degrees of freedom for a particular partition of this thermostat, in absence of any constraints.  <br /></td></tr>
<tr class="separator:a5cd98a37bfb7a96809f546c49b8909c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a18a0b01e8fc9f8d878c35532326e2" id="r_a45a18a0b01e8fc9f8d878c35532326e2"><td class="memItemLeft" align="right" valign="top"><a id="a45a18a0b01e8fc9f8d878c35532326e2" name="a45a18a0b01e8fc9f8d878c35532326e2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getAndersenResetFrequency</b> () const</td></tr>
<tr class="memdesc:a45a18a0b01e8fc9f8d878c35532326e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Andersen reset frequency. <br /></td></tr>
<tr class="separator:a45a18a0b01e8fc9f8d878c35532326e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7b8613993c189cf7ce8fa66482d5e1" id="r_a5c7b8613993c189cf7ce8fa66482d5e1"><td class="memItemLeft" align="right" valign="top"><a id="a5c7b8613993c189cf7ce8fa66482d5e1" name="a5c7b8613993c189cf7ce8fa66482d5e1"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getLangevinCollisionFrequency</b> () const</td></tr>
<tr class="memdesc:a5c7b8613993c189cf7ce8fa66482d5e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the collision frequency for the Langevin thermostat (in units of femtoseconds). <br /></td></tr>
<tr class="separator:a5c7b8613993c189cf7ce8fa66482d5e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c83e3e668983cb2a559269a9c3c946" id="r_ac0c83e3e668983cb2a559269a9c3c946"><td class="memItemLeft" align="right" valign="top"><a id="ac0c83e3e668983cb2a559269a9c3c946" name="ac0c83e3e668983cb2a559269a9c3c946"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getLangevinImplicitFactor</b> () const</td></tr>
<tr class="memdesc:ac0c83e3e668983cb2a559269a9c3c946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the "implicit" Langevin factor, the portion of the velocity update to apply immediately after forces have been computed. <br /></td></tr>
<tr class="separator:ac0c83e3e668983cb2a559269a9c3c946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8692c6b0d4840647e8ea3a7132c0f482" id="r_a8692c6b0d4840647e8ea3a7132c0f482"><td class="memItemLeft" align="right" valign="top"><a id="a8692c6b0d4840647e8ea3a7132c0f482" name="a8692c6b0d4840647e8ea3a7132c0f482"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getLangevinExplicitFactor</b> () const</td></tr>
<tr class="memdesc:a8692c6b0d4840647e8ea3a7132c0f482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the "explicit" Langevin factor, the portion of the velocity update to apply on the second half of the update, as new particle positions are being computed. <br /></td></tr>
<tr class="separator:a8692c6b0d4840647e8ea3a7132c0f482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf9269af7939dd72a856b7bdf7262efc" id="r_aaf9269af7939dd72a856b7bdf7262efc"><td class="memItemLeft" align="right" valign="top"><a id="aaf9269af7939dd72a856b7bdf7262efc" name="aaf9269af7939dd72a856b7bdf7262efc"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getTimeStep</b> () const</td></tr>
<tr class="memdesc:aaf9269af7939dd72a856b7bdf7262efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the time step, in units of femtoseconds. <br /></td></tr>
<tr class="separator:aaf9269af7939dd72a856b7bdf7262efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e472d6b0b2b892fca51e4f67cb0b670" id="r_a1e472d6b0b2b892fca51e4f67cb0b670"><td class="memItemLeft" align="right" valign="top"><a id="a1e472d6b0b2b892fca51e4f67cb0b670" name="a1e472d6b0b2b892fca51e4f67cb0b670"></a>
ApplyConstraints&#160;</td><td class="memItemRight" valign="bottom"><b>constrainGeometry</b> () const</td></tr>
<tr class="memdesc:a1e472d6b0b2b892fca51e4f67cb0b670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the order whether to apply geometric constraints. <br /></td></tr>
<tr class="separator:a1e472d6b0b2b892fca51e4f67cb0b670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a66082f94e106e2f5bdf2ac6ae649ad" id="r_a4a66082f94e106e2f5bdf2ac6ae649ad"><td class="memItemLeft" align="right" valign="top"><a id="a4a66082f94e106e2f5bdf2ac6ae649ad" name="a4a66082f94e106e2f5bdf2ac6ae649ad"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getRattleTolerance</b> () const</td></tr>
<tr class="memdesc:a4a66082f94e106e2f5bdf2ac6ae649ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the convergence criterion for RATTLE bond length constraints. <br /></td></tr>
<tr class="separator:a4a66082f94e106e2f5bdf2ac6ae649ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2424729baa304d297132bc347c788c0" id="r_ae2424729baa304d297132bc347c788c0"><td class="memItemLeft" align="right" valign="top"><a id="ae2424729baa304d297132bc347c788c0" name="ae2424729baa304d297132bc347c788c0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getRattleIterations</b> () const</td></tr>
<tr class="memdesc:ae2424729baa304d297132bc347c788c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of RATTLE iterations to attempt. <br /></td></tr>
<tr class="separator:ae2424729baa304d297132bc347c788c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade7ddb2fac3d8fe1313685c54d37d57a" id="r_ade7ddb2fac3d8fe1313685c54d37d57a"><td class="memItemLeft" align="right" valign="top"><a id="ade7ddb2fac3d8fe1313685c54d37d57a" name="ade7ddb2fac3d8fe1313685c54d37d57a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>loadSynthesisForces</b> () const</td></tr>
<tr class="memdesc:ade7ddb2fac3d8fe1313685c54d37d57a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an indication of whether extra forces should be loaded from the synthesis in periodic systems. <br /></td></tr>
<tr class="separator:ade7ddb2fac3d8fe1313685c54d37d57a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb575f117349a6b4a753d08fbff0977f" id="r_afb575f117349a6b4a753d08fbff0977f"><td class="memItemLeft" align="right" valign="top"><a id="afb575f117349a6b4a753d08fbff0977f" name="afb575f117349a6b4a753d08fbff0977f"></a>
const <a class="el" href="classstormm_1_1trajectory_1_1Thermostat.html">Thermostat</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getSelfPointer</b> () const</td></tr>
<tr class="memdesc:afb575f117349a6b4a753d08fbff0977f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the object itself, useful if it has been passed to a function by. <br /></td></tr>
<tr class="separator:afb575f117349a6b4a753d08fbff0977f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a374331fb63408577ccf0918137c53275" id="r_a374331fb63408577ccf0918137c53275"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a374331fb63408577ccf0918137c53275">setAtomCount</a> (int atom_count_in, int new_seed=-1, const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;gpu=null_gpu)</td></tr>
<tr class="memdesc:a374331fb63408577ccf0918137c53275"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of atoms for which the thermostat is responsible.  <br /></td></tr>
<tr class="separator:a374331fb63408577ccf0918137c53275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad402fa578bbc04a2cf1693633068c574" id="r_ad402fa578bbc04a2cf1693633068c574"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad402fa578bbc04a2cf1693633068c574">checkCompartments</a> (const <a class="el" href="classstormm_1_1synthesis_1_1AtomGraphSynthesis.html">AtomGraphSynthesis</a> *poly_ag)</td></tr>
<tr class="memdesc:ad402fa578bbc04a2cf1693633068c574"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the compartmentalization if the thermostat regulates a synthesis of systems.  <br /></td></tr>
<tr class="separator:ad402fa578bbc04a2cf1693633068c574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae051d1b8bec47f4a600778ae7b579523" id="r_ae051d1b8bec47f4a600778ae7b579523"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae051d1b8bec47f4a600778ae7b579523">setEvolutionWindow</a> (int init_step_in, int final_step_in)</td></tr>
<tr class="memdesc:ae051d1b8bec47f4a600778ae7b579523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the step at which temperature evolution, away from T(init), shall begin.  <br /></td></tr>
<tr class="separator:ae051d1b8bec47f4a600778ae7b579523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a347ee6c5d98ecac289d3ceff6e67bffe" id="r_a347ee6c5d98ecac289d3ceff6e67bffe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a347ee6c5d98ecac289d3ceff6e67bffe">setCacheConfiguration</a> (PrecisionModel cache_config_in, const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;gpu=null_gpu)</td></tr>
<tr class="memdesc:a347ee6c5d98ecac289d3ceff6e67bffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the random number cache configuration.  <br /></td></tr>
<tr class="separator:a347ee6c5d98ecac289d3ceff6e67bffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a459ebd1a64500cb32b70972c2e2589e3" id="r_a459ebd1a64500cb32b70972c2e2589e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a459ebd1a64500cb32b70972c2e2589e3">setRandomCacheDepth</a> (int depth_in, const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;gpu=null_gpu)</td></tr>
<tr class="memdesc:a459ebd1a64500cb32b70972c2e2589e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the random number cache depth. This value is kept on a tight leash, as it can easily lead to allocating too much memory. A hundred-thousand atom system with cache depth 8 leads to over 13.7MB of memory allocation.  <br /></td></tr>
<tr class="separator:a459ebd1a64500cb32b70972c2e2589e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a129fa8ff189dd4030971dcd534bc8d7b" id="r_a129fa8ff189dd4030971dcd534bc8d7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a129fa8ff189dd4030971dcd534bc8d7b">setLangevinCollisionFrequency</a> (double langevin_frequency_in)</td></tr>
<tr class="memdesc:a129fa8ff189dd4030971dcd534bc8d7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the collision frequency for the Langevin thermostat. This will also set the scaled form of the value.  <br /></td></tr>
<tr class="separator:a129fa8ff189dd4030971dcd534bc8d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa199f910b9825be22d42dee1dfcc24ee" id="r_aa199f910b9825be22d42dee1dfcc24ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa199f910b9825be22d42dee1dfcc24ee">setAndersenResetFrequency</a> (int andersen_frequency_in)</td></tr>
<tr class="memdesc:aa199f910b9825be22d42dee1dfcc24ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Andersen velocity reassignment frequency. This will be taken from user input.  <br /></td></tr>
<tr class="separator:aa199f910b9825be22d42dee1dfcc24ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3863aca60b98ec7bd76ce0c4882b440d" id="r_a3863aca60b98ec7bd76ce0c4882b440d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3863aca60b98ec7bd76ce0c4882b440d">setTimeStep</a> (double time_step_in)</td></tr>
<tr class="memdesc:a3863aca60b98ec7bd76ce0c4882b440d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the time step. This will also set the scaled form of the value.  <br /></td></tr>
<tr class="separator:a3863aca60b98ec7bd76ce0c4882b440d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f0f7b5d5d98eb60b3ed42f2a2bf0da4" id="r_a1f0f7b5d5d98eb60b3ed42f2a2bf0da4"><td class="memItemLeft" align="right" valign="top"><a id="a1f0f7b5d5d98eb60b3ed42f2a2bf0da4" name="a1f0f7b5d5d98eb60b3ed42f2a2bf0da4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>incrementStep</b> ()</td></tr>
<tr class="memdesc:a1f0f7b5d5d98eb60b3ed42f2a2bf0da4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the step count by one. This will advance the simulation's official step counter. <br /></td></tr>
<tr class="separator:a1f0f7b5d5d98eb60b3ed42f2a2bf0da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec34450161529972cca7f07423e7573" id="r_a1ec34450161529972cca7f07423e7573"><td class="memItemLeft" align="right" valign="top"><a id="a1ec34450161529972cca7f07423e7573" name="a1ec34450161529972cca7f07423e7573"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>decrementStep</b> ()</td></tr>
<tr class="memdesc:a1ec34450161529972cca7f07423e7573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrease the step count by one. This will cause the simulation's official step counter to backtrack. <br /></td></tr>
<tr class="separator:a1ec34450161529972cca7f07423e7573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae330b45b89ffd44b036df1e53b20a195" id="r_ae330b45b89ffd44b036df1e53b20a195"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae330b45b89ffd44b036df1e53b20a195">setGeometryConstraints</a> (ApplyConstraints cnst_geometry_in)</td></tr>
<tr class="memdesc:ae330b45b89ffd44b036df1e53b20a195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the instruction for carrying out geometric constraints during dynamics.  <br /></td></tr>
<tr class="separator:ae330b45b89ffd44b036df1e53b20a195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d3947cf1eef66cf9cf9f5860ca9ad7" id="r_a08d3947cf1eef66cf9cf9f5860ca9ad7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08d3947cf1eef66cf9cf9f5860ca9ad7">setRattleTolerance</a> (double rattle_tolerance_in)</td></tr>
<tr class="memdesc:a08d3947cf1eef66cf9cf9f5860ca9ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the convergence criterion for RATTLE.  <br /></td></tr>
<tr class="separator:a08d3947cf1eef66cf9cf9f5860ca9ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1116aea8575d84e31a962fcc56d714e8" id="r_a1116aea8575d84e31a962fcc56d714e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1116aea8575d84e31a962fcc56d714e8">setRattleIterations</a> (int rattle_iterations_in)</td></tr>
<tr class="memdesc:a1116aea8575d84e31a962fcc56d714e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum number of iterations to take when attempting to converge RATTLE bond length constraints.  <br /></td></tr>
<tr class="separator:a1116aea8575d84e31a962fcc56d714e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b9b3557690fcd8e46087b39a1f2a09b" id="r_a5b9b3557690fcd8e46087b39a1f2a09b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b9b3557690fcd8e46087b39a1f2a09b">setSynthesisForceLoading</a> (bool load_synthesis_forces_in=true)</td></tr>
<tr class="memdesc:a5b9b3557690fcd8e46087b39a1f2a09b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the integrator to take prior force computations residing in the <a class="el" href="classstormm_1_1energy_1_1PhaseSpaceSynthesis.html" title="A fixed-precision representation of coordinates, velocities, and forces to manage a set of simulation...">PhaseSpaceSynthesis</a> into account. This will have an effect in the dynamics of periodic systems when particle movement is fused to valence interaction computations. In this situation, by default all prior force computations would be expected to reside in the neighbor list grid (non-bonded forces). For non-periodic calculations, all prior force computations will be expected to accumulate in the <a class="el" href="classstormm_1_1energy_1_1PhaseSpaceSynthesis.html" title="A fixed-precision representation of coordinates, velocities, and forces to manage a set of simulation...">PhaseSpaceSynthesis</a>, meaning that this setting will have no effect.  <br /></td></tr>
<tr class="separator:a5b9b3557690fcd8e46087b39a1f2a09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df36a30bd77894b7734d62fee620db9" id="r_a3df36a30bd77894b7734d62fee620db9"><td class="memItemLeft" align="right" valign="top"><a id="a3df36a30bd77894b7734d62fee620db9" name="a3df36a30bd77894b7734d62fee620db9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>validateTemperature</b> (double temperature_in)</td></tr>
<tr class="memdesc:a3df36a30bd77894b7734d62fee620db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate the initial or final target temperature. <br /></td></tr>
<tr class="separator:a3df36a30bd77894b7734d62fee620db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cdc85e0495c5a1b04b63857bbbee25e" id="r_a6cdc85e0495c5a1b04b63857bbbee25e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6cdc85e0495c5a1b04b63857bbbee25e">validateEvolutionWindow</a> ()</td></tr>
<tr class="memdesc:a6cdc85e0495c5a1b04b63857bbbee25e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate the initial and final steps for applying the temperature evolution.  <br /></td></tr>
<tr class="separator:a6cdc85e0495c5a1b04b63857bbbee25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f8d53f3817eb4a511c09c9f47efeb4" id="r_a84f8d53f3817eb4a511c09c9f47efeb4"><td class="memItemLeft" align="right" valign="top"><a id="a84f8d53f3817eb4a511c09c9f47efeb4" name="a84f8d53f3817eb4a511c09c9f47efeb4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>validateRandomCacheDepth</b> ()</td></tr>
<tr class="memdesc:a84f8d53f3817eb4a511c09c9f47efeb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate the random number cache depth. A maxmimum cache depth of 15 (45 total random numbers per atom) is enforced, and tightened in cases of exceptionally large systems. <br /></td></tr>
<tr class="separator:a84f8d53f3817eb4a511c09c9f47efeb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57627ebd666e6e42b678a99ed6ec4e90" id="r_a57627ebd666e6e42b678a99ed6ec4e90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57627ebd666e6e42b678a99ed6ec4e90">initializeRandomStates</a> (int new_seed=default_thermostat_random_seed, int scrub_cycles=25, HybridTargetLevel tier=HybridTargetLevel::HOST, const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;gpu=null_gpu)</td></tr>
<tr class="memdesc:a57627ebd666e6e42b678a99ed6ec4e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the random state vectors of a thermostat, whether for Langevin or Andersen thermostating. This passes a call on to a general-purpose function for seeding the generators and will recruit the GPU if available to expedite the process.  <br /></td></tr>
<tr class="separator:a57627ebd666e6e42b678a99ed6ec4e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c1bd5bed4dbf6e26574ac9f272b4a84" id="r_a4c1bd5bed4dbf6e26574ac9f272b4a84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c1bd5bed4dbf6e26574ac9f272b4a84">refresh</a> (size_t index_start, size_t index_end, int refresh_depth=0)</td></tr>
<tr class="memdesc:a4c1bd5bed4dbf6e26574ac9f272b4a84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill or refill the random number cache for a subset of the atoms, advancing the thermostat's random number generators in the process. This CPU-based function is intended to mimic GPU functionality, but the GPU operations are expected to be fused with other kernels.  <br /></td></tr>
<tr class="separator:a4c1bd5bed4dbf6e26574ac9f272b4a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa3b1268420b7bf664176b451d95398dd" id="r_aa3b1268420b7bf664176b451d95398dd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3b1268420b7bf664176b451d95398dd">Thermostat</a> (ThermostatKind kind_in=ThermostatKind::NONE, PrecisionModel cache_config_in=PrecisionModel::SINGLE, int random_seed_in=default_thermostat_random_seed, const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;gpu=null_gpu)</td></tr>
<tr class="memdesc:aa3b1268420b7bf664176b451d95398dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructors for the <a class="el" href="classstormm_1_1energy_1_1Thermostat.html" title="Store the parameters for a simulation thermostat. Includes Berendsen, Andersen, and Langevin methods....">Thermostat</a> object. Any information can be added via setter functions after constructing the object.  <br /></td></tr>
<tr class="separator:aa3b1268420b7bf664176b451d95398dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02074cf14c0d8b7848a18ccb445da117" id="r_a02074cf14c0d8b7848a18ccb445da117"><td class="memItemLeft" align="right" valign="top"><a id="a02074cf14c0d8b7848a18ccb445da117" name="a02074cf14c0d8b7848a18ccb445da117"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Thermostat</b> (int atom_count_in, ThermostatKind kind_in, double temperature_in, PrecisionModel cache_config_in=PrecisionModel::SINGLE, int random_seed_in=default_thermostat_random_seed, const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;gpu=null_gpu)</td></tr>
<tr class="separator:a02074cf14c0d8b7848a18ccb445da117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f8006f268bfcd4da8e1722209041fd" id="r_aa0f8006f268bfcd4da8e1722209041fd"><td class="memItemLeft" align="right" valign="top"><a id="aa0f8006f268bfcd4da8e1722209041fd" name="aa0f8006f268bfcd4da8e1722209041fd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Thermostat</b> (int atom_count_in, ThermostatKind kind_in, double init_temperature_in, double final_temperature_in, int initial_evolution_step_in, int final_evolution_step_in, PrecisionModel cache_config_in=PrecisionModel::SINGLE, int random_seed_in=default_thermostat_random_seed, const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;gpu=null_gpu)</td></tr>
<tr class="separator:aa0f8006f268bfcd4da8e1722209041fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc03692c0cff89741160598a6776719a" id="r_afc03692c0cff89741160598a6776719a"><td class="memItemLeft" align="right" valign="top"><a id="afc03692c0cff89741160598a6776719a" name="afc03692c0cff89741160598a6776719a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Thermostat</b> (int atom_count_in, ThermostatKind kind_in, const std::vector&lt; double &gt; &amp;initial_temperatures_in, const std::vector&lt; double &gt; &amp;final_temperatures_in, const std::vector&lt; <a class="el" href="structstormm_1_1data__types_1_1int2.html">int2</a> &gt; &amp;paritions_in, int initial_evolution_step_in=default_tstat_evo_window_start, int final_evolution_step_in=default_tstat_evo_window_end, PrecisionModel cache_config_in=PrecisionModel::SINGLE, int random_seed_in=default_thermostat_random_seed, const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;gpu=null_gpu)</td></tr>
<tr class="separator:afc03692c0cff89741160598a6776719a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ffcf19e472c317f7bcd2fb4efb9d69" id="r_a31ffcf19e472c317f7bcd2fb4efb9d69"><td class="memItemLeft" align="right" valign="top"><a id="a31ffcf19e472c317f7bcd2fb4efb9d69" name="a31ffcf19e472c317f7bcd2fb4efb9d69"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Thermostat</b> (const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> *ag, ThermostatKind kind_in, double initial_temperature_in, double final_temperature_in, int initial_evolution_step_in, int final_evolution_step_in, PrecisionModel cache_config_in=PrecisionModel::SINGLE, int random_seed_in=default_thermostat_random_seed, const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;gpu=null_gpu)</td></tr>
<tr class="separator:a31ffcf19e472c317f7bcd2fb4efb9d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad21f35740c43a4d2e57accb1e7735dda" id="r_ad21f35740c43a4d2e57accb1e7735dda"><td class="memItemLeft" align="right" valign="top"><a id="ad21f35740c43a4d2e57accb1e7735dda" name="ad21f35740c43a4d2e57accb1e7735dda"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Thermostat</b> (const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;ag, ThermostatKind kind_in, double initial_temperature_in, double final_temperature_in, int initial_evolution_step_in, int final_evolution_step_in, PrecisionModel cache_config_in=PrecisionModel::SINGLE, int random_seed_in=default_thermostat_random_seed, const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;gpu=null_gpu)</td></tr>
<tr class="separator:ad21f35740c43a4d2e57accb1e7735dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af50cd00018e54a8ff67e9bb81fbe688d" id="r_af50cd00018e54a8ff67e9bb81fbe688d"><td class="memItemLeft" align="right" valign="top"><a id="af50cd00018e54a8ff67e9bb81fbe688d" name="af50cd00018e54a8ff67e9bb81fbe688d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Thermostat</b> (const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> *ag, ThermostatKind kind_in, double temperature_in=default_simulation_temperature, PrecisionModel cache_config_in=PrecisionModel::SINGLE, int random_seed_in=default_thermostat_random_seed, const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;gpu=null_gpu)</td></tr>
<tr class="separator:af50cd00018e54a8ff67e9bb81fbe688d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c79fa65de46efa9c1abff8fdca2d5a" id="r_a98c79fa65de46efa9c1abff8fdca2d5a"><td class="memItemLeft" align="right" valign="top"><a id="a98c79fa65de46efa9c1abff8fdca2d5a" name="a98c79fa65de46efa9c1abff8fdca2d5a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Thermostat</b> (const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;ag, ThermostatKind kind_in, double temperature_in=default_simulation_temperature, PrecisionModel cache_config_in=PrecisionModel::SINGLE, int random_seed_in=default_thermostat_random_seed, const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;gpu=null_gpu)</td></tr>
<tr class="separator:a98c79fa65de46efa9c1abff8fdca2d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb152c76cff7ec4ad4767e3e680dcf2d" id="r_abb152c76cff7ec4ad4767e3e680dcf2d"><td class="memItemLeft" align="right" valign="top"><a id="abb152c76cff7ec4ad4767e3e680dcf2d" name="abb152c76cff7ec4ad4767e3e680dcf2d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Thermostat</b> (const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> *ag, ThermostatKind kind_in, const std::vector&lt; double &gt; &amp;initial_temperatures_in, const std::vector&lt; double &gt; &amp;final_temperatures_in, const std::vector&lt; <a class="el" href="structstormm_1_1data__types_1_1int2.html">int2</a> &gt; &amp;paritions_in, int initial_evolution_step_in=default_tstat_evo_window_start, int final_evolution_step_in=default_tstat_evo_window_end, PrecisionModel cache_config_in=PrecisionModel::SINGLE, int random_seed_in=default_thermostat_random_seed, const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;gpu=null_gpu)</td></tr>
<tr class="separator:abb152c76cff7ec4ad4767e3e680dcf2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5eceae7a4e07e3e593ff2fbd6a18e6" id="r_afd5eceae7a4e07e3e593ff2fbd6a18e6"><td class="memItemLeft" align="right" valign="top"><a id="afd5eceae7a4e07e3e593ff2fbd6a18e6" name="afd5eceae7a4e07e3e593ff2fbd6a18e6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Thermostat</b> (const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;ag, ThermostatKind kind_in, const std::vector&lt; double &gt; &amp;initial_temperatures_in, const std::vector&lt; double &gt; &amp;final_temperatures_in, const std::vector&lt; <a class="el" href="structstormm_1_1data__types_1_1int2.html">int2</a> &gt; &amp;paritions_in, int initial_evolution_step_in=default_tstat_evo_window_start, int final_evolution_step_in=default_tstat_evo_window_end, PrecisionModel cache_config_in=PrecisionModel::SINGLE, int random_seed_in=default_thermostat_random_seed, const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;gpu=null_gpu)</td></tr>
<tr class="separator:afd5eceae7a4e07e3e593ff2fbd6a18e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13381815912f66b4f2305dd9ed472c7" id="r_ae13381815912f66b4f2305dd9ed472c7"><td class="memItemLeft" align="right" valign="top"><a id="ae13381815912f66b4f2305dd9ed472c7" name="ae13381815912f66b4f2305dd9ed472c7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Thermostat</b> (const <a class="el" href="classstormm_1_1synthesis_1_1AtomGraphSynthesis.html">AtomGraphSynthesis</a> *poly_ag, ThermostatKind kind_in, double initial_temperature_in, double final_temperature_in, int initial_evolution_step_in, int final_evolution_step_in, PrecisionModel cache_config_in=PrecisionModel::SINGLE, int random_seed_in=default_thermostat_random_seed, const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;gpu=null_gpu)</td></tr>
<tr class="separator:ae13381815912f66b4f2305dd9ed472c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bdadb91fb131218b737755b264b4b6d" id="r_a9bdadb91fb131218b737755b264b4b6d"><td class="memItemLeft" align="right" valign="top"><a id="a9bdadb91fb131218b737755b264b4b6d" name="a9bdadb91fb131218b737755b264b4b6d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Thermostat</b> (const <a class="el" href="classstormm_1_1synthesis_1_1AtomGraphSynthesis.html">AtomGraphSynthesis</a> &amp;poly_ag, ThermostatKind kind_in, double initial_temperature_in, double final_temperature_in, int initial_evolution_step_in, int final_evolution_step_in, PrecisionModel cache_config_in=PrecisionModel::SINGLE, int random_seed_in=default_thermostat_random_seed, const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;gpu=null_gpu)</td></tr>
<tr class="separator:a9bdadb91fb131218b737755b264b4b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa59a834026eaf2a9ec2db3a0414e356b" id="r_aa59a834026eaf2a9ec2db3a0414e356b"><td class="memItemLeft" align="right" valign="top"><a id="aa59a834026eaf2a9ec2db3a0414e356b" name="aa59a834026eaf2a9ec2db3a0414e356b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Thermostat</b> (const <a class="el" href="classstormm_1_1synthesis_1_1AtomGraphSynthesis.html">AtomGraphSynthesis</a> *poly_ag, ThermostatKind kind_in, double temperature_in=default_simulation_temperature, PrecisionModel cache_config_in=PrecisionModel::SINGLE, int random_seed_in=default_thermostat_random_seed, const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;gpu=null_gpu)</td></tr>
<tr class="separator:aa59a834026eaf2a9ec2db3a0414e356b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635426df3ccb452cb206509680ef801b" id="r_a635426df3ccb452cb206509680ef801b"><td class="memItemLeft" align="right" valign="top"><a id="a635426df3ccb452cb206509680ef801b" name="a635426df3ccb452cb206509680ef801b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Thermostat</b> (const <a class="el" href="classstormm_1_1synthesis_1_1AtomGraphSynthesis.html">AtomGraphSynthesis</a> &amp;poly_ag, ThermostatKind kind_in, double temperature_in=default_simulation_temperature, PrecisionModel cache_config_in=PrecisionModel::SINGLE, int random_seed_in=default_thermostat_random_seed, const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;gpu=null_gpu)</td></tr>
<tr class="separator:a635426df3ccb452cb206509680ef801b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e458c72dc3077df0cb7c3056f4a849" id="r_af5e458c72dc3077df0cb7c3056f4a849"><td class="memItemLeft" align="right" valign="top"><a id="af5e458c72dc3077df0cb7c3056f4a849" name="af5e458c72dc3077df0cb7c3056f4a849"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Thermostat</b> (const <a class="el" href="classstormm_1_1synthesis_1_1AtomGraphSynthesis.html">AtomGraphSynthesis</a> *poly_ag, ThermostatKind kind_in, const std::vector&lt; double &gt; &amp;initial_temperatures_in, const std::vector&lt; double &gt; &amp;final_temperatures_in, const std::vector&lt; <a class="el" href="structstormm_1_1data__types_1_1int2.html">int2</a> &gt; &amp;paritions_in, int initial_evolution_step_in=default_tstat_evo_window_start, int final_evolution_step_in=default_tstat_evo_window_end, PrecisionModel cache_config_in=PrecisionModel::SINGLE, int random_seed_in=default_thermostat_random_seed, const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;gpu=null_gpu)</td></tr>
<tr class="separator:af5e458c72dc3077df0cb7c3056f4a849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae18bbca0fc384cfdf39ef435c533fe58" id="r_ae18bbca0fc384cfdf39ef435c533fe58"><td class="memItemLeft" align="right" valign="top"><a id="ae18bbca0fc384cfdf39ef435c533fe58" name="ae18bbca0fc384cfdf39ef435c533fe58"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Thermostat</b> (const <a class="el" href="classstormm_1_1synthesis_1_1AtomGraphSynthesis.html">AtomGraphSynthesis</a> &amp;poly_ag, ThermostatKind kind_in, const std::vector&lt; double &gt; &amp;initial_temperatures_in, const std::vector&lt; double &gt; &amp;final_temperatures_in, const std::vector&lt; <a class="el" href="structstormm_1_1data__types_1_1int2.html">int2</a> &gt; &amp;paritions_in, int initial_evolution_step_in=default_tstat_evo_window_start, int final_evolution_step_in=default_tstat_evo_window_end, PrecisionModel cache_config_in=PrecisionModel::SINGLE, int random_seed_in=default_thermostat_random_seed, const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;gpu=null_gpu)</td></tr>
<tr class="separator:ae18bbca0fc384cfdf39ef435c533fe58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32fef13d270e22e7e86171015cf5069" id="r_ac32fef13d270e22e7e86171015cf5069"><td class="memItemLeft" align="right" valign="top"><a id="ac32fef13d270e22e7e86171015cf5069" name="ac32fef13d270e22e7e86171015cf5069"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Thermostat</b> (const <a class="el" href="classstormm_1_1synthesis_1_1AtomGraphSynthesis.html">AtomGraphSynthesis</a> *poly_ag, const DynamicsControls &amp;dyncon, const SystemCache &amp;sc, const std::vector&lt; int &gt; &amp;sc_origins, const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;gpu=null_gpu)</td></tr>
<tr class="separator:ac32fef13d270e22e7e86171015cf5069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa31289ea1061c4d4d3964578842102f" id="r_aaa31289ea1061c4d4d3964578842102f"><td class="memItemLeft" align="right" valign="top"><a id="aaa31289ea1061c4d4d3964578842102f" name="aaa31289ea1061c4d4d3964578842102f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Thermostat</b> (const <a class="el" href="classstormm_1_1synthesis_1_1AtomGraphSynthesis.html">AtomGraphSynthesis</a> &amp;poly_ag, const DynamicsControls &amp;dyncon, const SystemCache &amp;sc, const std::vector&lt; int &gt; &amp;sc_origins, const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;gpu=null_gpu)</td></tr>
<tr class="separator:aaa31289ea1061c4d4d3964578842102f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6b3e8fbe46a5dc8cf8548c278955c107" id="r_a6b3e8fbe46a5dc8cf8548c278955c107"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b3e8fbe46a5dc8cf8548c278955c107">Thermostat</a> (const <a class="el" href="classstormm_1_1trajectory_1_1Thermostat.html">Thermostat</a> &amp;original)=default</td></tr>
<tr class="memdesc:a6b3e8fbe46a5dc8cf8548c278955c107"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default copy and move constructors and assignment operators are best for this object with no POINTER-kind <a class="el" href="classstormm_1_1energy_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> objects.  <br /></td></tr>
<tr class="separator:a6b3e8fbe46a5dc8cf8548c278955c107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb5c5234e886c1ad29a438fd43910b5" id="r_a1fb5c5234e886c1ad29a438fd43910b5"><td class="memItemLeft" align="right" valign="top"><a id="a1fb5c5234e886c1ad29a438fd43910b5" name="a1fb5c5234e886c1ad29a438fd43910b5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Thermostat</b> (<a class="el" href="classstormm_1_1trajectory_1_1Thermostat.html">Thermostat</a> &amp;&amp;original)=default</td></tr>
<tr class="separator:a1fb5c5234e886c1ad29a438fd43910b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa875a53ea7ae5e59287ac16ee7635da5" id="r_aa875a53ea7ae5e59287ac16ee7635da5"><td class="memItemLeft" align="right" valign="top"><a id="aa875a53ea7ae5e59287ac16ee7635da5" name="aa875a53ea7ae5e59287ac16ee7635da5"></a>
<a class="el" href="classstormm_1_1trajectory_1_1Thermostat.html">Thermostat</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classstormm_1_1trajectory_1_1Thermostat.html">Thermostat</a> &amp;original)=default</td></tr>
<tr class="separator:aa875a53ea7ae5e59287ac16ee7635da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb6f4ad4020b62e97ae690973ead1c8" id="r_a4cb6f4ad4020b62e97ae690973ead1c8"><td class="memItemLeft" align="right" valign="top"><a id="a4cb6f4ad4020b62e97ae690973ead1c8" name="a4cb6f4ad4020b62e97ae690973ead1c8"></a>
<a class="el" href="classstormm_1_1trajectory_1_1Thermostat.html">Thermostat</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classstormm_1_1trajectory_1_1Thermostat.html">Thermostat</a> &amp;&amp;original)=default</td></tr>
<tr class="separator:a4cb6f4ad4020b62e97ae690973ead1c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a41991e0a62df864556533c8040b23416" id="r_a41991e0a62df864556533c8040b23416"><td class="memItemLeft" align="right" valign="top">const ThermostatReader&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41991e0a62df864556533c8040b23416">dpData</a> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:a41991e0a62df864556533c8040b23416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the abstract.  <br /></td></tr>
<tr class="separator:a41991e0a62df864556533c8040b23416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b3c7b3a57b060d3f746869f97826b6" id="r_a74b3c7b3a57b060d3f746869f97826b6"><td class="memItemLeft" align="right" valign="top"><a id="a74b3c7b3a57b060d3f746869f97826b6" name="a74b3c7b3a57b060d3f746869f97826b6"></a>
<a class="el" href="structstormm_1_1trajectory_1_1ThermostatWriter.html">ThermostatWriter</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>dpData</b> (HybridTargetLevel tier=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:a74b3c7b3a57b060d3f746869f97826b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75de0e18848355912dc0a0d18a81bf88" id="r_a75de0e18848355912dc0a0d18a81bf88"><td class="memItemLeft" align="right" valign="top"><a id="a75de0e18848355912dc0a0d18a81bf88" name="a75de0e18848355912dc0a0d18a81bf88"></a>
const ThermostatReader&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>spData</b> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="separator:a75de0e18848355912dc0a0d18a81bf88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d894b82afd81c2d1c65c0b759b039e3" id="r_a7d894b82afd81c2d1c65c0b759b039e3"><td class="memItemLeft" align="right" valign="top"><a id="a7d894b82afd81c2d1c65c0b759b039e3" name="a7d894b82afd81c2d1c65c0b759b039e3"></a>
<a class="el" href="structstormm_1_1trajectory_1_1ThermostatWriter.html">ThermostatWriter</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>spData</b> (HybridTargetLevel tier=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:a7d894b82afd81c2d1c65c0b759b039e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1faa9feacbd631e88ad7279b14fd7cd2" id="r_a1faa9feacbd631e88ad7279b14fd7cd2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1faa9feacbd631e88ad7279b14fd7cd2">setTemperature</a> (double initial_temperature_in, double final_temperature_in=-1.0)</td></tr>
<tr class="memdesc:a1faa9feacbd631e88ad7279b14fd7cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the initial target temperature.  <br /></td></tr>
<tr class="separator:a1faa9feacbd631e88ad7279b14fd7cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb672668727c425a9e166609bc33583" id="r_a3eb672668727c425a9e166609bc33583"><td class="memItemLeft" align="right" valign="top"><a id="a3eb672668727c425a9e166609bc33583" name="a3eb672668727c425a9e166609bc33583"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setTemperature</b> (const std::vector&lt; double &gt; &amp;initial_temperatures_in, const std::vector&lt; double &gt; &amp;final_temperatures_in, const std::vector&lt; <a class="el" href="structstormm_1_1data__types_1_1int2.html">int2</a> &gt; &amp;partitions_in)</td></tr>
<tr class="separator:a3eb672668727c425a9e166609bc33583"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Store the parameters for a simulation thermostat. Includes Berendsen, Andersen, and Langevin methods. This class can be assembled like many of the control objects, i.e. MinimizationControls, based on namelists. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa3b1268420b7bf664176b451d95398dd" name="aa3b1268420b7bf664176b451d95398dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3b1268420b7bf664176b451d95398dd">&#9670;&#160;</a></span>Thermostat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">stormm::trajectory::Thermostat::Thermostat </td>
          <td>(</td>
          <td class="paramtype">ThermostatKind</td>          <td class="paramname"><span class="paramname"><em>kind_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">ThermostatKind::NONE</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PrecisionModel</td>          <td class="paramname"><span class="paramname"><em>cache_config_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">PrecisionModel::SINGLE</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>random_seed_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">default_thermostat_random_seed</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gpu</em></span><span class="paramdefsep"> = </span><span class="paramdefval">null_gpu</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructors for the <a class="el" href="classstormm_1_1energy_1_1Thermostat.html" title="Store the parameters for a simulation thermostat. Includes Berendsen, Andersen, and Langevin methods....">Thermostat</a> object. Any information can be added via setter functions after constructing the object. </p>
<p>Overloaded:</p><ul>
<li>Construct a blank thermostat that applies no regulation</li>
<li>Construct a specific type of thermostat with default settings</li>
<li>Accept a type of thermostat and a temperature to maintain</li>
<li>Accept a temperature evolution profile</li>
<li>Accept a total number of atoms and a compartmentalization plan</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">temperature_in</td><td>A flat temperature to apply at all times </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b3e8fbe46a5dc8cf8548c278955c107" name="a6b3e8fbe46a5dc8cf8548c278955c107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b3e8fbe46a5dc8cf8548c278955c107">&#9670;&#160;</a></span>Thermostat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">stormm::trajectory::Thermostat::Thermostat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstormm_1_1trajectory_1_1Thermostat.html">Thermostat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>original</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The default copy and move constructors and assignment operators are best for this object with no POINTER-kind <a class="el" href="classstormm_1_1energy_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">original</td><td>The object to copy or move </td></tr>
    <tr><td class="paramname">other</td><td>An object to clone or replace the present object with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad402fa578bbc04a2cf1693633068c574" name="ad402fa578bbc04a2cf1693633068c574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad402fa578bbc04a2cf1693633068c574">&#9670;&#160;</a></span>checkCompartments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::trajectory::Thermostat::checkCompartments </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstormm_1_1synthesis_1_1AtomGraphSynthesis.html">AtomGraphSynthesis</a> *</td>          <td class="paramname"><span class="paramname"><em>poly_ag</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check the compartmentalization if the thermostat regulates a synthesis of systems. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly_ag</td><td>The topology synthesis describing systems to regulate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41991e0a62df864556533c8040b23416" name="a41991e0a62df864556533c8040b23416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41991e0a62df864556533c8040b23416">&#9670;&#160;</a></span>dpData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const ThermostatReader&lt; double &gt; stormm::trajectory::Thermostat::dpData </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the abstract. </p>
<p>Overloaded:</p><ul>
<li>Get a reader for a const object</li>
<li>Get a (partially) writeable abstract for a non-const object</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tier</td><td>Indicate whether to take pointers to memory on the CPU host or on the GPU device </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a439743a19c6fbe8c0b0bd7212732da" name="a3a439743a19c6fbe8c0b0bd7212732da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a439743a19c6fbe8c0b0bd7212732da">&#9670;&#160;</a></span>getAtomTarget()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tcalc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Tcalc stormm::trajectory::Thermostat::getAtomTarget </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>atom_index</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current target temperature for this thermostat, in units of Kelvin, for a specific atom. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">atom_index</td><td>Index of the atom of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7fb2d2bbff483db8b7c25f77c825acac" name="a7fb2d2bbff483db8b7c25f77c825acac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fb2d2bbff483db8b7c25f77c825acac">&#9670;&#160;</a></span>getCachedRandomResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stormm::trajectory::Thermostat::getCachedRandomResult </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>atom_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>cache_row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get one of the cached random numbers. This function returns the result as a double-precision real, but if a single-precision result is queried it will be converted to double and can then be put back in a float without changing its value. For retrieving large numbers of results, one should used the abstract. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">atom_index</td><td>Index of the atom for which to get a result </td></tr>
    <tr><td class="paramname">cache_row</td><td>Row of the cache to query (the 0th row offers a result for Cartesian X influence on the atom, the 4th row offers a result for the Carteisan Y influence on the atom one cycle in the future) </td></tr>
    <tr><td class="paramname">tier</td><td>Indicate whether to take information from the CPU host or GPU device </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a27691a9ce7e547296d143deea770c1d4" name="a27691a9ce7e547296d143deea770c1d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27691a9ce7e547296d143deea770c1d4">&#9670;&#160;</a></span>getFinalTemperature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stormm::trajectory::Thermostat::getFinalTemperature </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>atom_index</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the end-point target temperature for this thermostat, in units of Kelvin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">atom_index</td><td>Index of the atom of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a15bf6daa21a9ecdc04ce470001ef352f" name="a15bf6daa21a9ecdc04ce470001ef352f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15bf6daa21a9ecdc04ce470001ef352f">&#9670;&#160;</a></span>getInitialTemperature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stormm::trajectory::Thermostat::getInitialTemperature </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>atom_index</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the initial target temperature for this thermostat, in units of Kelvin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">atom_index</td><td>Index of the atom of interest (only provided if there are different regulated temperatures for unique subsets of atoms) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24855ca9ac0af8b01b8c67a3c9217324" name="a24855ca9ac0af8b01b8c67a3c9217324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24855ca9ac0af8b01b8c67a3c9217324">&#9670;&#160;</a></span>getPartitionConstrainedDoF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stormm::trajectory::Thermostat::getPartitionConstrainedDoF </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of constrained degrees of freedom for a particular partition of this thermostat. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the partition of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5cd98a37bfb7a96809f546c49b8909c0" name="a5cd98a37bfb7a96809f546c49b8909c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cd98a37bfb7a96809f546c49b8909c0">&#9670;&#160;</a></span>getPartitionFreeDoF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stormm::trajectory::Thermostat::getPartitionFreeDoF </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of degrees of freedom for a particular partition of this thermostat, in absence of any constraints. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the partition of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab068c78f11ccf704848481221169969c" name="ab068c78f11ccf704848481221169969c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab068c78f11ccf704848481221169969c">&#9670;&#160;</a></span>getPartitionTarget()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tcalc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Tcalc stormm::trajectory::Thermostat::getPartitionTarget </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current target temperature for a specific partition within this thermostat, in units of Kelvin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the partition of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a783d37481306a98b8f4960af4941e0d6" name="a783d37481306a98b8f4960af4941e0d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a783d37481306a98b8f4960af4941e0d6">&#9670;&#160;</a></span>getTemperatureSpread()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; stormm::trajectory::Thermostat::getTemperatureSpread </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>step_number</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the spread of temperature targets for all segments of the thermostat at a specific time step. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">step_number</td><td>The step at which to assess the temperature targets </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57627ebd666e6e42b678a99ed6ec4e90" name="a57627ebd666e6e42b678a99ed6ec4e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57627ebd666e6e42b678a99ed6ec4e90">&#9670;&#160;</a></span>initializeRandomStates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::trajectory::Thermostat::initializeRandomStates </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>new_seed</em></span><span class="paramdefsep"> = </span><span class="paramdefval">default_thermostat_random_seed</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>scrub_cycles</em></span><span class="paramdefsep"> = </span><span class="paramdefval">25</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gpu</em></span><span class="paramdefsep"> = </span><span class="paramdefval">null_gpu</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the random state vectors of a thermostat, whether for Langevin or Andersen thermostating. This passes a call on to a general-purpose function for seeding the generators and will recruit the GPU if available to expedite the process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_seed</td><td>A new random number seed to apply, if different from the one used during construction of this <a class="el" href="classstormm_1_1energy_1_1Thermostat.html" title="Store the parameters for a simulation thermostat. Includes Berendsen, Andersen, and Langevin methods....">Thermostat</a> object </td></tr>
    <tr><td class="paramname">scrub_cycles</td><td>Number of cycles of Xoshiro256++ generation to run in order to ensure that the newly seeded generators produce high-quality results </td></tr>
    <tr><td class="paramname">tier</td><td>Indicate whether to seed random states and cached numbers on the CPU host alone, or on the GPU device. Random number state vectors will be mirrored at both levels of memory if the GPU device layer is initialized, but the generators will not be advanced on the host. </td></tr>
    <tr><td class="paramname">gpu</td><td>Specifications of the GPU in use (if applicable) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c1bd5bed4dbf6e26574ac9f272b4a84" name="a4c1bd5bed4dbf6e26574ac9f272b4a84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c1bd5bed4dbf6e26574ac9f272b4a84">&#9670;&#160;</a></span>refresh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::trajectory::Thermostat::refresh </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index_start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index_end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>refresh_depth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill or refill the random number cache for a subset of the atoms, advancing the thermostat's random number generators in the process. This CPU-based function is intended to mimic GPU functionality, but the GPU operations are expected to be fused with other kernels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index_start</td><td>Starting index in the list of all atoms </td></tr>
    <tr><td class="paramname">index_end</td><td>Upper bound of atoms for which to cache random numbers </td></tr>
    <tr><td class="paramname">refresh_depth</td><td>The depth to which the cache is to be refreshed (the default of 0 will refresh all layers of prepared random numbers) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa199f910b9825be22d42dee1dfcc24ee" name="aa199f910b9825be22d42dee1dfcc24ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa199f910b9825be22d42dee1dfcc24ee">&#9670;&#160;</a></span>setAndersenResetFrequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::trajectory::Thermostat::setAndersenResetFrequency </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>andersen_frequency_in</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the Andersen velocity reassignment frequency. This will be taken from user input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">andersen_frequency_in</td><td>The number of time steps between Andersen velocity resets </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a374331fb63408577ccf0918137c53275" name="a374331fb63408577ccf0918137c53275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a374331fb63408577ccf0918137c53275">&#9670;&#160;</a></span>setAtomCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::trajectory::Thermostat::setAtomCount </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>atom_count_in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>new_seed</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gpu</em></span><span class="paramdefsep"> = </span><span class="paramdefval">null_gpu</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the number of atoms for which the thermostat is responsible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">atom_count_in</td><td>The total number of atoms to assign to this thermostat, whether all part of one system or a padded number collected within a synthesis </td></tr>
    <tr><td class="paramname">new_seed</td><td>New random number generator seed for initializing the random cache (if applicable). If set to -1, the object's original seed will be taken. Otherwise, the object will later record having been initialized with new_seed. </td></tr>
    <tr><td class="paramname">gpu</td><td>Details of any available GPU. If a real GPU is available, the random state vectors and cache will be initialized on the CPU host as well as the GPU device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a347ee6c5d98ecac289d3ceff6e67bffe" name="a347ee6c5d98ecac289d3ceff6e67bffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a347ee6c5d98ecac289d3ceff6e67bffe">&#9670;&#160;</a></span>setCacheConfiguration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::trajectory::Thermostat::setCacheConfiguration </td>
          <td>(</td>
          <td class="paramtype">PrecisionModel</td>          <td class="paramname"><span class="paramname"><em>cache_config_in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gpu</em></span><span class="paramdefsep"> = </span><span class="paramdefval">null_gpu</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the random number cache configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache_config_in</td><td>The manner in which the cache is to be configured, storing random numbers in single- or double-precision </td></tr>
    <tr><td class="paramname">gpu</td><td>Details of the GPU that will handle future calculations with this thermostat. This is critical for getting random state vectors initialized on the GPU. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae051d1b8bec47f4a600778ae7b579523" name="ae051d1b8bec47f4a600778ae7b579523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae051d1b8bec47f4a600778ae7b579523">&#9670;&#160;</a></span>setEvolutionWindow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::trajectory::Thermostat::setEvolutionWindow </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>init_step_in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>final_step_in</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the step at which temperature evolution, away from T(init), shall begin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init_step_in</td><td>Step number at which temperature evolution begins. Prior to this step, each bath's target temperature is its initial temperature. Following this step, the target temperature of each bath becomes a linear mixture of the initial and final temperatures. </td></tr>
    <tr><td class="paramname">init_step_in</td><td>Step number at which temperature evolution ends. After this point, the final temperature of each bath is the target. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae330b45b89ffd44b036df1e53b20a195" name="ae330b45b89ffd44b036df1e53b20a195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae330b45b89ffd44b036df1e53b20a195">&#9670;&#160;</a></span>setGeometryConstraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::trajectory::Thermostat::setGeometryConstraints </td>
          <td>(</td>
          <td class="paramtype">ApplyConstraints</td>          <td class="paramname"><span class="paramname"><em>cnst_geometry_in</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the instruction for carrying out geometric constraints during dynamics. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cnst_geometry_in</td><td>The order for constraints to be applied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a129fa8ff189dd4030971dcd534bc8d7b" name="a129fa8ff189dd4030971dcd534bc8d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a129fa8ff189dd4030971dcd534bc8d7b">&#9670;&#160;</a></span>setLangevinCollisionFrequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::trajectory::Thermostat::setLangevinCollisionFrequency </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>langevin_frequency_in</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the collision frequency for the Langevin thermostat. This will also set the scaled form of the value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">langevin_frequency_in</td><td>The collision frequency to take, in events per femtosecond </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a459ebd1a64500cb32b70972c2e2589e3" name="a459ebd1a64500cb32b70972c2e2589e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a459ebd1a64500cb32b70972c2e2589e3">&#9670;&#160;</a></span>setRandomCacheDepth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::trajectory::Thermostat::setRandomCacheDepth </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>depth_in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gpu</em></span><span class="paramdefsep"> = </span><span class="paramdefval">null_gpu</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the random number cache depth. This value is kept on a tight leash, as it can easily lead to allocating too much memory. A hundred-thousand atom system with cache depth 8 leads to over 13.7MB of memory allocation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depth_in</td><td>The depth to take </td></tr>
    <tr><td class="paramname">gpu</td><td>Details of the GPU that will handle future calculations with this thermostat. This is critical for getting random state vectors initialized on the GPU. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1116aea8575d84e31a962fcc56d714e8" name="a1116aea8575d84e31a962fcc56d714e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1116aea8575d84e31a962fcc56d714e8">&#9670;&#160;</a></span>setRattleIterations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::trajectory::Thermostat::setRattleIterations </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rattle_iterations_in</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the maximum number of iterations to take when attempting to converge RATTLE bond length constraints. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rattle_iterations_in</td><td>The number of iterations to permit </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a08d3947cf1eef66cf9cf9f5860ca9ad7" name="a08d3947cf1eef66cf9cf9f5860ca9ad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08d3947cf1eef66cf9cf9f5860ca9ad7">&#9670;&#160;</a></span>setRattleTolerance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::trajectory::Thermostat::setRattleTolerance </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>rattle_tolerance_in</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the convergence criterion for RATTLE. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rattle_tolerance_in</td><td>The convergence criterion to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b9b3557690fcd8e46087b39a1f2a09b" name="a5b9b3557690fcd8e46087b39a1f2a09b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b9b3557690fcd8e46087b39a1f2a09b">&#9670;&#160;</a></span>setSynthesisForceLoading()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::trajectory::Thermostat::setSynthesisForceLoading </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>load_synthesis_forces_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the integrator to take prior force computations residing in the <a class="el" href="classstormm_1_1energy_1_1PhaseSpaceSynthesis.html" title="A fixed-precision representation of coordinates, velocities, and forces to manage a set of simulation...">PhaseSpaceSynthesis</a> into account. This will have an effect in the dynamics of periodic systems when particle movement is fused to valence interaction computations. In this situation, by default all prior force computations would be expected to reside in the neighbor list grid (non-bonded forces). For non-periodic calculations, all prior force computations will be expected to accumulate in the <a class="el" href="classstormm_1_1energy_1_1PhaseSpaceSynthesis.html" title="A fixed-precision representation of coordinates, velocities, and forces to manage a set of simulation...">PhaseSpaceSynthesis</a>, meaning that this setting will have no effect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">load_synthesis_forces_in</td><td>Indicate whether the synthesis forces shuld be loaded </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1faa9feacbd631e88ad7279b14fd7cd2" name="a1faa9feacbd631e88ad7279b14fd7cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1faa9feacbd631e88ad7279b14fd7cd2">&#9670;&#160;</a></span>setTemperature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::trajectory::Thermostat::setTemperature </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>initial_temperature_in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>final_temperature_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1.0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the initial target temperature. </p>
<p>Overloaded:</p><ul>
<li>Set the temperature to a single value (if the final temperatures are also consistent, this will set common_temperature to TRUE and de-allocate any existing <a class="el" href="classstormm_1_1energy_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> data related to unique temperature compartments).</li>
<li>Set the temperatures of unique subsets of the atoms to a series of values based on a compartmentalization</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init_temp_in</td><td>Temperature or temperatures that the thermostat shall start with, and continue to apply until the initial step in its evolution </td></tr>
    <tr><td class="paramname">partitions_in</td><td>A new compartmentalization scheme (the same interpretation described in setCompartments() above applies) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3863aca60b98ec7bd76ce0c4882b440d" name="a3863aca60b98ec7bd76ce0c4882b440d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3863aca60b98ec7bd76ce0c4882b440d">&#9670;&#160;</a></span>setTimeStep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::trajectory::Thermostat::setTimeStep </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>time_step_in</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the time step. This will also set the scaled form of the value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time_step_in</td><td>The time step to take, in units of femtoseconds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6cdc85e0495c5a1b04b63857bbbee25e" name="a6cdc85e0495c5a1b04b63857bbbee25e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cdc85e0495c5a1b04b63857bbbee25e">&#9670;&#160;</a></span>validateEvolutionWindow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::trajectory::Thermostat::validateEvolutionWindow </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validate the initial and final steps for applying the temperature evolution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">step_in</td><td>The step number to validate (it will be checked for a positive value) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/Trajectory/<a class="el" href="thermostat_8h_source.html">thermostat.h</a></li>
<li>src/Trajectory/<b>thermostat.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2
</small></address>
</div><!-- doc-content -->
</body>
</html>
