<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>STORMM Source Documentation: stormm::energy::PPITable Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">STORMM Source Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>stormm</b></li><li class="navelem"><b>energy</b></li><li class="navelem"><a class="el" href="classstormm_1_1energy_1_1PPITable.html">PPITable</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classstormm_1_1energy_1_1PPITable-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">stormm::energy::PPITable Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A tabulated non-bonded potential, with or without exclusions, to be used in the context of particle-particle, particle-mesh calculations. The key is to create two tables, one for the non-excluded form of the interaction and the other for the excluded form. The entries for each table will then be concatenated, such that all non-excluded interactions are contiguous and then all exclude interactions are contiguous. The offset for accessing an excluded interaction based on an index calculated from a particle-particle distance is stored alongside the tabulated splines in the abstract.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ppitable_8h_source.html">ppitable.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae9bb7e1cde3df0be1469b5a3ac549c98" id="r_ae9bb7e1cde3df0be1469b5a3ac549c98"><td class="memItemLeft" align="right" valign="top"><a id="ae9bb7e1cde3df0be1469b5a3ac549c98" name="ae9bb7e1cde3df0be1469b5a3ac549c98"></a>
NonbondedTheme&#160;</td><td class="memItemRight" valign="bottom"><b>getTheme</b> () const</td></tr>
<tr class="memdesc:ae9bb7e1cde3df0be1469b5a3ac549c98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the non-bonded potential described by an object of this class. <br /></td></tr>
<tr class="separator:ae9bb7e1cde3df0be1469b5a3ac549c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f8b0709382cc0ffce40c462e8a92cf" id="r_af7f8b0709382cc0ffce40c462e8a92cf"><td class="memItemLeft" align="right" valign="top"><a id="af7f8b0709382cc0ffce40c462e8a92cf" name="af7f8b0709382cc0ffce40c462e8a92cf"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getCutoff</b> () const</td></tr>
<tr class="memdesc:af7f8b0709382cc0ffce40c462e8a92cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the cutoff on particle-particle interactions. <br /></td></tr>
<tr class="separator:af7f8b0709382cc0ffce40c462e8a92cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bcd64e1e5119ca81619699531db5225" id="r_a0bcd64e1e5119ca81619699531db5225"><td class="memItemLeft" align="right" valign="top"><a id="a0bcd64e1e5119ca81619699531db5225" name="a0bcd64e1e5119ca81619699531db5225"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getMaximumRange</b> () const</td></tr>
<tr class="memdesc:a0bcd64e1e5119ca81619699531db5225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum range of the spline. <br /></td></tr>
<tr class="separator:a0bcd64e1e5119ca81619699531db5225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f234b441f0a36dfe2778dd9e9ad08b" id="r_a12f234b441f0a36dfe2778dd9e9ad08b"><td class="memItemLeft" align="right" valign="top"><a id="a12f234b441f0a36dfe2778dd9e9ad08b" name="a12f234b441f0a36dfe2778dd9e9ad08b"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getIndexingOffset</b> () const</td></tr>
<tr class="memdesc:a12f234b441f0a36dfe2778dd9e9ad08b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the indexing argument offset, consistent across all tables. <br /></td></tr>
<tr class="separator:a12f234b441f0a36dfe2778dd9e9ad08b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dc9ead7b1597acc65cebc5530769197" id="r_a9dc9ead7b1597acc65cebc5530769197"><td class="memItemLeft" align="right" valign="top"><a id="a9dc9ead7b1597acc65cebc5530769197" name="a9dc9ead7b1597acc65cebc5530769197"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getDirectSumTolerance</b> () const</td></tr>
<tr class="memdesc:a9dc9ead7b1597acc65cebc5530769197"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the direct sum tolerance. <br /></td></tr>
<tr class="separator:a9dc9ead7b1597acc65cebc5530769197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6a1bbed8cdec5551d2ec704c899b78" id="r_a8e6a1bbed8cdec5551d2ec704c899b78"><td class="memItemLeft" align="right" valign="top"><a id="a8e6a1bbed8cdec5551d2ec704c899b78" name="a8e6a1bbed8cdec5551d2ec704c899b78"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getBitStride</b> () const</td></tr>
<tr class="memdesc:a8e6a1bbed8cdec5551d2ec704c899b78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of bits of the mantissa used for table indexing. <br /></td></tr>
<tr class="separator:a8e6a1bbed8cdec5551d2ec704c899b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a121255523b824f3f760eb15f731cd935" id="r_a121255523b824f3f760eb15f731cd935"><td class="memItemLeft" align="right" valign="top"><a id="a121255523b824f3f760eb15f731cd935" name="a121255523b824f3f760eb15f731cd935"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getEwaldCoefficient</b> () const</td></tr>
<tr class="memdesc:a121255523b824f3f760eb15f731cd935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Ewald coefficient used to perform the switching between short- and long-ranged potentials. <br /></td></tr>
<tr class="separator:a121255523b824f3f760eb15f731cd935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a562afcd36997606688869a6eb1a911e2" id="r_a562afcd36997606688869a6eb1a911e2"><td class="memItemLeft" align="right" valign="top"><a id="a562afcd36997606688869a6eb1a911e2" name="a562afcd36997606688869a6eb1a911e2"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getGaussianWidth</b> () const</td></tr>
<tr class="memdesc:a562afcd36997606688869a6eb1a911e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Gaussian RMS sigma parameter (one half the inverse of the Ewald coefficient) used to perform the switching between short- and long-ranged potentials. <br /></td></tr>
<tr class="separator:a562afcd36997606688869a6eb1a911e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b5ddcf6231fdb3849648368c233e4c0" id="r_a4b5ddcf6231fdb3849648368c233e4c0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b5ddcf6231fdb3849648368c233e4c0">getTableIndex</a> (double arg, PrecisionModel prec=PrecisionModel::SINGLE) const</td></tr>
<tr class="memdesc:a4b5ddcf6231fdb3849648368c233e4c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the spline index that would be accessed in order to evaluate a given argument.  <br /></td></tr>
<tr class="separator:a4b5ddcf6231fdb3849648368c233e4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a3e551d338301231fd31ba805e6397" id="r_a43a3e551d338301231fd31ba805e6397"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43a3e551d338301231fd31ba805e6397">getTableIndexByRealArg</a> (double arg, PrecisionModel prec=PrecisionModel::SINGLE) const</td></tr>
<tr class="memdesc:a43a3e551d338301231fd31ba805e6397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the spline index that would be accessed in order to evaluate a given argument.  <br /></td></tr>
<tr class="separator:a43a3e551d338301231fd31ba805e6397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4953aa1a60f1157b7a3d5e6a53ec93" id="r_a6e4953aa1a60f1157b7a3d5e6a53ec93"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e4953aa1a60f1157b7a3d5e6a53ec93">evaluate</a> (double arg, LogSplineForm kind, PrecisionModel prec=PrecisionModel::SINGLE, bool use_elemental_tables=false) const</td></tr>
<tr class="memdesc:a6e4953aa1a60f1157b7a3d5e6a53ec93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the spline table at a given inter-particle distance expressed in the manner used for the class object's table indexing. For example, if the object indexes its tables by the squared value of the displacement, enter 49.0 A^2 in order to get the force, energy, or excluded form thereof for two particles separated by a distance of 7.0 A.  <br /></td></tr>
<tr class="separator:a6e4953aa1a60f1157b7a3d5e6a53ec93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4269a7eeeaa2904d1cd43d17062ebdc" id="r_ae4269a7eeeaa2904d1cd43d17062ebdc"><td class="memItemLeft" align="right" valign="top"><a id="ae4269a7eeeaa2904d1cd43d17062ebdc" name="ae4269a7eeeaa2904d1cd43d17062ebdc"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>evaluateByRealArg</b> (double arg, LogSplineForm kind, PrecisionModel prec=PrecisionModel::SINGLE, bool use_elemental_tables=false) const</td></tr>
<tr class="memdesc:ae4269a7eeeaa2904d1cd43d17062ebdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the spline table at a given inter-particle distance expressed as the absolute value of the displacement between two particles. Descriptions of input parameters otherwise follow from <a class="el" href="#a6e4953aa1a60f1157b7a3d5e6a53ec93" title="Evaluate the spline table at a given inter-particle distance expressed in the manner used for the cla...">evaluate()</a>, above. <br /></td></tr>
<tr class="separator:ae4269a7eeeaa2904d1cd43d17062ebdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2acaa65ff111fe306af58d624d652457" id="r_a2acaa65ff111fe306af58d624d652457"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structstormm_1_1energy_1_1PPIKit.html">PPIKit</a>&lt; double, <a class="el" href="structstormm_1_1data__types_1_1double4.html">double4</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2acaa65ff111fe306af58d624d652457">dpData</a> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:a2acaa65ff111fe306af58d624d652457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the double-precision abstract for use of the splines in a C programming style.  <br /></td></tr>
<tr class="separator:a2acaa65ff111fe306af58d624d652457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4980f3cdc8186dbb53ba07a0127bc152" id="r_a4980f3cdc8186dbb53ba07a0127bc152"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structstormm_1_1energy_1_1PPIKit.html">PPIKit</a>&lt; float, <a class="el" href="structstormm_1_1data__types_1_1float4.html">float4</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4980f3cdc8186dbb53ba07a0127bc152">spData</a> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:a4980f3cdc8186dbb53ba07a0127bc152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the single-precision abstract for use of the splines in a C programming style.  <br /></td></tr>
<tr class="separator:a4980f3cdc8186dbb53ba07a0127bc152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b2d043634208aca218436ac4f7a7b4" id="r_a34b2d043634208aca218436ac4f7a7b4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structstormm_1_1energy_1_1PPIeKit.html">PPIeKit</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34b2d043634208aca218436ac4f7a7b4">dpeData</a> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:a34b2d043634208aca218436ac4f7a7b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the double-precision abstract for use of the splines in a C programming style, with all spline tuples broken into their individual components. This abstract may be more suitable for kernels where register pressure constrains performance.  <br /></td></tr>
<tr class="separator:a34b2d043634208aca218436ac4f7a7b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028cafec293523836a5caa35c6c8e034" id="r_a028cafec293523836a5caa35c6c8e034"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structstormm_1_1energy_1_1PPIeKit.html">PPIeKit</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a028cafec293523836a5caa35c6c8e034">speData</a> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:a028cafec293523836a5caa35c6c8e034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the single-precision abstract for use of the splines in a C programming style, with all spline tuples broken into their individual components. This abstract may be more suitable for kernels where register pressure constrains performance.  <br /></td></tr>
<tr class="separator:a028cafec293523836a5caa35c6c8e034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4c7c24639b540d56c067e27909595137" id="r_a4c7c24639b540d56c067e27909595137"><td class="memItemLeft" align="right" valign="top"><a id="a4c7c24639b540d56c067e27909595137" name="a4c7c24639b540d56c067e27909595137"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PPITable</b> (NonbondedTheme theme_in=NonbondedTheme::ELECTROSTATIC, BasisFunctions basis_set_in=BasisFunctions::POLYNOMIAL, TableIndexing indexing_method_in=TableIndexing::SQUARED_ARG, double cutoff_in=default_pme_cutoff, double argument_offset_in=0.0, double dsum_tol_in=default_dsum_tol, int mantissa_bits_in=5, double coulomb_in=amber_ancient_bioq, double min_range_in=0.015625)</td></tr>
<tr class="memdesc:a4c7c24639b540d56c067e27909595137"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constuctor can accept all of the arguments that might be useful for making a LosScaleSpline, or a <a class="el" href="classstormm_1_1energy_1_1LogScaleSpline.html" title="A logarithmic spline can be very useful for interpolating functions that are steepest at low values o...">LogScaleSpline</a> itself. Tables for both the otential and the derivative will be computed. <br /></td></tr>
<tr class="separator:a4c7c24639b540d56c067e27909595137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f594bd8724df71139135944d603797" id="r_a33f594bd8724df71139135944d603797"><td class="memTemplParams" colspan="2"><a id="a33f594bd8724df71139135944d603797" name="a33f594bd8724df71139135944d603797"></a>
template&lt;typename T4&gt; </td></tr>
<tr class="memitem:a33f594bd8724df71139135944d603797"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PPITable</b> (const <a class="el" href="classstormm_1_1stmath_1_1LogScaleSpline.html">LogScaleSpline</a>&lt; T4 &gt; &amp;spl_a, const <a class="el" href="classstormm_1_1stmath_1_1LogScaleSpline.html">LogScaleSpline</a>&lt; T4 &gt; &amp;spl_b, const <a class="el" href="classstormm_1_1stmath_1_1LogScaleSpline.html">LogScaleSpline</a>&lt; T4 &gt; &amp;spl_c, const <a class="el" href="classstormm_1_1stmath_1_1LogScaleSpline.html">LogScaleSpline</a>&lt; T4 &gt; &amp;spl_d, double cutoff_in=default_pme_cutoff)</td></tr>
<tr class="separator:a33f594bd8724df71139135944d603797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f1f82d0d96355c5400f08fdf78b77d" id="r_ad5f1f82d0d96355c5400f08fdf78b77d"><td class="memTemplParams" colspan="2"><a id="ad5f1f82d0d96355c5400f08fdf78b77d" name="ad5f1f82d0d96355c5400f08fdf78b77d"></a>
template&lt;typename T4&gt; </td></tr>
<tr class="memitem:ad5f1f82d0d96355c5400f08fdf78b77d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PPITable</b> (const <a class="el" href="classstormm_1_1stmath_1_1LogScaleSpline.html">LogScaleSpline</a>&lt; T4 &gt; &amp;spl_a, const <a class="el" href="classstormm_1_1stmath_1_1LogScaleSpline.html">LogScaleSpline</a>&lt; T4 &gt; &amp;spl_b, const <a class="el" href="classstormm_1_1stmath_1_1LogScaleSpline.html">LogScaleSpline</a>&lt; T4 &gt; &amp;spl_c)</td></tr>
<tr class="separator:ad5f1f82d0d96355c5400f08fdf78b77d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec4fa7b88f87d374be2b4a947cd537b" id="r_a7ec4fa7b88f87d374be2b4a947cd537b"><td class="memTemplParams" colspan="2"><a id="a7ec4fa7b88f87d374be2b4a947cd537b" name="a7ec4fa7b88f87d374be2b4a947cd537b"></a>
template&lt;typename T4&gt; </td></tr>
<tr class="memitem:a7ec4fa7b88f87d374be2b4a947cd537b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PPITable</b> (const <a class="el" href="classstormm_1_1stmath_1_1LogScaleSpline.html">LogScaleSpline</a>&lt; T4 &gt; &amp;spl_a, const <a class="el" href="classstormm_1_1stmath_1_1LogScaleSpline.html">LogScaleSpline</a>&lt; T4 &gt; &amp;spl_b)</td></tr>
<tr class="separator:a7ec4fa7b88f87d374be2b4a947cd537b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f43ad32504ed4648c76ce7832913e34" id="r_a2f43ad32504ed4648c76ce7832913e34"><td class="memTemplParams" colspan="2"><a id="a2f43ad32504ed4648c76ce7832913e34" name="a2f43ad32504ed4648c76ce7832913e34"></a>
template&lt;typename T4&gt; </td></tr>
<tr class="memitem:a2f43ad32504ed4648c76ce7832913e34"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PPITable</b> (const <a class="el" href="classstormm_1_1stmath_1_1LogScaleSpline.html">LogScaleSpline</a>&lt; T4 &gt; &amp;spl_a)</td></tr>
<tr class="separator:a2f43ad32504ed4648c76ce7832913e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4e1e951429a65009d6801c22d9b42cf0" id="r_a4e1e951429a65009d6801c22d9b42cf0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e1e951429a65009d6801c22d9b42cf0">PPITable</a> (const <a class="el" href="classstormm_1_1energy_1_1PPITable.html">PPITable</a> &amp;original)</td></tr>
<tr class="memdesc:a4e1e951429a65009d6801c22d9b42cf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The presence of POINTER-kind <a class="el" href="classstormm_1_1energy_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> objects implies pointer repairs that require the copy and move constructors as well as assignment operators to be spelled out.  <br /></td></tr>
<tr class="separator:a4e1e951429a65009d6801c22d9b42cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aee3012ddb7a8e9d5626974bbfa4a79" id="r_a5aee3012ddb7a8e9d5626974bbfa4a79"><td class="memItemLeft" align="right" valign="top"><a id="a5aee3012ddb7a8e9d5626974bbfa4a79" name="a5aee3012ddb7a8e9d5626974bbfa4a79"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PPITable</b> (<a class="el" href="classstormm_1_1energy_1_1PPITable.html">PPITable</a> &amp;&amp;original)</td></tr>
<tr class="separator:a5aee3012ddb7a8e9d5626974bbfa4a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754ce900d4f4dfcd1b278e221b3e51ea" id="r_a754ce900d4f4dfcd1b278e221b3e51ea"><td class="memItemLeft" align="right" valign="top"><a id="a754ce900d4f4dfcd1b278e221b3e51ea" name="a754ce900d4f4dfcd1b278e221b3e51ea"></a>
<a class="el" href="classstormm_1_1energy_1_1PPITable.html">PPITable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classstormm_1_1energy_1_1PPITable.html">PPITable</a> &amp;original)</td></tr>
<tr class="separator:a754ce900d4f4dfcd1b278e221b3e51ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0506cab630ab4ca92b63bfe83db726e" id="r_ac0506cab630ab4ca92b63bfe83db726e"><td class="memItemLeft" align="right" valign="top"><a id="ac0506cab630ab4ca92b63bfe83db726e" name="ac0506cab630ab4ca92b63bfe83db726e"></a>
<a class="el" href="classstormm_1_1energy_1_1PPITable.html">PPITable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classstormm_1_1energy_1_1PPITable.html">PPITable</a> &amp;&amp;original)</td></tr>
<tr class="separator:ac0506cab630ab4ca92b63bfe83db726e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A tabulated non-bonded potential, with or without exclusions, to be used in the context of particle-particle, particle-mesh calculations. The key is to create two tables, one for the non-excluded form of the interaction and the other for the excluded form. The entries for each table will then be concatenated, such that all non-excluded interactions are contiguous and then all exclude interactions are contiguous. The offset for accessing an excluded interaction based on an index calculated from a particle-particle distance is stored alongside the tabulated splines in the abstract. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4e1e951429a65009d6801c22d9b42cf0" name="a4e1e951429a65009d6801c22d9b42cf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e1e951429a65009d6801c22d9b42cf0">&#9670;&#160;</a></span>PPITable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">stormm::energy::PPITable::PPITable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstormm_1_1energy_1_1PPITable.html">PPITable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>original</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The presence of POINTER-kind <a class="el" href="classstormm_1_1energy_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> objects implies pointer repairs that require the copy and move constructors as well as assignment operators to be spelled out. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">original</td><td>THe original object to copy or move </td></tr>
    <tr><td class="paramname">other</td><td>Another object placed on the right hand side of the assignment statement </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2acaa65ff111fe306af58d624d652457" name="a2acaa65ff111fe306af58d624d652457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2acaa65ff111fe306af58d624d652457">&#9670;&#160;</a></span>dpData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structstormm_1_1energy_1_1PPIKit.html">PPIKit</a>&lt; double, <a class="el" href="structstormm_1_1data__types_1_1double4.html">double4</a> &gt; stormm::energy::PPITable::dpData </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the double-precision abstract for use of the splines in a C programming style. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tier</td><td>Indicate whether to obtain pointers for data on the CPU host or GPU device </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a34b2d043634208aca218436ac4f7a7b4" name="a34b2d043634208aca218436ac4f7a7b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34b2d043634208aca218436ac4f7a7b4">&#9670;&#160;</a></span>dpeData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structstormm_1_1energy_1_1PPIeKit.html">PPIeKit</a>&lt; double &gt; stormm::energy::PPITable::dpeData </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the double-precision abstract for use of the splines in a C programming style, with all spline tuples broken into their individual components. This abstract may be more suitable for kernels where register pressure constrains performance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tier</td><td>Indicate whether to obtain pointers for data on the CPU host or GPU device </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e4953aa1a60f1157b7a3d5e6a53ec93" name="a6e4953aa1a60f1157b7a3d5e6a53ec93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e4953aa1a60f1157b7a3d5e6a53ec93">&#9670;&#160;</a></span>evaluate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stormm::energy::PPITable::evaluate </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LogSplineForm</td>          <td class="paramname"><span class="paramname"><em>kind</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PrecisionModel</td>          <td class="paramname"><span class="paramname"><em>prec</em></span><span class="paramdefsep"> = </span><span class="paramdefval">PrecisionModel::SINGLE</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>use_elemental_tables</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the spline table at a given inter-particle distance expressed in the manner used for the class object's table indexing. For example, if the object indexes its tables by the squared value of the displacement, enter 49.0 A^2 in order to get the force, energy, or excluded form thereof for two particles separated by a distance of 7.0 A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The value of the spline table indexing argument </td></tr>
    <tr><td class="paramname">kind</td><td>Indicate whether to evaluate the potential, the force, or an excluded form of either quantity </td></tr>
    <tr><td class="paramname">prec</td><td>The precision of the table from which to retrieve calculations (also implies a precision model for the spline calculation) </td></tr>
    <tr><td class="paramname">use_elemental_tables</td><td>Indicate whether to use elementwise tables, in which each of the spline coefficients are accessed individually, or tuple tables in which they are all accessed at once. The default behavior is to use tuple-baed tables. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b5ddcf6231fdb3849648368c233e4c0" name="a4b5ddcf6231fdb3849648368c233e4c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b5ddcf6231fdb3849648368c233e4c0">&#9670;&#160;</a></span>getTableIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stormm::energy::PPITable::getTableIndex </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PrecisionModel</td>          <td class="paramname"><span class="paramname"><em>prec</em></span><span class="paramdefsep"> = </span><span class="paramdefval">PrecisionModel::SINGLE</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the spline index that would be accessed in order to evaluate a given argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The value of the spline table indexing argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a43a3e551d338301231fd31ba805e6397" name="a43a3e551d338301231fd31ba805e6397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43a3e551d338301231fd31ba805e6397">&#9670;&#160;</a></span>getTableIndexByRealArg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stormm::energy::PPITable::getTableIndexByRealArg </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PrecisionModel</td>          <td class="paramname"><span class="paramname"><em>prec</em></span><span class="paramdefsep"> = </span><span class="paramdefval">PrecisionModel::SINGLE</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the spline index that would be accessed in order to evaluate a given argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The value of the spline table indexing argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4980f3cdc8186dbb53ba07a0127bc152" name="a4980f3cdc8186dbb53ba07a0127bc152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4980f3cdc8186dbb53ba07a0127bc152">&#9670;&#160;</a></span>spData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structstormm_1_1energy_1_1PPIKit.html">PPIKit</a>&lt; float, <a class="el" href="structstormm_1_1data__types_1_1float4.html">float4</a> &gt; stormm::energy::PPITable::spData </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the single-precision abstract for use of the splines in a C programming style. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tier</td><td>Indicate whether to obtain pointers for data on the CPU host or GPU device </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a028cafec293523836a5caa35c6c8e034" name="a028cafec293523836a5caa35c6c8e034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a028cafec293523836a5caa35c6c8e034">&#9670;&#160;</a></span>speData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structstormm_1_1energy_1_1PPIeKit.html">PPIeKit</a>&lt; float &gt; stormm::energy::PPITable::speData </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the single-precision abstract for use of the splines in a C programming style, with all spline tuples broken into their individual components. This abstract may be more suitable for kernels where register pressure constrains performance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tier</td><td>Indicate whether to obtain pointers for data on the CPU host or GPU device </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/Potential/<a class="el" href="ppitable_8h_source.html">ppitable.h</a></li>
<li>src/Potential/<b>ppitable.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2
</small></address>
</div><!-- doc-content -->
</body>
</html>
