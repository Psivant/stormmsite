<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>STORMM Source Documentation: stormm::mm::CellGrid&lt; T, Tacc, Tcalc, T4 &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">STORMM Source Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>stormm</b></li><li class="navelem"><b>mm</b></li><li class="navelem"><a class="el" href="classstormm_1_1mm_1_1CellGrid.html">CellGrid</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classstormm_1_1mm_1_1CellGrid-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">stormm::mm::CellGrid&lt; T, Tacc, Tcalc, T4 &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>An object to manage the spatial decomposition of a system of particles. The general strategy is to arrange particles in a grid of cells, each at least half the direct-space cutoff in width in all directions. A work unit entails computing all interactions assigned to one of the cells. This is done using a neutral-territory decomposition the lines of the "tower-plate" arrangement, which consists of seventeen cells:  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cellgrid_8h_source.html">cellgrid.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0f0a2a0af0dbf3fef0b25416d79355e8" id="r_a0f0a2a0af0dbf3fef0b25416d79355e8"><td class="memItemLeft" align="right" valign="top"><a id="a0f0a2a0af0dbf3fef0b25416d79355e8" name="a0f0a2a0af0dbf3fef0b25416d79355e8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getSystemCount</b> () const</td></tr>
<tr class="memdesc:a0f0a2a0af0dbf3fef0b25416d79355e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of systems in the object. <br /></td></tr>
<tr class="separator:a0f0a2a0af0dbf3fef0b25416d79355e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10548ec5e6099f6728321acf522cdb5c" id="r_a10548ec5e6099f6728321acf522cdb5c"><td class="memItemLeft" align="right" valign="top"><a id="a10548ec5e6099f6728321acf522cdb5c" name="a10548ec5e6099f6728321acf522cdb5c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getTotalCellCount</b> () const</td></tr>
<tr class="memdesc:a10548ec5e6099f6728321acf522cdb5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of cells allocated in the object. <br /></td></tr>
<tr class="separator:a10548ec5e6099f6728321acf522cdb5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859460d2f8ef863c52c53a197dc2d3ce" id="r_a859460d2f8ef863c52c53a197dc2d3ce"><td class="memItemLeft" align="right" valign="top"><a id="a859460d2f8ef863c52c53a197dc2d3ce" name="a859460d2f8ef863c52c53a197dc2d3ce"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>getCellBaseCapacity</b> () const</td></tr>
<tr class="memdesc:a859460d2f8ef863c52c53a197dc2d3ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the base capacity of any particular cell in the grid. All systems' cells share the same base capacity. <br /></td></tr>
<tr class="separator:a859460d2f8ef863c52c53a197dc2d3ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087911e4bdef7ee6722271f56d1f32ca" id="r_a087911e4bdef7ee6722271f56d1f32ca"><td class="memItemLeft" align="right" valign="top"><a id="a087911e4bdef7ee6722271f56d1f32ca" name="a087911e4bdef7ee6722271f56d1f32ca"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getCutoff</b> () const</td></tr>
<tr class="memdesc:a087911e4bdef7ee6722271f56d1f32ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the particle-particle cutoff defining the neighbor list. <br /></td></tr>
<tr class="separator:a087911e4bdef7ee6722271f56d1f32ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f90ea6ad2873f9158daf85f41d8f73" id="r_ad5f90ea6ad2873f9158daf85f41d8f73"><td class="memItemLeft" align="right" valign="top"><a id="ad5f90ea6ad2873f9158daf85f41d8f73" name="ad5f90ea6ad2873f9158daf85f41d8f73"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getPadding</b> () const</td></tr>
<tr class="memdesc:ad5f90ea6ad2873f9158daf85f41d8f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the padding incorporated into each neighbor list cell. <br /></td></tr>
<tr class="separator:ad5f90ea6ad2873f9158daf85f41d8f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad933601a3da3353d088870cc4e5823ab" id="r_ad933601a3da3353d088870cc4e5823ab"><td class="memItemLeft" align="right" valign="top"><a id="ad933601a3da3353d088870cc4e5823ab" name="ad933601a3da3353d088870cc4e5823ab"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getEffectiveCutoff</b> () const</td></tr>
<tr class="memdesc:ad933601a3da3353d088870cc4e5823ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the effective cutoff. <br /></td></tr>
<tr class="separator:ad933601a3da3353d088870cc4e5823ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade08bd9487a181fc301b4113f0954f6c" id="r_ade08bd9487a181fc301b4113f0954f6c"><td class="memItemLeft" align="right" valign="top"><a id="ade08bd9487a181fc301b4113f0954f6c" name="ade08bd9487a181fc301b4113f0954f6c"></a>
NonbondedTheme&#160;</td><td class="memItemRight" valign="bottom"><b>getTheme</b> () const</td></tr>
<tr class="memdesc:ade08bd9487a181fc301b4113f0954f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the non-bonded theme of this cell grid&ndash;does it hold atoms with only electrostatic or van-der Waals properties? <br /></td></tr>
<tr class="separator:ade08bd9487a181fc301b4113f0954f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591fe6f985f5c1fa2241d2a63ff90166" id="r_a591fe6f985f5c1fa2241d2a63ff90166"><td class="memItemLeft" align="right" valign="top"><a id="a591fe6f985f5c1fa2241d2a63ff90166" name="a591fe6f985f5c1fa2241d2a63ff90166"></a>
TinyBoxPresence&#160;</td><td class="memItemRight" valign="bottom"><b>getTinyBoxPresence</b> () const</td></tr>
<tr class="memdesc:a591fe6f985f5c1fa2241d2a63ff90166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the presence of a tiny unit cell anywhere in the synthesis. <br /></td></tr>
<tr class="separator:a591fe6f985f5c1fa2241d2a63ff90166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac094762fe5d9c8fbc23c97d6ddbcc03a" id="r_ac094762fe5d9c8fbc23c97d6ddbcc03a"><td class="memItemLeft" align="right" valign="top"><a id="ac094762fe5d9c8fbc23c97d6ddbcc03a" name="ac094762fe5d9c8fbc23c97d6ddbcc03a"></a>
CoordinateCycle&#160;</td><td class="memItemRight" valign="bottom"><b>getCyclePosition</b> () const</td></tr>
<tr class="memdesc:ac094762fe5d9c8fbc23c97d6ddbcc03a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the position in the time cycle. <br /></td></tr>
<tr class="separator:ac094762fe5d9c8fbc23c97d6ddbcc03a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e62b33241d07f2c8cc2cf9c7979ebbb" id="r_a6e62b33241d07f2c8cc2cf9c7979ebbb"><td class="memItemLeft" align="right" valign="top"><a id="a6e62b33241d07f2c8cc2cf9c7979ebbb" name="a6e62b33241d07f2c8cc2cf9c7979ebbb"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getPositionScalingBits</b> () const</td></tr>
<tr class="memdesc:a6e62b33241d07f2c8cc2cf9c7979ebbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of bits in the fixed-precision format. <br /></td></tr>
<tr class="separator:a6e62b33241d07f2c8cc2cf9c7979ebbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff9517a1c13398e955f5df58959a26bb" id="r_aff9517a1c13398e955f5df58959a26bb"><td class="memItemLeft" align="right" valign="top"><a id="aff9517a1c13398e955f5df58959a26bb" name="aff9517a1c13398e955f5df58959a26bb"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getMeshSubdivisions</b> () const</td></tr>
<tr class="memdesc:aff9517a1c13398e955f5df58959a26bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of mesh elements spanning each spatial decomposition cell. The "mesh" refers to a particle-mesh interaction grid, e.g. the PME reciprocal space lattice. <br /></td></tr>
<tr class="separator:aff9517a1c13398e955f5df58959a26bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5416d700fce7f4da3ea5c1c501fe2002" id="r_a5416d700fce7f4da3ea5c1c501fe2002"><td class="memItemLeft" align="right" valign="top"><a id="a5416d700fce7f4da3ea5c1c501fe2002" name="a5416d700fce7f4da3ea5c1c501fe2002"></a>
const <a class="el" href="classstormm_1_1synthesis_1_1PhaseSpaceSynthesis.html">PhaseSpaceSynthesis</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getCoordinateSynthesisPointer</b> () const</td></tr>
<tr class="memdesc:a5416d700fce7f4da3ea5c1c501fe2002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const pointer to the coordinate synthesis served by this object. <br /></td></tr>
<tr class="separator:a5416d700fce7f4da3ea5c1c501fe2002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a894d24bfce9b5f40a41c9b570ec29acf" id="r_a894d24bfce9b5f40a41c9b570ec29acf"><td class="memItemLeft" align="right" valign="top"><a id="a894d24bfce9b5f40a41c9b570ec29acf" name="a894d24bfce9b5f40a41c9b570ec29acf"></a>
const <a class="el" href="classstormm_1_1synthesis_1_1AtomGraphSynthesis.html">AtomGraphSynthesis</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getTopologySynthesisPointer</b> () const</td></tr>
<tr class="memdesc:a894d24bfce9b5f40a41c9b570ec29acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const pointer to the topology synthesis served by this object. <br /></td></tr>
<tr class="separator:a894d24bfce9b5f40a41c9b570ec29acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace0d998be3299d462dc1659918b6d097" id="r_ace0d998be3299d462dc1659918b6d097"><td class="memItemLeft" align="right" valign="top"><a id="ace0d998be3299d462dc1659918b6d097" name="ace0d998be3299d462dc1659918b6d097"></a>
const <a class="el" href="classstormm_1_1energy_1_1CellGrid.html">CellGrid</a>&lt; T, Tacc, Tcalc, T4 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>getSelfPointer</b> () const</td></tr>
<tr class="memdesc:ace0d998be3299d462dc1659918b6d097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the object itself, useful if the object is only available by const reference. <br /></td></tr>
<tr class="separator:ace0d998be3299d462dc1659918b6d097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9367a8dd4c2090b8f0bee89127b085f9" id="r_a9367a8dd4c2090b8f0bee89127b085f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9367a8dd4c2090b8f0bee89127b085f9">initializeForces</a> (HybridTargetLevel tier=HybridTargetLevel::HOST, const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;gpu=null_gpu)</td></tr>
<tr class="memdesc:a9367a8dd4c2090b8f0bee89127b085f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize forces for the cell grid, on the CPU host or GPU device. This standalone feature provides a means for performing this activity at will, although in the most optimized code the process it performs will be fused with some other kernel. This will initialize forces for the current cell layout and should only be called once the contents of image_cell_limits or image_cell_limits_alt have been settled, whichever is appropriate to the current time cycle. There is only one array of forces in the <a class="el" href="classstormm_1_1mm_1_1CellGrid.html" title="An object to manage the spatial decomposition of a system of particles. The general strategy is to ar...">CellGrid</a>, as once they are accumulated in this object they are added to one of the two time-cycle dependent arrays in the accompanying <a class="el" href="classstormm_1_1mm_1_1PhaseSpaceSynthesis.html" title="A fixed-precision representation of coordinates, velocities, and forces to manage a set of simulation...">PhaseSpaceSynthesis</a>.  <br /></td></tr>
<tr class="separator:a9367a8dd4c2090b8f0bee89127b085f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32daa97e4cc398abf738a717792fb936" id="r_a32daa97e4cc398abf738a717792fb936"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32daa97e4cc398abf738a717792fb936">markImageRelevance</a> (HybridTargetLevel tier=HybridTargetLevel::HOST, const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;gpu=null_gpu)</td></tr>
<tr class="memdesc:a32daa97e4cc398abf738a717792fb936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute whether various atoms may be within range of the tower when they are in the plate of various neutral territory decompositions. Bitwise information (1 for relevant, 0 for irrelevant) is recorded in a 16-bit unsigned integer for each atom in the current image, as indicated by its stage in the coordinate cycle.  <br /></td></tr>
<tr class="separator:a32daa97e4cc398abf738a717792fb936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a62e3a961ea4f30ce4f72e31b0fc82685" id="r_a62e3a961ea4f30ce4f72e31b0fc82685"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62e3a961ea4f30ce4f72e31b0fc82685">CellGrid</a> (const <a class="el" href="classstormm_1_1synthesis_1_1PhaseSpaceSynthesis.html">PhaseSpaceSynthesis</a> *poly_ps_ptr_in, const <a class="el" href="classstormm_1_1synthesis_1_1AtomGraphSynthesis.html">AtomGraphSynthesis</a> *poly_ag_ptr_in, double cutoff_in, double padding_in, int mesh_subdivisions_in, NonbondedTheme theme_in, uint cell_base_capacity_in=default_cellgrid_base_capacity, ExceptionResponse policy_in=ExceptionResponse::WARN)</td></tr>
<tr class="memdesc:a62e3a961ea4f30ce4f72e31b0fc82685"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructor accepts an associated <a class="el" href="classstormm_1_1mm_1_1PhaseSpaceSynthesis.html" title="A fixed-precision representation of coordinates, velocities, and forces to manage a set of simulation...">PhaseSpaceSynthesis</a> object and a precision model. The system count and scaling factors will be set by the coordinate synthesis. The total cell count and cell layout can be modulated by specifying a cutoff and a padding related to how much larger each cell should be sized.  <br /></td></tr>
<tr class="separator:a62e3a961ea4f30ce4f72e31b0fc82685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b2ca22573f83afa4c69285172dffc1" id="r_af4b2ca22573f83afa4c69285172dffc1"><td class="memItemLeft" align="right" valign="top"><a id="af4b2ca22573f83afa4c69285172dffc1" name="af4b2ca22573f83afa4c69285172dffc1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CellGrid</b> (const <a class="el" href="classstormm_1_1synthesis_1_1PhaseSpaceSynthesis.html">PhaseSpaceSynthesis</a> *poly_ps_ptr_in, const <a class="el" href="classstormm_1_1synthesis_1_1AtomGraphSynthesis.html">AtomGraphSynthesis</a> &amp;poly_ag_ptr_in, double cutoff_in, double padding_in, int mesh_subdivisions_in, NonbondedTheme theme_in, uint cell_base_capacity_in=default_cellgrid_base_capacity, ExceptionResponse policy_in=ExceptionResponse::WARN)</td></tr>
<tr class="separator:af4b2ca22573f83afa4c69285172dffc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac83d147da62b0be91303a05f7b9f7e2f" id="r_ac83d147da62b0be91303a05f7b9f7e2f"><td class="memItemLeft" align="right" valign="top"><a id="ac83d147da62b0be91303a05f7b9f7e2f" name="ac83d147da62b0be91303a05f7b9f7e2f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CellGrid</b> (const <a class="el" href="classstormm_1_1synthesis_1_1PhaseSpaceSynthesis.html">PhaseSpaceSynthesis</a> &amp;poly_ps_ptr_in, const <a class="el" href="classstormm_1_1synthesis_1_1AtomGraphSynthesis.html">AtomGraphSynthesis</a> &amp;poly_ag_ptr_in, double cutoff_in, double padding_in, int mesh_subdivisions_in, NonbondedTheme theme_in, uint cell_base_capacity_in=default_cellgrid_base_capacity, ExceptionResponse policy_in=ExceptionResponse::WARN)</td></tr>
<tr class="separator:ac83d147da62b0be91303a05f7b9f7e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:adb131a44c5e97447c07df812d5d81673" id="r_adb131a44c5e97447c07df812d5d81673"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb131a44c5e97447c07df812d5d81673">CellGrid</a> (const <a class="el" href="classstormm_1_1energy_1_1CellGrid.html">CellGrid</a> &amp;original)</td></tr>
<tr class="memdesc:adb131a44c5e97447c07df812d5d81673"><td class="mdescLeft">&#160;</td><td class="mdescRight">The presence of POINTER-kind <a class="el" href="classstormm_1_1mm_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> objects in the cell origin rulers invalidates the default copy and move constructors as well as assignment operators. Manual implementations are needed.  <br /></td></tr>
<tr class="separator:adb131a44c5e97447c07df812d5d81673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af11fb1aac19b42dab746ef744c2d6f1a" id="r_af11fb1aac19b42dab746ef744c2d6f1a"><td class="memItemLeft" align="right" valign="top"><a id="af11fb1aac19b42dab746ef744c2d6f1a" name="af11fb1aac19b42dab746ef744c2d6f1a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CellGrid</b> (<a class="el" href="classstormm_1_1energy_1_1CellGrid.html">CellGrid</a> &amp;&amp;original)</td></tr>
<tr class="separator:af11fb1aac19b42dab746ef744c2d6f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a577f480983f64b1e32518cd519983d49" id="r_a577f480983f64b1e32518cd519983d49"><td class="memItemLeft" align="right" valign="top"><a id="a577f480983f64b1e32518cd519983d49" name="a577f480983f64b1e32518cd519983d49"></a>
<a class="el" href="classstormm_1_1energy_1_1CellGrid.html">CellGrid</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classstormm_1_1energy_1_1CellGrid.html">CellGrid</a> &amp;original)</td></tr>
<tr class="separator:a577f480983f64b1e32518cd519983d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b15aa991b1fa13a1dacf4ad87ee472d" id="r_a3b15aa991b1fa13a1dacf4ad87ee472d"><td class="memItemLeft" align="right" valign="top"><a id="a3b15aa991b1fa13a1dacf4ad87ee472d" name="a3b15aa991b1fa13a1dacf4ad87ee472d"></a>
<a class="el" href="classstormm_1_1energy_1_1CellGrid.html">CellGrid</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classstormm_1_1energy_1_1CellGrid.html">CellGrid</a> &amp;&amp;original)</td></tr>
<tr class="separator:a3b15aa991b1fa13a1dacf4ad87ee472d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a2136748090799d111ef82791002eb217" id="r_a2136748090799d111ef82791002eb217"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2136748090799d111ef82791002eb217">getCellCount</a> (int index) const</td></tr>
<tr class="memdesc:a2136748090799d111ef82791002eb217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of cells allotted to any one system.  <br /></td></tr>
<tr class="separator:a2136748090799d111ef82791002eb217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada09b36bc1bbf2b86b6334b59ec9b7c9" id="r_ada09b36bc1bbf2b86b6334b59ec9b7c9"><td class="memItemLeft" align="right" valign="top"><a id="ada09b36bc1bbf2b86b6334b59ec9b7c9" name="ada09b36bc1bbf2b86b6334b59ec9b7c9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getCellCount</b> (int index, UnitCellAxis axis) const</td></tr>
<tr class="separator:ada09b36bc1bbf2b86b6334b59ec9b7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c734657984d7df4132eb164e422d959" id="r_a0c734657984d7df4132eb164e422d959"><td class="memItemLeft" align="right" valign="top"><a id="a0c734657984d7df4132eb164e422d959" name="a0c734657984d7df4132eb164e422d959"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getCellCount</b> (int index, CartesianDimension axis) const</td></tr>
<tr class="separator:a0c734657984d7df4132eb164e422d959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a97ea25e135b7fd045ec555af404365f8" id="r_a97ea25e135b7fd045ec555af404365f8"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97ea25e135b7fd045ec555af404365f8">getImageIndex</a> (int system_index, int atom_index, CoordinateCycle orientation) const</td></tr>
<tr class="memdesc:a97ea25e135b7fd045ec555af404365f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the image location of an atom based on its system and topological atom number.  <br /></td></tr>
<tr class="separator:a97ea25e135b7fd045ec555af404365f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a198b600b64bf171e8c98456d96b5e194" id="r_a198b600b64bf171e8c98456d96b5e194"><td class="memItemLeft" align="right" valign="top"><a id="a198b600b64bf171e8c98456d96b5e194" name="a198b600b64bf171e8c98456d96b5e194"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>getImageIndex</b> (int system_index, int atom_index) const</td></tr>
<tr class="separator:a198b600b64bf171e8c98456d96b5e194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9f707c244f7f6bebdd4af0c9e0545b7f" id="r_a9f707c244f7f6bebdd4af0c9e0545b7f"><td class="memItemLeft" align="right" valign="top"><a id="a9f707c244f7f6bebdd4af0c9e0545b7f" name="a9f707c244f7f6bebdd4af0c9e0545b7f"></a>
<a class="el" href="structstormm_1_1data__types_1_1int4.html">int4</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getCellLocation</b> (int system_index, int atom_index, CoordinateCycle orientation) const</td></tr>
<tr class="memdesc:a9f707c244f7f6bebdd4af0c9e0545b7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the cell grid location of an atom based on its system and topological atom number. The result will be returned as the index of the cell within the grid belonging to the system of interest, with the indices along the A, B, and C axes placed in the "x", "y", and "z" members of the tuple. The overall index of the cell in the entire <a class="el" href="classstormm_1_1mm_1_1CellGrid.html" title="An object to manage the spatial decomposition of a system of particles. The general strategy is to ar...">CellGrid</a> object (up to 2^28 cells) will be returned in the "w" member of the tuple. All of this information is available in bit-packed form in the system_cell_limits array. Overloading and descriptions of parameters follow from <a class="el" href="classstormm_1_1energy_1_1CellGrid.html#a97ea25e135b7fd045ec555af404365f8" title="Find the image location of an atom based on its system and topological atom number.">getImageIndex()</a> above. <br /></td></tr>
<tr class="separator:a9f707c244f7f6bebdd4af0c9e0545b7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af102a1c21e59ad671f8cb16bd0df3a1f" id="r_af102a1c21e59ad671f8cb16bd0df3a1f"><td class="memItemLeft" align="right" valign="top"><a id="af102a1c21e59ad671f8cb16bd0df3a1f" name="af102a1c21e59ad671f8cb16bd0df3a1f"></a>
<a class="el" href="structstormm_1_1data__types_1_1int4.html">int4</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getCellLocation</b> (int system_index, int atom_index) const</td></tr>
<tr class="separator:af102a1c21e59ad671f8cb16bd0df3a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a80c35c79b7f4ae38a2dc650a22c64661" id="r_a80c35c79b7f4ae38a2dc650a22c64661"><td class="memItemLeft" align="right" valign="top"><a id="a80c35c79b7f4ae38a2dc650a22c64661" name="a80c35c79b7f4ae38a2dc650a22c64661"></a>
<a class="el" href="structstormm_1_1data__types_1_1int2.html">int2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getChainLocation</b> (int system_index, int atom_index, CoordinateCycle orientation) const</td></tr>
<tr class="memdesc:a80c35c79b7f4ae38a2dc650a22c64661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the chain index of an atom based on its system and topological atom index. The chain index is returned in the "x" member of the tuple while the offset within the chain is returned in the "y" member. Overloading and descriptions of parameters follow from <a class="el" href="classstormm_1_1energy_1_1CellGrid.html#a97ea25e135b7fd045ec555af404365f8" title="Find the image location of an atom based on its system and topological atom number.">getImageIndex()</a> above. <br /></td></tr>
<tr class="separator:a80c35c79b7f4ae38a2dc650a22c64661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd9f17cfad0d5f57a950e40cd2240a5" id="r_a9bd9f17cfad0d5f57a950e40cd2240a5"><td class="memItemLeft" align="right" valign="top"><a id="a9bd9f17cfad0d5f57a950e40cd2240a5" name="a9bd9f17cfad0d5f57a950e40cd2240a5"></a>
<a class="el" href="structstormm_1_1data__types_1_1int2.html">int2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getChainLocation</b> (int system_index, int atom_index) const</td></tr>
<tr class="separator:a9bd9f17cfad0d5f57a950e40cd2240a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aaafede3d674488e846bdf77796810b98" id="r_aaafede3d674488e846bdf77796810b98"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structstormm_1_1synthesis_1_1PsSynthesisBorders.html">PsSynthesisBorders</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaafede3d674488e846bdf77796810b98">getUnitCellTransforms</a> (CoordinateCycle orientation, HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:aaafede3d674488e846bdf77796810b98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a miniature abstract of the underlying coordinate synthesis containing pointers to the arays of unit cell transformation matrices for each system.  <br /></td></tr>
<tr class="separator:aaafede3d674488e846bdf77796810b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad342ec8c8b483501a5ae11ae8408c581" id="r_ad342ec8c8b483501a5ae11ae8408c581"><td class="memItemLeft" align="right" valign="top"><a id="ad342ec8c8b483501a5ae11ae8408c581" name="ad342ec8c8b483501a5ae11ae8408c581"></a>
const <a class="el" href="structstormm_1_1synthesis_1_1PsSynthesisBorders.html">PsSynthesisBorders</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getUnitCellTransforms</b> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="separator:ad342ec8c8b483501a5ae11ae8408c581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1451b1816eafc9235fc42d25624cdcaf" id="r_a1451b1816eafc9235fc42d25624cdcaf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstormm_1_1energy_1_1CellGridWriter.html">CellGridWriter</a>&lt; T, Tacc, Tcalc, T4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1451b1816eafc9235fc42d25624cdcaf">data</a> (CoordinateCycle orientation, HybridTargetLevel tier=HybridTargetLevel::HOST)</td></tr>
<tr class="memdesc:a1451b1816eafc9235fc42d25624cdcaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the object's abstract in order to access its members in C-programming fashion, whether on the CPU host or GPU device.  <br /></td></tr>
<tr class="separator:a1451b1816eafc9235fc42d25624cdcaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23ee9fba6a04d37a916cf24b0f463e91" id="r_a23ee9fba6a04d37a916cf24b0f463e91"><td class="memItemLeft" align="right" valign="top"><a id="a23ee9fba6a04d37a916cf24b0f463e91" name="a23ee9fba6a04d37a916cf24b0f463e91"></a>
<a class="el" href="structstormm_1_1energy_1_1CellGridWriter.html">CellGridWriter</a>&lt; T, Tacc, Tcalc, T4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> (HybridTargetLevel tier=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:a23ee9fba6a04d37a916cf24b0f463e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8c44936403b59a83c79da1cde718cd" id="r_aed8c44936403b59a83c79da1cde718cd"><td class="memItemLeft" align="right" valign="top"><a id="aed8c44936403b59a83c79da1cde718cd" name="aed8c44936403b59a83c79da1cde718cd"></a>
const <a class="el" href="structstormm_1_1energy_1_1CellGridReader.html">CellGridReader</a>&lt; T, Tacc, Tcalc, T4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> (CoordinateCycle orientation, HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="separator:aed8c44936403b59a83c79da1cde718cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb4eb406e7cf6df780e00ddaeba3c0f" id="r_a1bb4eb406e7cf6df780e00ddaeba3c0f"><td class="memItemLeft" align="right" valign="top"><a id="a1bb4eb406e7cf6df780e00ddaeba3c0f" name="a1bb4eb406e7cf6df780e00ddaeba3c0f"></a>
const <a class="el" href="structstormm_1_1energy_1_1CellGridReader.html">CellGridReader</a>&lt; T, Tacc, Tcalc, T4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="separator:a1bb4eb406e7cf6df780e00ddaeba3c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa9d0540f3ec499261d059da239187ea0" id="r_aa9d0540f3ec499261d059da239187ea0"><td class="memItemLeft" align="right" valign="top"><a id="aa9d0540f3ec499261d059da239187ea0" name="aa9d0540f3ec499261d059da239187ea0"></a>
<a class="el" href="structstormm_1_1energy_1_1CellGridWriter.html">CellGridWriter</a>&lt; void, void, void, void &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>templateFreeData</b> (CoordinateCycle orientation, HybridTargetLevel tier=HybridTargetLevel::HOST)</td></tr>
<tr class="memdesc:aa9d0540f3ec499261d059da239187ea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the object's abstract with templating removed. Overloading and descriptions of parameters follow from <a class="el" href="classstormm_1_1energy_1_1CellGrid.html#a1451b1816eafc9235fc42d25624cdcaf" title="Obtain the object&#39;s abstract in order to access its members in C-programming fashion,...">data()</a> above. <br /></td></tr>
<tr class="separator:aa9d0540f3ec499261d059da239187ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb229fd479840c5a7c0703e2de22488f" id="r_abb229fd479840c5a7c0703e2de22488f"><td class="memItemLeft" align="right" valign="top"><a id="abb229fd479840c5a7c0703e2de22488f" name="abb229fd479840c5a7c0703e2de22488f"></a>
<a class="el" href="structstormm_1_1energy_1_1CellGridWriter.html">CellGridWriter</a>&lt; void, void, void, void &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>templateFreeData</b> (HybridTargetLevel tier=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:abb229fd479840c5a7c0703e2de22488f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c565f6174cd8d8d9eda39562cc8b283" id="r_a6c565f6174cd8d8d9eda39562cc8b283"><td class="memItemLeft" align="right" valign="top"><a id="a6c565f6174cd8d8d9eda39562cc8b283" name="a6c565f6174cd8d8d9eda39562cc8b283"></a>
const <a class="el" href="structstormm_1_1energy_1_1CellGridReader.html">CellGridReader</a>&lt; void, void, void, void &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>templateFreeData</b> (CoordinateCycle orientation, HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="separator:a6c565f6174cd8d8d9eda39562cc8b283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0540d4e2176f785f8d65f455774cb6a" id="r_aa0540d4e2176f785f8d65f455774cb6a"><td class="memItemLeft" align="right" valign="top"><a id="aa0540d4e2176f785f8d65f455774cb6a" name="aa0540d4e2176f785f8d65f455774cb6a"></a>
const <a class="el" href="structstormm_1_1energy_1_1CellGridReader.html">CellGridReader</a>&lt; void, void, void, void &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>templateFreeData</b> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="separator:aa0540d4e2176f785f8d65f455774cb6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a23ef672b22b5384a61b19d3249ba6173" id="r_a23ef672b22b5384a61b19d3249ba6173"><td class="memItemLeft" align="right" valign="top">const CellOriginsReader&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23ef672b22b5384a61b19d3249ba6173">getRulers</a> (CoordinateCycle orientation, HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:a23ef672b22b5384a61b19d3249ba6173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the object's rulers for determining the origins of each neighbor list cell in terms of the fixed-precision coordinate system of the accompanying <a class="el" href="classstormm_1_1mm_1_1PhaseSpaceSynthesis.html" title="A fixed-precision representation of coordinates, velocities, and forces to manage a set of simulation...">PhaseSpaceSynthesis</a>.  <br /></td></tr>
<tr class="separator:a23ef672b22b5384a61b19d3249ba6173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b762bc097aaa175b513eed8c59757e" id="r_a09b762bc097aaa175b513eed8c59757e"><td class="memItemLeft" align="right" valign="top"><a id="a09b762bc097aaa175b513eed8c59757e" name="a09b762bc097aaa175b513eed8c59757e"></a>
const CellOriginsReader&#160;</td><td class="memItemRight" valign="bottom"><b>getRulers</b> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="separator:a09b762bc097aaa175b513eed8c59757e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef98d4d3ebd9246bf7d5b2c662b74bc5" id="r_aef98d4d3ebd9246bf7d5b2c662b74bc5"><td class="memItemLeft" align="right" valign="top"><a id="aef98d4d3ebd9246bf7d5b2c662b74bc5" name="aef98d4d3ebd9246bf7d5b2c662b74bc5"></a>
CellOriginsWriter&#160;</td><td class="memItemRight" valign="bottom"><b>getRulers</b> (CoordinateCycle orientation, HybridTargetLevel tier=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:aef98d4d3ebd9246bf7d5b2c662b74bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a672b2de4b985ec7fe7cda3431b6abd" id="r_a7a672b2de4b985ec7fe7cda3431b6abd"><td class="memItemLeft" align="right" valign="top"><a id="a7a672b2de4b985ec7fe7cda3431b6abd" name="a7a672b2de4b985ec7fe7cda3431b6abd"></a>
CellOriginsWriter&#160;</td><td class="memItemRight" valign="bottom"><b>getRulers</b> (HybridTargetLevel tier=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:a7a672b2de4b985ec7fe7cda3431b6abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6e0f3efa940179a145ea0f80b0b37934" id="r_a6e0f3efa940179a145ea0f80b0b37934"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e0f3efa940179a145ea0f80b0b37934">contributeForces</a> (<a class="el" href="classstormm_1_1synthesis_1_1PhaseSpaceSynthesis.html">PhaseSpaceSynthesis</a> *dest, HybridTargetLevel tier, const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;gpu) const</td></tr>
<tr class="memdesc:a6e0f3efa940179a145ea0f80b0b37934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contribute forces accumulated in the cell grid back to a coordinate synthesis with its own force accumulators and forces from other sources.  <br /></td></tr>
<tr class="separator:a6e0f3efa940179a145ea0f80b0b37934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d2a61a873e9a5d01b969e371ba0898e" id="r_a6d2a61a873e9a5d01b969e371ba0898e"><td class="memItemLeft" align="right" valign="top"><a id="a6d2a61a873e9a5d01b969e371ba0898e" name="a6d2a61a873e9a5d01b969e371ba0898e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>contributeForces</b> (HybridTargetLevel tier=HybridTargetLevel::HOST, const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;gpu=null_gpu) const</td></tr>
<tr class="separator:a6d2a61a873e9a5d01b969e371ba0898e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a2adc76e7256f8677bea2db2d22ea4618" id="r_a2adc76e7256f8677bea2db2d22ea4618"><td class="memItemLeft" align="right" valign="top"><a id="a2adc76e7256f8677bea2db2d22ea4618" name="a2adc76e7256f8677bea2db2d22ea4618"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>updatePositions</b> (<a class="el" href="classstormm_1_1synthesis_1_1PhaseSpaceSynthesis.html">PhaseSpaceSynthesis</a> *dest, HybridTargetLevel tier, const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;gpu)</td></tr>
<tr class="memdesc:a2adc76e7256f8677bea2db2d22ea4618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the positions and cells of residence for all particles based on the current positions in the associated synthesis. Overloading and descriptions of input parameters follow from <a class="el" href="classstormm_1_1energy_1_1CellGrid.html#a6e0f3efa940179a145ea0f80b0b37934" title="Contribute forces accumulated in the cell grid back to a coordinate synthesis with its own force accu...">contributeForces()</a>, above. <br /></td></tr>
<tr class="separator:a2adc76e7256f8677bea2db2d22ea4618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0354eecdcf8177a80649a51aed40f21" id="r_aa0354eecdcf8177a80649a51aed40f21"><td class="memItemLeft" align="right" valign="top"><a id="aa0354eecdcf8177a80649a51aed40f21" name="aa0354eecdcf8177a80649a51aed40f21"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>updatePositions</b> (HybridTargetLevel tier=HybridTargetLevel::HOST, const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;gpu=null_gpu)</td></tr>
<tr class="separator:aa0354eecdcf8177a80649a51aed40f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6013ebd2e70ac027cc5d75296df64709" id="r_a6013ebd2e70ac027cc5d75296df64709"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6013ebd2e70ac027cc5d75296df64709">updateCyclePosition</a> ()</td></tr>
<tr class="memdesc:a6013ebd2e70ac027cc5d75296df64709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the object's cycle position as it participates in the WHITE:BLACK tick-tock mechanics of other coordinate objects.  <br /></td></tr>
<tr class="separator:a6013ebd2e70ac027cc5d75296df64709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23acb3b08f7587078a2234134abdf019" id="r_a23acb3b08f7587078a2234134abdf019"><td class="memItemLeft" align="right" valign="top"><a id="a23acb3b08f7587078a2234134abdf019" name="a23acb3b08f7587078a2234134abdf019"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>updateCyclePosition</b> (CoordinateCycle time_point)</td></tr>
<tr class="separator:a23acb3b08f7587078a2234134abdf019"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T, typename Tacc, typename Tcalc, typename T4&gt;<br />
class stormm::mm::CellGrid&lt; T, Tacc, Tcalc, T4 &gt;</div><p>An object to manage the spatial decomposition of a system of particles. The general strategy is to arrange particles in a grid of cells, each at least half the direct-space cutoff in width in all directions. A work unit entails computing all interactions assigned to one of the cells. This is done using a neutral-territory decomposition the lines of the "tower-plate" arrangement, which consists of seventeen cells: </p>
<pre class="fragment">      ---X--- ^                    ---X--- ^                    ------- ^
      ---X--- |                    ---X--- |                    ------- |
</pre><p> View along A: &mdash;XXX- c View along B: -XXXXX- c View along C: &mdash;XXX- b &mdash;X&mdash; &mdash;X&mdash; -XXXXX- &mdash;X&mdash; b-&gt; &mdash;X&mdash; a-&gt; -XXXXX- a-&gt;</p>
<p>As with other grids in STORMM, the cell grid index increments most rapidly along the A axis. Furthermore, the atoms of all cells in a stack along A are arranged in contiguous memory, with no spacing between them. Each row of cells along a mesh's A axis is arranged with a degree of padding so that the population of any particular row may fluctuate within some anticipated bounds. Memory access is optimized by arranging the tower along the C axis, providing continuous atom flow for 3, 5, and 5 cells when loading the larger plate. Atoms in the tower will interact with the most other atoms and require one global write (atomicAdd) to commit their forces back to the totals at the end of the work unit. Therefore, it is most efficient to have these atoms be the least contiguous of the whole.</p>
<p>In all cells, cache behavior is optimized by storing coordinates and properties as four-tuples such that only eight atoms in single-precision mode (or four in double-precision mode) are required to fill a cache line.</p>
<p>The work cycle is as follows: 1 .) A KERNEL COMPUTING VALENCE INTERACTIONS will accumulate all forces, including non-bonded contributions originating in this kernel on a previous cycle, and move particles. Following moves, this VALENCE INTERACTION KERNEL will compute new cell addresses for each atom and populate the vestibules of particles entering and leaving each cell. The VALENCE INTERACTION KERNEL will also deposit the new, scaled coordinates of each cell in the previous cycle's atoms array, which is no longer in use. 2.) A NEIGHBOR LIST UPDATE KERNEL will fire off ahead of the non-bonded kernels. This will handle re-imaging of coordinates and updates to cells. Taking the (now complete) vestibules of entering and exiting particles, the kernel begins by performing an out-of-place sort to adjust each cell in the mesh. Each warp performs a prefix sum over the adjustments in the particular cell's column in order to arrive at the limits within which to transfer particles, first from the cell's contents in the old atoms array (so long as they are to be retained) and then by referencing the prior indices of particles that are moving in and transferring the particles from their prior cells, but will likely be hidden by the memory accesses happening at the same time. Particles exit cells, causing contractions of the list of bitmasks and then of the bitmasks themselves. Particles leaving the plate cell prunes the array of bitmasks while particles leaving the tower prunes the bitmasks themselves&ndash;see notes in this library's template implementation file. Likewise, particles entering the tower cells will add bits to the back of each mask, and particles entering cells of the plate will expand the arrays of bitmasks in various places. The exact list of particles in each cell will be in flux, but with the identities of particles entering and the indices (positions within the cell grid image) of particles exiting already established in the preceding kernel, the non-bonded lists can be updated without risk of any race conditions. One warp will be tasked with updating each cell's atom coordinates while a second will be tasked with updating its exclusion masks. Both the atom coordinate update and the neighbor list update are performed out-of-place. 3 .) Taking the newly updated neighbor lists, the RECIPROCAL-SPACE KERNEL will proceed to assemble the the FFT pencils and use strong barriers in order to complete the convolution. 4 .) The DIRECT-SPACE KERNEL will launch to complete the work, and perform interpolation of long-ranged particle-particle interactions if that is required. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a62e3a961ea4f30ce4f72e31b0fc82685" name="a62e3a961ea4f30ce4f72e31b0fc82685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62e3a961ea4f30ce4f72e31b0fc82685">&#9670;&#160;</a></span>CellGrid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Tacc, typename Tcalc, typename T4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstormm_1_1energy_1_1CellGrid.html">stormm::energy::CellGrid</a>&lt; T, Tacc, Tcalc, T4 &gt;::CellGrid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstormm_1_1synthesis_1_1PhaseSpaceSynthesis.html">PhaseSpaceSynthesis</a> *</td>          <td class="paramname"><span class="paramname"><em>poly_ps_ptr_in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstormm_1_1synthesis_1_1AtomGraphSynthesis.html">AtomGraphSynthesis</a> *</td>          <td class="paramname"><span class="paramname"><em>poly_ag_ptr_in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>cutoff_in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>padding_in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>mesh_subdivisions_in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NonbondedTheme</td>          <td class="paramname"><span class="paramname"><em>theme_in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>cell_base_capacity_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">default_cellgrid_base_capacity</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExceptionResponse</td>          <td class="paramname"><span class="paramname"><em>policy_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">ExceptionResponse::WARN</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The constructor accepts an associated <a class="el" href="classstormm_1_1mm_1_1PhaseSpaceSynthesis.html" title="A fixed-precision representation of coordinates, velocities, and forces to manage a set of simulation...">PhaseSpaceSynthesis</a> object and a precision model. The system count and scaling factors will be set by the coordinate synthesis. The total cell count and cell layout can be modulated by specifying a cutoff and a padding related to how much larger each cell should be sized. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh_subdivisions_in</td><td>The number of mesh elements along each axis of one of the spatial decomposition cell. This value, times the cell grid dimensions themselves, defines the size of a particle-mesh interaction grid associated with the neighbor list, i.e. the PME reciprocal space grid. </td></tr>
    <tr><td class="paramname">theme_in</td><td>The non-bonded potential that will be computed based on the neighbor list represented in the cell grid </td></tr>
    <tr><td class="paramname">gpu</td><td>Details of the GPU that will utilize and manipulate the cell grid </td></tr>
    <tr><td class="paramname">cell_base_capacity_in</td><td>The atom capacity of an individual decomposition cell. This is set to be larger than the atom content is likely to go, and in all cases where it might be relevant multiple cells will pool their capacities to ensure that overflow is extremely unlikely. </td></tr>
    <tr><td class="paramname">policy_in</td><td>Course of action in the case of bad input </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb131a44c5e97447c07df812d5d81673" name="adb131a44c5e97447c07df812d5d81673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb131a44c5e97447c07df812d5d81673">&#9670;&#160;</a></span>CellGrid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Tacc, typename Tcalc, typename T4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstormm_1_1energy_1_1CellGrid.html">stormm::energy::CellGrid</a>&lt; T, Tacc, Tcalc, T4 &gt;::CellGrid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstormm_1_1energy_1_1CellGrid.html">CellGrid</a>&lt; T, Tacc, Tcalc, T4 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>original</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The presence of POINTER-kind <a class="el" href="classstormm_1_1mm_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> objects in the cell origin rulers invalidates the default copy and move constructors as well as assignment operators. Manual implementations are needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">original</td><td>The original object to copy or move </td></tr>
    <tr><td class="paramname">other</td><td>Another object placed on the right hand side of the assignment statement </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6e0f3efa940179a145ea0f80b0b37934" name="a6e0f3efa940179a145ea0f80b0b37934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e0f3efa940179a145ea0f80b0b37934">&#9670;&#160;</a></span>contributeForces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Tacc, typename Tcalc, typename T4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstormm_1_1energy_1_1CellGrid.html">stormm::energy::CellGrid</a>&lt; T, Tacc, Tcalc, T4 &gt;::contributeForces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstormm_1_1synthesis_1_1PhaseSpaceSynthesis.html">PhaseSpaceSynthesis</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gpu</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Contribute forces accumulated in the cell grid back to a coordinate synthesis with its own force accumulators and forces from other sources. </p>
<p>Overloaded:</p><ul>
<li>Contribute the forces to an arbitrary <a class="el" href="classstormm_1_1mm_1_1PhaseSpaceSynthesis.html" title="A fixed-precision representation of coordinates, velocities, and forces to manage a set of simulation...">PhaseSpaceSynthesis</a></li>
<li>Contribute the forces back to the <a class="el" href="classstormm_1_1mm_1_1CellGrid.html" title="An object to manage the spatial decomposition of a system of particles. The general strategy is to ar...">CellGrid</a>'s internally referenced synthesis</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Specify a different synthesis to receive the accumulated forces </td></tr>
    <tr><td class="paramname">tier</td><td>Indicate whether to initialize forces on the CPU host or GPU device </td></tr>
    <tr><td class="paramname">gpu</td><td>Details of the GPU that will perform the initialization of device memory </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1451b1816eafc9235fc42d25624cdcaf" name="a1451b1816eafc9235fc42d25624cdcaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1451b1816eafc9235fc42d25624cdcaf">&#9670;&#160;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Tacc, typename Tcalc, typename T4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstormm_1_1energy_1_1CellGridWriter.html">CellGridWriter</a>&lt; T, Tacc, Tcalc, T4 &gt; <a class="el" href="classstormm_1_1energy_1_1CellGrid.html">stormm::energy::CellGrid</a>&lt; T, Tacc, Tcalc, T4 &gt;::data </td>
          <td>(</td>
          <td class="paramtype">CoordinateCycle</td>          <td class="paramname"><span class="paramname"><em>orientation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the object's abstract in order to access its members in C-programming fashion, whether on the CPU host or GPU device. </p>
<p>Overloaded:</p><ul>
<li>Return a const reader from a const <a class="el" href="classstormm_1_1mm_1_1CellGrid.html" title="An object to manage the spatial decomposition of a system of particles. The general strategy is to ar...">CellGrid</a> object</li>
<li>Return an editable writer from a non-const <a class="el" href="classstormm_1_1mm_1_1CellGrid.html" title="An object to manage the spatial decomposition of a system of particles. The general strategy is to ar...">CellGrid</a> object</li>
<li>Indicate the point in the time cycle or take the device's internal setting</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orientation</td><td>The point in the time cycle at which to obtain some pointers </td></tr>
    <tr><td class="paramname">tier</td><td>Indicate whether to target pointers to memory on the CPU host or GPU device </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2136748090799d111ef82791002eb217" name="a2136748090799d111ef82791002eb217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2136748090799d111ef82791002eb217">&#9670;&#160;</a></span>getCellCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Tacc, typename Tcalc, typename T4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classstormm_1_1energy_1_1CellGrid.html">stormm::energy::CellGrid</a>&lt; T, Tacc, Tcalc, T4 &gt;::getCellCount </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of cells allotted to any one system. </p>
<p>Overloaded:</p><ul>
<li>Get the total number of cells in the system.</li>
<li>Get the number cells along one of the system's simulation box axes.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The system of interest </td></tr>
    <tr><td class="paramname">axis</td><td>The axis of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97ea25e135b7fd045ec555af404365f8" name="a97ea25e135b7fd045ec555af404365f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97ea25e135b7fd045ec555af404365f8">&#9670;&#160;</a></span>getImageIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Tacc, typename Tcalc, typename T4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint <a class="el" href="classstormm_1_1energy_1_1CellGrid.html">stormm::energy::CellGrid</a>&lt; T, Tacc, Tcalc, T4 &gt;::getImageIndex </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>system_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>atom_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoordinateCycle</td>          <td class="paramname"><span class="paramname"><em>orientation</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the image location of an atom based on its system and topological atom number. </p>
<p>Overloaded:</p><ul>
<li>Check in the most recent image</li>
<li>Specify the primary or alternate image to check for the atom</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">system_index</td><td>The system of interest within the associated synthesis </td></tr>
    <tr><td class="paramname">atom_index</td><td>Topological atom index within the system </td></tr>
    <tr><td class="paramname">orientation</td><td>Specify whether to look in the primary or </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a23ef672b22b5384a61b19d3249ba6173" name="a23ef672b22b5384a61b19d3249ba6173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23ef672b22b5384a61b19d3249ba6173">&#9670;&#160;</a></span>getRulers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Tacc, typename Tcalc, typename T4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const CellOriginsReader <a class="el" href="classstormm_1_1energy_1_1CellGrid.html">stormm::energy::CellGrid</a>&lt; T, Tacc, Tcalc, T4 &gt;::getRulers </td>
          <td>(</td>
          <td class="paramtype">CoordinateCycle</td>          <td class="paramname"><span class="paramname"><em>orientation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the object's rulers for determining the origins of each neighbor list cell in terms of the fixed-precision coordinate system of the accompanying <a class="el" href="classstormm_1_1mm_1_1PhaseSpaceSynthesis.html" title="A fixed-precision representation of coordinates, velocities, and forces to manage a set of simulation...">PhaseSpaceSynthesis</a>. </p>
<p>Overloaded:</p><ul>
<li>Obtain the rulers for a particular stage of the time cycle, or use the object's internal timekeeping</li>
<li>Obtain a mutable collection of rulers from a non-const object, or a read-only collection or rulers from a const object</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orientation</td><td>The point in the time cycle at which to obtain the rulers </td></tr>
    <tr><td class="paramname">tier</td><td>Indicate whether to target pointers to memory on the CPU host or GPU device </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaafede3d674488e846bdf77796810b98" name="aaafede3d674488e846bdf77796810b98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaafede3d674488e846bdf77796810b98">&#9670;&#160;</a></span>getUnitCellTransforms()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Tacc, typename Tcalc, typename T4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structstormm_1_1synthesis_1_1PsSynthesisBorders.html">PsSynthesisBorders</a> <a class="el" href="classstormm_1_1energy_1_1CellGrid.html">stormm::energy::CellGrid</a>&lt; T, Tacc, Tcalc, T4 &gt;::getUnitCellTransforms </td>
          <td>(</td>
          <td class="paramtype">CoordinateCycle</td>          <td class="paramname"><span class="paramname"><em>orientation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a miniature abstract of the underlying coordinate synthesis containing pointers to the arays of unit cell transformation matrices for each system. </p>
<p>Overloaded:</p><ul>
<li>Specify a stage of the coordinate cycle at which to retrieve box information</li>
<li>Take the <a class="el" href="classstormm_1_1mm_1_1CellGrid.html" title="An object to manage the spatial decomposition of a system of particles. The general strategy is to ar...">CellGrid</a>'s own stage of the coordinate cycle (the <a class="el" href="classstormm_1_1mm_1_1CellGrid.html" title="An object to manage the spatial decomposition of a system of particles. The general strategy is to ar...">CellGrid</a> and its underlying synthesis should be aligned in their cycle positions in most situations)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orientation</td><td>Indicate whether to get the transformation matrices for the WHITE or BLACK stages of the coordinate cycle in the underlying synthesis. If unspecified, the coordinate cycle position of the <a class="el" href="classstormm_1_1mm_1_1CellGrid.html" title="An object to manage the spatial decomposition of a system of particles. The general strategy is to ar...">CellGrid</a> itself will be submitted. </td></tr>
    <tr><td class="paramname">tier</td><td>Indicate whether to retrieve pointers to memory on the CPU host or GPU device </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9367a8dd4c2090b8f0bee89127b085f9" name="a9367a8dd4c2090b8f0bee89127b085f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9367a8dd4c2090b8f0bee89127b085f9">&#9670;&#160;</a></span>initializeForces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Tacc, typename Tcalc, typename T4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstormm_1_1energy_1_1CellGrid.html">stormm::energy::CellGrid</a>&lt; T, Tacc, Tcalc, T4 &gt;::initializeForces </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gpu</em></span><span class="paramdefsep"> = </span><span class="paramdefval">null_gpu</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize forces for the cell grid, on the CPU host or GPU device. This standalone feature provides a means for performing this activity at will, although in the most optimized code the process it performs will be fused with some other kernel. This will initialize forces for the current cell layout and should only be called once the contents of image_cell_limits or image_cell_limits_alt have been settled, whichever is appropriate to the current time cycle. There is only one array of forces in the <a class="el" href="classstormm_1_1mm_1_1CellGrid.html" title="An object to manage the spatial decomposition of a system of particles. The general strategy is to ar...">CellGrid</a>, as once they are accumulated in this object they are added to one of the two time-cycle dependent arrays in the accompanying <a class="el" href="classstormm_1_1mm_1_1PhaseSpaceSynthesis.html" title="A fixed-precision representation of coordinates, velocities, and forces to manage a set of simulation...">PhaseSpaceSynthesis</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tier</td><td>Indicate whether to initialize forces on the CPU host or GPU device </td></tr>
    <tr><td class="paramname">gpu</td><td>Details of the GPU that will perform the initialization of device memory </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32daa97e4cc398abf738a717792fb936" name="a32daa97e4cc398abf738a717792fb936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32daa97e4cc398abf738a717792fb936">&#9670;&#160;</a></span>markImageRelevance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Tacc, typename Tcalc, typename T4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstormm_1_1energy_1_1CellGrid.html">stormm::energy::CellGrid</a>&lt; T, Tacc, Tcalc, T4 &gt;::markImageRelevance </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gpu</em></span><span class="paramdefsep"> = </span><span class="paramdefval">null_gpu</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute whether various atoms may be within range of the tower when they are in the plate of various neutral territory decompositions. Bitwise information (1 for relevant, 0 for irrelevant) is recorded in a 16-bit unsigned integer for each atom in the current image, as indicated by its stage in the coordinate cycle. </p>
<p>On GPU resources, the functionality in this routine is fused with particle migration.</p>
<p>The bitwise map is such that any work unit with a given home cell and twelve surrounding "plate" cells 0 (-2 cells along the A axis, -2 cells along the B axis relative to the home cell), 1 (-1, -2 cells along the A and B axes), ..., 4 (+2, -2), ..., 9 (+2, -1), 10 (-2, 0) and 11 (-1, 0) will look in bits 0, 1, ..., 11 to determine whether the atom is relevant. The relevance of atoms in the "tower" cells 0 (-2 along the C axis relative to the home cell), 1 (-1 along the C axis), 3 (+1 along the C axis), and 4 (+2 along the C axis) can be tested by looking at bits 12, 13, 14, and 15, respectively. Only atoms in the bottom and top cells of the tower might be culled due to being more than the cutoff from the nearest plane bounding the plate. Similarly, atoms in the "inner" four cells of the plate (6, 7, 8, and 10) will almost always be relevant. These facts will be utilized when filling the bit mask: only two cells of the tower (for which the calculation is a simple comparison of the Cartesian Z position and the height of a neighbor list cell) and eight cells of the plate are needed. If the unit cell is orthorhombic, the calculations for eight plate cells are likewise very simple. If it is not, the calculations involve finding the location of a point along which to situate a line parallel to the unit cell C axis, then finding the distance of the particle to that line.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tier</td><td>Indicate whether to update the relevance array on the CPU host or GPU device </td></tr>
    <tr><td class="paramname">gpu</td><td>Specifications of the GPU that will carry out calculations </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6013ebd2e70ac027cc5d75296df64709" name="a6013ebd2e70ac027cc5d75296df64709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6013ebd2e70ac027cc5d75296df64709">&#9670;&#160;</a></span>updateCyclePosition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Tacc, typename Tcalc, typename T4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstormm_1_1energy_1_1CellGrid.html">stormm::energy::CellGrid</a>&lt; T, Tacc, Tcalc, T4 &gt;::updateCyclePosition </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the object's cycle position as it participates in the WHITE:BLACK tick-tock mechanics of other coordinate objects. </p>
<p>Overloaded:</p><ul>
<li>Increment the cycle position one step forward (this toggles between the WHITE and BLACK states, and is the same as decrementing the cycle position unless the time cycle takes on a third possible stage) <br  />
</li>
<li>Set the time cycle to a specific point</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time_point</td><td>The point in the time cycle which the object is to take as "current" </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/Potential/<a class="el" href="cellgrid_8h_source.html">cellgrid.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2
</small></address>
</div><!-- doc-content -->
</body>
</html>
