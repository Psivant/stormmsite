<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>STORMM Source Documentation: stormm::energy::AtomGraph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">STORMM Source Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>stormm</b></li><li class="navelem"><b>energy</b></li><li class="navelem"><a class="el" href="classstormm_1_1energy_1_1AtomGraph.html">AtomGraph</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classstormm_1_1energy_1_1AtomGraph-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">stormm::energy::AtomGraph Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A struct to hold information relating to an Amber topology. This struct's member functions are limited to getters for its private data. Because the primary means of constructing a topology will be complex, i.e. meticulous parsing of a file or expansion of an existing topology based on some new information, the constructors will need to be buried within wrapper functions that perform such procedures. This struct contains all information contained within an Amber prmtop-format file, nothng more, as described on:  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="atomgraph_8h_source.html">atomgraph.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae1616281b03ea4a1a142ae40c8a57c5a" id="r_ae1616281b03ea4a1a142ae40c8a57c5a"><td class="memItemLeft" align="right" valign="top"><a id="ae1616281b03ea4a1a142ae40c8a57c5a" name="ae1616281b03ea4a1a142ae40c8a57c5a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AtomGraph</b> ()</td></tr>
<tr class="memdesc:ae1616281b03ea4a1a142ae40c8a57c5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The blank constructor makes a blank <a class="el" href="classstormm_1_1energy_1_1AtomGraph.html" title="A struct to hold information relating to an Amber topology. This struct&#39;s member functions are limite...">AtomGraph</a>, which is used by the general- purpose file-based constructor to delegate initialization. <br /></td></tr>
<tr class="separator:ae1616281b03ea4a1a142ae40c8a57c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5af36f94dfc8922430f31610b9d82c" id="r_a8b5af36f94dfc8922430f31610b9d82c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b5af36f94dfc8922430f31610b9d82c">AtomGraph</a> (const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;original)</td></tr>
<tr class="memdesc:a8b5af36f94dfc8922430f31610b9d82c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The copy constructor takes a lot of tedium upon itself to prevent more complexity in working with <a class="el" href="classstormm_1_1energy_1_1AtomGraph.html" title="A struct to hold information relating to an Amber topology. This struct&#39;s member functions are limite...">AtomGraph</a> objects downstream.  <br /></td></tr>
<tr class="separator:a8b5af36f94dfc8922430f31610b9d82c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d79ebd487db56bced1642e823d8b77" id="r_ad8d79ebd487db56bced1642e823d8b77"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8d79ebd487db56bced1642e823d8b77">AtomGraph</a> (<a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;&amp;original)</td></tr>
<tr class="memdesc:ad8d79ebd487db56bced1642e823d8b77"><td class="mdescLeft">&#160;</td><td class="mdescRight">The move constructor makes prodigious use of std::move for each string and <a class="el" href="classstormm_1_1energy_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> member variable.  <br /></td></tr>
<tr class="separator:ad8d79ebd487db56bced1642e823d8b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86fa1b1e2570448753ad852b789dfed9" id="r_a86fa1b1e2570448753ad852b789dfed9"><td class="memItemLeft" align="right" valign="top"><a id="a86fa1b1e2570448753ad852b789dfed9" name="a86fa1b1e2570448753ad852b789dfed9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~AtomGraph</b> ()=default</td></tr>
<tr class="memdesc:a86fa1b1e2570448753ad852b789dfed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default destructor is adequate. <br /></td></tr>
<tr class="separator:a86fa1b1e2570448753ad852b789dfed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3bc6196852d2b207843c9796143723e" id="r_ab3bc6196852d2b207843c9796143723e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3bc6196852d2b207843c9796143723e">operator=</a> (const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;other)</td></tr>
<tr class="memdesc:ab3bc6196852d2b207843c9796143723e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:ab3bc6196852d2b207843c9796143723e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb2dbe08db5eda24dd446b20bfc56aa" id="r_a5bb2dbe08db5eda24dd446b20bfc56aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5bb2dbe08db5eda24dd446b20bfc56aa">operator=</a> (<a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a5bb2dbe08db5eda24dd446b20bfc56aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <br /></td></tr>
<tr class="separator:a5bb2dbe08db5eda24dd446b20bfc56aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68367674e283799bf8e522a849b9960" id="r_aa68367674e283799bf8e522a849b9960"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa68367674e283799bf8e522a849b9960">buildFromPrmtop</a> (const std::string &amp;file_name, const ExceptionResponse policy=ExceptionResponse::WARN, double coulomb_constant_in=amber_ancient_bioq, double default_elec14_screening=amber_default_elec14_screen, double default_vdw14_screening=amber_default_vdw14_screen, double charge_rounding_tol=default_charge_rounding_tol, double charge_discretization=default_charge_precision_inc)</td></tr>
<tr class="memdesc:aa68367674e283799bf8e522a849b9960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build an <a class="el" href="classstormm_1_1energy_1_1AtomGraph.html" title="A struct to hold information relating to an Amber topology. This struct&#39;s member functions are limite...">AtomGraph</a> form a file. This is called by the general-purpose constructor or also by the developer after instantiating an empty object.  <br /></td></tr>
<tr class="separator:aa68367674e283799bf8e522a849b9960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c66d4369686e1fff0244a10b55abb2" id="r_af8c66d4369686e1fff0244a10b55abb2"><td class="memItemLeft" align="right" valign="top"><a id="af8c66d4369686e1fff0244a10b55abb2" name="af8c66d4369686e1fff0244a10b55abb2"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getTitle</b> () const</td></tr>
<tr class="memdesc:af8c66d4369686e1fff0244a10b55abb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the title of the topology (may be blank). <br /></td></tr>
<tr class="separator:af8c66d4369686e1fff0244a10b55abb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad06c9aeed00f8a3630905ade408ab1bc" id="r_ad06c9aeed00f8a3630905ade408ab1bc"><td class="memItemLeft" align="right" valign="top"><a id="ad06c9aeed00f8a3630905ade408ab1bc" name="ad06c9aeed00f8a3630905ade408ab1bc"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getFileName</b> () const</td></tr>
<tr class="memdesc:ad06c9aeed00f8a3630905ade408ab1bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the file name where a topology originated (may be blank, indicating that the topology was produced by some other means). <br /></td></tr>
<tr class="separator:ad06c9aeed00f8a3630905ade408ab1bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae118a08b2815a21f40317f1fcd3c7c2a" id="r_ae118a08b2815a21f40317f1fcd3c7c2a"><td class="memItemLeft" align="right" valign="top"><a id="ae118a08b2815a21f40317f1fcd3c7c2a" name="ae118a08b2815a21f40317f1fcd3c7c2a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getAtomCount</b> () const</td></tr>
<tr class="memdesc:ae118a08b2815a21f40317f1fcd3c7c2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of atoms, using the topology's dedicated private variable rather than a list of input dimensions that was mostly stored for developers most familiar with Amber. <br /></td></tr>
<tr class="separator:ae118a08b2815a21f40317f1fcd3c7c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45149568c62cc7e39ba34d8df6fe5e4d" id="r_a45149568c62cc7e39ba34d8df6fe5e4d"><td class="memItemLeft" align="right" valign="top"><a id="a45149568c62cc7e39ba34d8df6fe5e4d" name="a45149568c62cc7e39ba34d8df6fe5e4d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getResidueCount</b> () const</td></tr>
<tr class="memdesc:a45149568c62cc7e39ba34d8df6fe5e4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of residues. <br /></td></tr>
<tr class="separator:a45149568c62cc7e39ba34d8df6fe5e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b77e12c6f2399c501a4498705e8697" id="r_ab9b77e12c6f2399c501a4498705e8697"><td class="memItemLeft" align="right" valign="top"><a id="ab9b77e12c6f2399c501a4498705e8697" name="ab9b77e12c6f2399c501a4498705e8697"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getMoleculeCount</b> () const</td></tr>
<tr class="memdesc:ab9b77e12c6f2399c501a4498705e8697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of separate molecules in the system. <br /></td></tr>
<tr class="separator:ab9b77e12c6f2399c501a4498705e8697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ecdb9ee2a0fccff83874bc7243bc3b" id="r_a37ecdb9ee2a0fccff83874bc7243bc3b"><td class="memItemLeft" align="right" valign="top">MoleculeKind&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37ecdb9ee2a0fccff83874bc7243bc3b">getMoleculeKind</a> (int mol_index) const</td></tr>
<tr class="memdesc:a37ecdb9ee2a0fccff83874bc7243bc3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the kind of a specific molecule wihtin the topology.  <br /></td></tr>
<tr class="separator:a37ecdb9ee2a0fccff83874bc7243bc3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb30ecfc9cf326960eb562e8c3247b8" id="r_a7eb30ecfc9cf326960eb562e8c3247b8"><td class="memItemLeft" align="right" valign="top"><a id="a7eb30ecfc9cf326960eb562e8c3247b8" name="a7eb30ecfc9cf326960eb562e8c3247b8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getOrganicMoleculeCount</b> () const</td></tr>
<tr class="memdesc:a7eb30ecfc9cf326960eb562e8c3247b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of organic molecules in the system, based on the criteria of greater than or equal to eight total real atoms and at least one carbon atom. <br /></td></tr>
<tr class="separator:a7eb30ecfc9cf326960eb562e8c3247b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a6247725935799cb1e553ac6ea7d59" id="r_ab2a6247725935799cb1e553ac6ea7d59"><td class="memItemLeft" align="right" valign="top"><a id="ab2a6247725935799cb1e553ac6ea7d59" name="ab2a6247725935799cb1e553ac6ea7d59"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getOrganicAtomCount</b> () const</td></tr>
<tr class="memdesc:ab2a6247725935799cb1e553ac6ea7d59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of organic atoms in the system, based on the criteria of greater than or equal to eight total real atoms and at least one carbon atom. <br /></td></tr>
<tr class="separator:ab2a6247725935799cb1e553ac6ea7d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad48022da5b5755852056e80c1396145a" id="r_ad48022da5b5755852056e80c1396145a"><td class="memItemLeft" align="right" valign="top"><a id="ad48022da5b5755852056e80c1396145a" name="ad48022da5b5755852056e80c1396145a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getWaterResidueSize</b> () const</td></tr>
<tr class="memdesc:ad48022da5b5755852056e80c1396145a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of particles (which may include virtual sites) in a single water molecule within the system. <br /></td></tr>
<tr class="separator:ad48022da5b5755852056e80c1396145a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bbbe75a86d460f938ed34bf3d870aa7" id="r_a9bbbe75a86d460f938ed34bf3d870aa7"><td class="memItemLeft" align="right" valign="top"><a id="a9bbbe75a86d460f938ed34bf3d870aa7" name="a9bbbe75a86d460f938ed34bf3d870aa7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getWaterResidueCount</b> () const</td></tr>
<tr class="memdesc:a9bbbe75a86d460f938ed34bf3d870aa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of water residues in the system. <br /></td></tr>
<tr class="separator:a9bbbe75a86d460f938ed34bf3d870aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0bbe2dc8c28f21822f72b255615fd9" id="r_afb0bbe2dc8c28f21822f72b255615fd9"><td class="memItemLeft" align="right" valign="top"><a id="afb0bbe2dc8c28f21822f72b255615fd9" name="afb0bbe2dc8c28f21822f72b255615fd9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getLargestResidueSize</b> () const</td></tr>
<tr class="memdesc:afb0bbe2dc8c28f21822f72b255615fd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of separate molecules in the system. <br /></td></tr>
<tr class="separator:afb0bbe2dc8c28f21822f72b255615fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d42f60dbdc855858d8069bba8a57f2" id="r_a32d42f60dbdc855858d8069bba8a57f2"><td class="memItemLeft" align="right" valign="top"><a id="a32d42f60dbdc855858d8069bba8a57f2" name="a32d42f60dbdc855858d8069bba8a57f2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getLastSoluteResidue</b> () const</td></tr>
<tr class="memdesc:a32d42f60dbdc855858d8069bba8a57f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the final solute residue, indexed according to C/C++ array indexing conventions. <br /></td></tr>
<tr class="separator:a32d42f60dbdc855858d8069bba8a57f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8d00671565d3bb535a50441f6a173d" id="r_a9a8d00671565d3bb535a50441f6a173d"><td class="memItemLeft" align="right" valign="top"><a id="a9a8d00671565d3bb535a50441f6a173d" name="a9a8d00671565d3bb535a50441f6a173d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getLastSoluteAtom</b> () const</td></tr>
<tr class="memdesc:a9a8d00671565d3bb535a50441f6a173d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the final solute atom, indexed according to C/C++ array indexing conventions. <br /></td></tr>
<tr class="separator:a9a8d00671565d3bb535a50441f6a173d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d461eb0180b2942487819c7f6d192c" id="r_aa3d461eb0180b2942487819c7f6d192c"><td class="memItemLeft" align="right" valign="top"><a id="aa3d461eb0180b2942487819c7f6d192c" name="aa3d461eb0180b2942487819c7f6d192c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getFirstSolventMolecule</b> () const</td></tr>
<tr class="memdesc:aa3d461eb0180b2942487819c7f6d192c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first solvent molecule, indexed according to C/C++ array indexing conventions. <br /></td></tr>
<tr class="separator:aa3d461eb0180b2942487819c7f6d192c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a902fe2650d5ba9f27b685ef1de254061" id="r_a902fe2650d5ba9f27b685ef1de254061"><td class="memItemLeft" align="right" valign="top"><a id="a902fe2650d5ba9f27b685ef1de254061" name="a902fe2650d5ba9f27b685ef1de254061"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getFirstSolventAtom</b> () const</td></tr>
<tr class="memdesc:a902fe2650d5ba9f27b685ef1de254061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first solvent atom, indexed according to C/C++ array indexing conventions. <br /></td></tr>
<tr class="separator:a902fe2650d5ba9f27b685ef1de254061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af003b7e7000a256f82bd26d1a4af00c9" id="r_af003b7e7000a256f82bd26d1a4af00c9"><td class="memItemLeft" align="right" valign="top"><a id="af003b7e7000a256f82bd26d1a4af00c9" name="af003b7e7000a256f82bd26d1a4af00c9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getLargestMoleculeSize</b> () const</td></tr>
<tr class="memdesc:af003b7e7000a256f82bd26d1a4af00c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the largest molecule's size. <br /></td></tr>
<tr class="separator:af003b7e7000a256f82bd26d1a4af00c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f5d383bff166da269273cbcafe7247d" id="r_a5f5d383bff166da269273cbcafe7247d"><td class="memItemLeft" align="right" valign="top"><a id="a5f5d383bff166da269273cbcafe7247d" name="a5f5d383bff166da269273cbcafe7247d"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getTotalMass</b> () const</td></tr>
<tr class="memdesc:a5f5d383bff166da269273cbcafe7247d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total mass of all atoms in the topology (this is a computation, not a stored value). <br /></td></tr>
<tr class="separator:a5f5d383bff166da269273cbcafe7247d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad543c6120e705c7f26aede004708184f" id="r_ad543c6120e705c7f26aede004708184f"><td class="memItemLeft" align="right" valign="top"><a id="ad543c6120e705c7f26aede004708184f" name="ad543c6120e705c7f26aede004708184f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getDegreesOfFreedom</b> () const</td></tr>
<tr class="memdesc:ad543c6120e705c7f26aede004708184f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of degrees of freedom, without consideration to geometric constraints. <br /></td></tr>
<tr class="separator:ad543c6120e705c7f26aede004708184f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca44410df1bf093da25992057bb738ed" id="r_aca44410df1bf093da25992057bb738ed"><td class="memItemLeft" align="right" valign="top"><a id="aca44410df1bf093da25992057bb738ed" name="aca44410df1bf093da25992057bb738ed"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getConstrainedDegreesOfFreedom</b> () const</td></tr>
<tr class="memdesc:aca44410df1bf093da25992057bb738ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of degrees of freedom after geometric constraints have been applied. <br /></td></tr>
<tr class="separator:aca44410df1bf093da25992057bb738ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a8df0b247b19aa13619a9b7b29694d" id="r_a96a8df0b247b19aa13619a9b7b29694d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96a8df0b247b19aa13619a9b7b29694d">getParticlesPerMolecule</a> () const</td></tr>
<tr class="memdesc:a96a8df0b247b19aa13619a9b7b29694d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sizes of all molecules in the system. Rather redundant with the molecule limits being accessible, but convenient.  <br /></td></tr>
<tr class="separator:a96a8df0b247b19aa13619a9b7b29694d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600e99583aa15cccead474fc357cea31" id="r_a600e99583aa15cccead474fc357cea31"><td class="memItemLeft" align="right" valign="top"><a id="a600e99583aa15cccead474fc357cea31" name="a600e99583aa15cccead474fc357cea31"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getParticlesPerMolecule</b> (int index) const</td></tr>
<tr class="separator:a600e99583aa15cccead474fc357cea31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ba883d001355455d81cdef475d18b9" id="r_ad6ba883d001355455d81cdef475d18b9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6ba883d001355455d81cdef475d18b9">getFullAtomName</a> (int index) const</td></tr>
<tr class="memdesc:ad6ba883d001355455d81cdef475d18b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the full name (including the residue and structural residue number) of an atom, as a string.  <br /></td></tr>
<tr class="separator:ad6ba883d001355455d81cdef475d18b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfbc7a295ae941144138d0c201032853" id="r_abfbc7a295ae941144138d0c201032853"><td class="memItemLeft" align="right" valign="top"><a id="abfbc7a295ae941144138d0c201032853" name="abfbc7a295ae941144138d0c201032853"></a>
std::vector&lt; std::vector&lt; <a class="el" href="structstormm_1_1data__types_1_1char4.html">char4</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getAtomTypeNameTable</b> () const</td></tr>
<tr class="memdesc:abfbc7a295ae941144138d0c201032853"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a table with the names of all unique atom types, arranged according to their Lennard-Jones indices as they appear in the topology (in ascending order). <br /></td></tr>
<tr class="separator:abfbc7a295ae941144138d0c201032853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef4ce59a70e3fa07933d22a3f20bf50" id="r_a5ef4ce59a70e3fa07933d22a3f20bf50"><td class="memItemLeft" align="right" valign="top"><a id="a5ef4ce59a70e3fa07933d22a3f20bf50" name="a5ef4ce59a70e3fa07933d22a3f20bf50"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getUreyBradleyTermCount</b> () const</td></tr>
<tr class="memdesc:a5ef4ce59a70e3fa07933d22a3f20bf50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of Urey-Bradley terms in the system. <br /></td></tr>
<tr class="separator:a5ef4ce59a70e3fa07933d22a3f20bf50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefed386a5162de84ea0bff18b438fed2" id="r_aefed386a5162de84ea0bff18b438fed2"><td class="memItemLeft" align="right" valign="top"><a id="aefed386a5162de84ea0bff18b438fed2" name="aefed386a5162de84ea0bff18b438fed2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getCharmmImprTermCount</b> () const</td></tr>
<tr class="memdesc:aefed386a5162de84ea0bff18b438fed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of CHARMM improper terms. <br /></td></tr>
<tr class="separator:aefed386a5162de84ea0bff18b438fed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ab0e21956dce5809085609716bcc08" id="r_ab5ab0e21956dce5809085609716bcc08"><td class="memItemLeft" align="right" valign="top"><a id="ab5ab0e21956dce5809085609716bcc08" name="ab5ab0e21956dce5809085609716bcc08"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getCmapTermCount</b> () const</td></tr>
<tr class="memdesc:ab5ab0e21956dce5809085609716bcc08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of CMAP terms (the number of CMAP parameter surfaces is different) <br /></td></tr>
<tr class="separator:ab5ab0e21956dce5809085609716bcc08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb6e67ce04739a9df94accafc2c887b" id="r_a6cb6e67ce04739a9df94accafc2c887b"><td class="memItemLeft" align="right" valign="top"><a id="a6cb6e67ce04739a9df94accafc2c887b" name="a6cb6e67ce04739a9df94accafc2c887b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getUreyBradleyParameterCount</b> () const</td></tr>
<tr class="memdesc:a6cb6e67ce04739a9df94accafc2c887b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of unique Urey-Bradley parameter sets. <br /></td></tr>
<tr class="separator:a6cb6e67ce04739a9df94accafc2c887b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a0bd7c8c3ad6d1afbafb44f456673f" id="r_a30a0bd7c8c3ad6d1afbafb44f456673f"><td class="memItemLeft" align="right" valign="top"><a id="a30a0bd7c8c3ad6d1afbafb44f456673f" name="a30a0bd7c8c3ad6d1afbafb44f456673f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getCharmmImprParameterCount</b> () const</td></tr>
<tr class="memdesc:a30a0bd7c8c3ad6d1afbafb44f456673f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of unique CHARMM improper parameter sets. <br /></td></tr>
<tr class="separator:a30a0bd7c8c3ad6d1afbafb44f456673f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ffb1afb96db519a1de78638bfe3668" id="r_ac6ffb1afb96db519a1de78638bfe3668"><td class="memItemLeft" align="right" valign="top"><a id="ac6ffb1afb96db519a1de78638bfe3668" name="ac6ffb1afb96db519a1de78638bfe3668"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getCmapSurfaceCount</b> () const</td></tr>
<tr class="memdesc:ac6ffb1afb96db519a1de78638bfe3668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of unique CMAP surfaces. <br /></td></tr>
<tr class="separator:ac6ffb1afb96db519a1de78638bfe3668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa020e1c2cd7c704253230bae4ce30d21" id="r_aa020e1c2cd7c704253230bae4ce30d21"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa020e1c2cd7c704253230bae4ce30d21">getCmapDimension</a> (int index) const</td></tr>
<tr class="memdesc:aa020e1c2cd7c704253230bae4ce30d21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the dimension of a particular CMAP surface (all CMAPs are assumed to be square)  <br /></td></tr>
<tr class="separator:aa020e1c2cd7c704253230bae4ce30d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d71afd37ae4bf909f7cca1ff54ceeb" id="r_a09d71afd37ae4bf909f7cca1ff54ceeb"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a09d71afd37ae4bf909f7cca1ff54ceeb"><td class="memTemplItemLeft" align="right" valign="top">UreyBradleyTerm&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a09d71afd37ae4bf909f7cca1ff54ceeb">getUreyBradleyTerm</a> (int index) const</td></tr>
<tr class="memdesc:a09d71afd37ae4bf909f7cca1ff54ceeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect the atom indices and actual parameters to implement one of the system's Urey-Bradley terms. The special-purpose, unguarded struct that holds the result also provides the original parameter index, if of interest. This is for computing the potential energy and forces in the most straightforward manner possible, albeit slow.  <br /></td></tr>
<tr class="separator:a09d71afd37ae4bf909f7cca1ff54ceeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f43094f2ff71ee760494260e29f4240" id="r_a3f43094f2ff71ee760494260e29f4240"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a3f43094f2ff71ee760494260e29f4240"><td class="memTemplItemLeft" align="right" valign="top">CharmmImprTerm&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3f43094f2ff71ee760494260e29f4240">getCharmmImprTerm</a> (int index) const</td></tr>
<tr class="memdesc:a3f43094f2ff71ee760494260e29f4240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect the atom indices and actual parameters to implement one of the system's CHARMM improper terms. The special-pupose, unguarded struct that holds the result also provides the original parameter index, if of interest. This is for computing the potential energy and forces in the most straightforward manner possible, albeit slow.  <br /></td></tr>
<tr class="separator:a3f43094f2ff71ee760494260e29f4240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a578338544f90cf6f49371cdd4e856ba5" id="r_a578338544f90cf6f49371cdd4e856ba5"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a578338544f90cf6f49371cdd4e856ba5"><td class="memTemplItemLeft" align="right" valign="top">CmapTerm&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a578338544f90cf6f49371cdd4e856ba5">getCmapTerm</a> (int index) const</td></tr>
<tr class="memdesc:a578338544f90cf6f49371cdd4e856ba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect the atom indices and a pointer to the surface to implement one of the system's CMAP terms. The special-purpose, unguarded struct that holds the result also provides the original parameter index, if of interest.  <br /></td></tr>
<tr class="separator:a578338544f90cf6f49371cdd4e856ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a034d136852a660d09230a8305eddb09b" id="r_a034d136852a660d09230a8305eddb09b"><td class="memItemLeft" align="right" valign="top"><a id="a034d136852a660d09230a8305eddb09b" name="a034d136852a660d09230a8305eddb09b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getBondTermCount</b> () const</td></tr>
<tr class="memdesc:a034d136852a660d09230a8305eddb09b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of bond stretching terms in the system. <br /></td></tr>
<tr class="separator:a034d136852a660d09230a8305eddb09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e017745460c9baaa04565592e27914d" id="r_a8e017745460c9baaa04565592e27914d"><td class="memItemLeft" align="right" valign="top"><a id="a8e017745460c9baaa04565592e27914d" name="a8e017745460c9baaa04565592e27914d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getAngleTermCount</b> () const</td></tr>
<tr class="memdesc:a8e017745460c9baaa04565592e27914d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of angle bending terms in the system. <br /></td></tr>
<tr class="separator:a8e017745460c9baaa04565592e27914d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1feaf5706787f354901e885b7a97338" id="r_ae1feaf5706787f354901e885b7a97338"><td class="memItemLeft" align="right" valign="top"><a id="ae1feaf5706787f354901e885b7a97338" name="ae1feaf5706787f354901e885b7a97338"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getDihedralTermCount</b> () const</td></tr>
<tr class="memdesc:ae1feaf5706787f354901e885b7a97338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of dihedral torsion terms in the system. <br /></td></tr>
<tr class="separator:ae1feaf5706787f354901e885b7a97338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6c2e5b2a28e009563330aad4fc8c658" id="r_ac6c2e5b2a28e009563330aad4fc8c658"><td class="memItemLeft" align="right" valign="top"><a id="ac6c2e5b2a28e009563330aad4fc8c658" name="ac6c2e5b2a28e009563330aad4fc8c658"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getBondParameterCount</b> () const</td></tr>
<tr class="memdesc:ac6c2e5b2a28e009563330aad4fc8c658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of unique bond stretching parameter sets. <br /></td></tr>
<tr class="separator:ac6c2e5b2a28e009563330aad4fc8c658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3700f0b2cdb388df8aebadcdfe04cf66" id="r_a3700f0b2cdb388df8aebadcdfe04cf66"><td class="memItemLeft" align="right" valign="top"><a id="a3700f0b2cdb388df8aebadcdfe04cf66" name="a3700f0b2cdb388df8aebadcdfe04cf66"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getAngleParameterCount</b> () const</td></tr>
<tr class="memdesc:a3700f0b2cdb388df8aebadcdfe04cf66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of unique bond angle bending parameter sets. <br /></td></tr>
<tr class="separator:a3700f0b2cdb388df8aebadcdfe04cf66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a117fad6c93df6f734b39473d39709473" id="r_a117fad6c93df6f734b39473d39709473"><td class="memItemLeft" align="right" valign="top"><a id="a117fad6c93df6f734b39473d39709473" name="a117fad6c93df6f734b39473d39709473"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getDihedralParameterCount</b> () const</td></tr>
<tr class="memdesc:a117fad6c93df6f734b39473d39709473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of unique dihedral parameter sets. <br /></td></tr>
<tr class="separator:a117fad6c93df6f734b39473d39709473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a561b6dc629f72c2f8a3e9bc79805bb" id="r_a0a561b6dc629f72c2f8a3e9bc79805bb"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a0a561b6dc629f72c2f8a3e9bc79805bb"><td class="memTemplItemLeft" align="right" valign="top">BondTerm&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0a561b6dc629f72c2f8a3e9bc79805bb">getBondTerm</a> (int index) const</td></tr>
<tr class="memdesc:a0a561b6dc629f72c2f8a3e9bc79805bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect the atom indices and actual parameters for implement one of the system's harmonic bond stretching terms.  <br /></td></tr>
<tr class="separator:a0a561b6dc629f72c2f8a3e9bc79805bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a820b6cf62ea4f263705ea64d7bf48d6f" id="r_a820b6cf62ea4f263705ea64d7bf48d6f"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a820b6cf62ea4f263705ea64d7bf48d6f"><td class="memTemplItemLeft" align="right" valign="top">AngleTerm&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a820b6cf62ea4f263705ea64d7bf48d6f">getAngleTerm</a> (int index) const</td></tr>
<tr class="memdesc:a820b6cf62ea4f263705ea64d7bf48d6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect the atom indices and actual parameters for implement one of the system's harmonic bond angle bending terms.  <br /></td></tr>
<tr class="separator:a820b6cf62ea4f263705ea64d7bf48d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a052efb1a0f8c827101142168afdedc4a" id="r_a052efb1a0f8c827101142168afdedc4a"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a052efb1a0f8c827101142168afdedc4a"><td class="memTemplItemLeft" align="right" valign="top">DihedralTerm&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a052efb1a0f8c827101142168afdedc4a">getDihedralTerm</a> (int index) const</td></tr>
<tr class="memdesc:a052efb1a0f8c827101142168afdedc4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect the atom indices and actual parameters for implement one of the system's cosine-based dihedral torsion terms.  <br /></td></tr>
<tr class="separator:a052efb1a0f8c827101142168afdedc4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c2b91482ad5b792d28588c372b935d" id="r_a77c2b91482ad5b792d28588c372b935d"><td class="memItemLeft" align="right" valign="top"><a id="a77c2b91482ad5b792d28588c372b935d" name="a77c2b91482ad5b792d28588c372b935d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getVirtualSiteCount</b> () const</td></tr>
<tr class="memdesc:a77c2b91482ad5b792d28588c372b935d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of virtual sites in the system. <br /></td></tr>
<tr class="separator:a77c2b91482ad5b792d28588c372b935d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0384ae88b85ace68b0fb59b18342aa50" id="r_a0384ae88b85ace68b0fb59b18342aa50"><td class="memItemLeft" align="right" valign="top"><a id="a0384ae88b85ace68b0fb59b18342aa50" name="a0384ae88b85ace68b0fb59b18342aa50"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getVirtualSiteParameterSetCount</b> () const</td></tr>
<tr class="memdesc:a0384ae88b85ace68b0fb59b18342aa50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of unique virtual site frames in the system. For example, a system of 1024 TIP-4P waters would have one unique frame, applied to 1024 different groups of atoms. <br /></td></tr>
<tr class="separator:a0384ae88b85ace68b0fb59b18342aa50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ef34fd71594b3c252ed7427b9b7f6b" id="r_a91ef34fd71594b3c252ed7427b9b7f6b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91ef34fd71594b3c252ed7427b9b7f6b">getVirtualSiteIndex</a> (int atom_index, ExceptionResponse policy=ExceptionResponse::DIE) const</td></tr>
<tr class="memdesc:a91ef34fd71594b3c252ed7427b9b7f6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the virtual site index of an atom index. If the atom index is not a virtual site, this function will throw an error.  <br /></td></tr>
<tr class="separator:a91ef34fd71594b3c252ed7427b9b7f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15fca03a580f470d5bcdde57c6df2288" id="r_a15fca03a580f470d5bcdde57c6df2288"><td class="memItemLeft" align="right" valign="top">VirtualSiteKind&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15fca03a580f470d5bcdde57c6df2288">getVirtualSiteFrameType</a> (int index) const</td></tr>
<tr class="memdesc:a15fca03a580f470d5bcdde57c6df2288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the frame type of a particular virtual site.  <br /></td></tr>
<tr class="separator:a15fca03a580f470d5bcdde57c6df2288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8738095c48c67ab3a37842607d3597ff" id="r_a8738095c48c67ab3a37842607d3597ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8738095c48c67ab3a37842607d3597ff">getVirtualSiteFrameAtom</a> (int index, int nfrm) const</td></tr>
<tr class="memdesc:a8738095c48c67ab3a37842607d3597ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the general topology index of one of a virtual site's frame atoms.  <br /></td></tr>
<tr class="separator:a8738095c48c67ab3a37842607d3597ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a78d76a16dbdd948a944f7219c89b9d" id="r_a7a78d76a16dbdd948a944f7219c89b9d"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a7a78d76a16dbdd948a944f7219c89b9d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7a78d76a16dbdd948a944f7219c89b9d">getVirtualSiteFrameDimension</a> (int index, int ndim)</td></tr>
<tr class="memdesc:a7a78d76a16dbdd948a944f7219c89b9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dimensions (could be length in A, could be scaling factor for a distance or cross product) of one virtual site's frame.  <br /></td></tr>
<tr class="separator:a7a78d76a16dbdd948a944f7219c89b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b08f5dfa88ddeb33a0a440b63c7364" id="r_a23b08f5dfa88ddeb33a0a440b63c7364"><td class="memItemLeft" align="right" valign="top"><a id="a23b08f5dfa88ddeb33a0a440b63c7364" name="a23b08f5dfa88ddeb33a0a440b63c7364"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getChargeTypeCount</b> () const</td></tr>
<tr class="memdesc:a23b08f5dfa88ddeb33a0a440b63c7364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of charge types in the system. <br /></td></tr>
<tr class="separator:a23b08f5dfa88ddeb33a0a440b63c7364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a90783e961c1344b8966aff82d37ec4" id="r_a7a90783e961c1344b8966aff82d37ec4"><td class="memItemLeft" align="right" valign="top"><a id="a7a90783e961c1344b8966aff82d37ec4" name="a7a90783e961c1344b8966aff82d37ec4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getLJTypeCount</b> () const</td></tr>
<tr class="memdesc:a7a90783e961c1344b8966aff82d37ec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of atom types in the system. <br /></td></tr>
<tr class="separator:a7a90783e961c1344b8966aff82d37ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a587d227564841dba710796e5908cad59" id="r_a587d227564841dba710796e5908cad59"><td class="memItemLeft" align="right" valign="top"><a id="a587d227564841dba710796e5908cad59" name="a587d227564841dba710796e5908cad59"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getTotalExclusions</b> () const</td></tr>
<tr class="memdesc:a587d227564841dba710796e5908cad59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of exclusions in the entire topology. <br /></td></tr>
<tr class="separator:a587d227564841dba710796e5908cad59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b563d1acdbcda9b40a3e3a801ec45c" id="r_ab3b563d1acdbcda9b40a3e3a801ec45c"><td class="memItemLeft" align="right" valign="top"><a id="ab3b563d1acdbcda9b40a3e3a801ec45c" name="ab3b563d1acdbcda9b40a3e3a801ec45c"></a>
UnitCellType&#160;</td><td class="memItemRight" valign="bottom"><b>getUnitCellType</b> () const</td></tr>
<tr class="memdesc:ab3b563d1acdbcda9b40a3e3a801ec45c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the simulation cell type (isolated boundary conditions, rectilinear, triclinic) <br /></td></tr>
<tr class="separator:ab3b563d1acdbcda9b40a3e3a801ec45c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af178776b95ae5589079788f7a130661c" id="r_af178776b95ae5589079788f7a130661c"><td class="memItemLeft" align="right" valign="top"><a id="af178776b95ae5589079788f7a130661c" name="af178776b95ae5589079788f7a130661c"></a>
ImplicitSolventModel&#160;</td><td class="memItemRight" valign="bottom"><b>getImplicitSolventModel</b> () const</td></tr>
<tr class="memdesc:af178776b95ae5589079788f7a130661c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the implicit solvent model type, i.e. some flavor of GB or NONE. <br /></td></tr>
<tr class="separator:af178776b95ae5589079788f7a130661c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d452c336564c0752908bfcbbfbada4" id="r_a91d452c336564c0752908bfcbbfbada4"><td class="memItemLeft" align="right" valign="top"><a id="a91d452c336564c0752908bfcbbfbada4" name="a91d452c336564c0752908bfcbbfbada4"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getDielectricConstant</b> () const</td></tr>
<tr class="memdesc:a91d452c336564c0752908bfcbbfbada4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dielectric constant (part of the implicit solvent setup) <br /></td></tr>
<tr class="separator:a91d452c336564c0752908bfcbbfbada4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81c6f0e31525b074201f37b4e7556d62" id="r_a81c6f0e31525b074201f37b4e7556d62"><td class="memItemLeft" align="right" valign="top"><a id="a81c6f0e31525b074201f37b4e7556d62" name="a81c6f0e31525b074201f37b4e7556d62"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getSaltConcentration</b> () const</td></tr>
<tr class="memdesc:a81c6f0e31525b074201f37b4e7556d62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the salt concentration (part of the implicit solvent setup) <br /></td></tr>
<tr class="separator:a81c6f0e31525b074201f37b4e7556d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b58e9d9adc83903ba866397512d2fc" id="r_a67b58e9d9adc83903ba866397512d2fc"><td class="memItemLeft" align="right" valign="top"><a id="a67b58e9d9adc83903ba866397512d2fc" name="a67b58e9d9adc83903ba866397512d2fc"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getCoulombConstant</b> () const</td></tr>
<tr class="memdesc:a67b58e9d9adc83903ba866397512d2fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the fundamental coulomb constant that this system uses in electrostatic calculations. <br /></td></tr>
<tr class="separator:a67b58e9d9adc83903ba866397512d2fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79d3ee999c65a6020d653bd2d1b28586" id="r_a79d3ee999c65a6020d653bd2d1b28586"><td class="memItemLeft" align="right" valign="top"><a id="a79d3ee999c65a6020d653bd2d1b28586" name="a79d3ee999c65a6020d653bd2d1b28586"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getElectrostatic14Screening</b> () const</td></tr>
<tr class="memdesc:a79d3ee999c65a6020d653bd2d1b28586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the general 1:4 screening factor on electrostatic interactions. <br /></td></tr>
<tr class="separator:a79d3ee999c65a6020d653bd2d1b28586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c6b8697cfa88f0fc49c4ee06183e63d" id="r_a5c6b8697cfa88f0fc49c4ee06183e63d"><td class="memItemLeft" align="right" valign="top"><a id="a5c6b8697cfa88f0fc49c4ee06183e63d" name="a5c6b8697cfa88f0fc49c4ee06183e63d"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getVanDerWaals14Screening</b> () const</td></tr>
<tr class="memdesc:a5c6b8697cfa88f0fc49c4ee06183e63d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the general 1:4 screening factor on van-der Waals interactions. <br /></td></tr>
<tr class="separator:a5c6b8697cfa88f0fc49c4ee06183e63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3434ff27d6474d1f1c61d8a93c248069" id="r_a3434ff27d6474d1f1c61d8a93c248069"><td class="memItemLeft" align="right" valign="top"><a id="a3434ff27d6474d1f1c61d8a93c248069" name="a3434ff27d6474d1f1c61d8a93c248069"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getPBRadiiSet</b> () const</td></tr>
<tr class="memdesc:a3434ff27d6474d1f1c61d8a93c248069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the PB Radii set. <br /></td></tr>
<tr class="separator:a3434ff27d6474d1f1c61d8a93c248069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45029b9dbacf816c46ffa62faad0f9a6" id="r_a45029b9dbacf816c46ffa62faad0f9a6"><td class="memItemLeft" align="right" valign="top"><a id="a45029b9dbacf816c46ffa62faad0f9a6" name="a45029b9dbacf816c46ffa62faad0f9a6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>usesShake</b> () const</td></tr>
<tr class="memdesc:a45029b9dbacf816c46ffa62faad0f9a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the status of SHAKE and RATTLE constraints in the system. <br /></td></tr>
<tr class="separator:a45029b9dbacf816c46ffa62faad0f9a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad295503e4a088ddb799ac4eb5bf1fd22" id="r_ad295503e4a088ddb799ac4eb5bf1fd22"><td class="memItemLeft" align="right" valign="top"><a id="ad295503e4a088ddb799ac4eb5bf1fd22" name="ad295503e4a088ddb799ac4eb5bf1fd22"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>usesSettle</b> () const</td></tr>
<tr class="memdesc:ad295503e4a088ddb799ac4eb5bf1fd22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the status of SETTLE rigid water constraints in the system. <br /></td></tr>
<tr class="separator:ad295503e4a088ddb799ac4eb5bf1fd22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a400b821e91c15c080020c26a24405d2c" id="r_a400b821e91c15c080020c26a24405d2c"><td class="memItemLeft" align="right" valign="top"><a id="a400b821e91c15c080020c26a24405d2c" name="a400b821e91c15c080020c26a24405d2c"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getWaterResidueName</b> () const</td></tr>
<tr class="memdesc:a400b821e91c15c080020c26a24405d2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the water residue name. <br /></td></tr>
<tr class="separator:a400b821e91c15c080020c26a24405d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571b4f36577b80e9d85322d6b82fc7c4" id="r_a571b4f36577b80e9d85322d6b82fc7c4"><td class="memItemLeft" align="right" valign="top"><a id="a571b4f36577b80e9d85322d6b82fc7c4" name="a571b4f36577b80e9d85322d6b82fc7c4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getRigidWaterCount</b> () const</td></tr>
<tr class="memdesc:a571b4f36577b80e9d85322d6b82fc7c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of rigid waters in the system. This will check through the SETTLE groups and confirm the number that are, by their chemistry, water. <br /></td></tr>
<tr class="separator:a571b4f36577b80e9d85322d6b82fc7c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad06420b7b4d64f71fa0a9a69b894f05" id="r_aad06420b7b4d64f71fa0a9a69b894f05"><td class="memItemLeft" align="right" valign="top"><a id="aad06420b7b4d64f71fa0a9a69b894f05" name="aad06420b7b4d64f71fa0a9a69b894f05"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getRigidWaterAtomCount</b> () const</td></tr>
<tr class="memdesc:aad06420b7b4d64f71fa0a9a69b894f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of atoms in a rigid water molecule of the system, if the system has rigid waters. This function will return zero if the system has no rigid waters. <br /></td></tr>
<tr class="separator:aad06420b7b4d64f71fa0a9a69b894f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b912798bdb36ef7b0d1bff38747d63a" id="r_a4b912798bdb36ef7b0d1bff38747d63a"><td class="memItemLeft" align="right" valign="top"><a id="a4b912798bdb36ef7b0d1bff38747d63a" name="a4b912798bdb36ef7b0d1bff38747d63a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getSettleGroupCount</b> () const</td></tr>
<tr class="memdesc:a4b912798bdb36ef7b0d1bff38747d63a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of SETTLE groups in the system. <br /></td></tr>
<tr class="separator:a4b912798bdb36ef7b0d1bff38747d63a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a38539df299c45cbe9a0f1b9bc44a0f" id="r_a6a38539df299c45cbe9a0f1b9bc44a0f"><td class="memItemLeft" align="right" valign="top"><a id="a6a38539df299c45cbe9a0f1b9bc44a0f" name="a6a38539df299c45cbe9a0f1b9bc44a0f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getBondConstraintCount</b> () const</td></tr>
<tr class="memdesc:a6a38539df299c45cbe9a0f1b9bc44a0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of bond constraints. <br /></td></tr>
<tr class="separator:a6a38539df299c45cbe9a0f1b9bc44a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc30d069075ed6dc5b7aec248546ba99" id="r_acc30d069075ed6dc5b7aec248546ba99"><td class="memItemLeft" align="right" valign="top"><a id="acc30d069075ed6dc5b7aec248546ba99" name="acc30d069075ed6dc5b7aec248546ba99"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getConstraintGroupCount</b> () const</td></tr>
<tr class="memdesc:acc30d069075ed6dc5b7aec248546ba99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of constrained groups. <br /></td></tr>
<tr class="separator:acc30d069075ed6dc5b7aec248546ba99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07161e431576f4391dd8ab9ebe32c973" id="r_a07161e431576f4391dd8ab9ebe32c973"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07161e431576f4391dd8ab9ebe32c973">getConstraintGroupAtoms</a> (int index) const</td></tr>
<tr class="memdesc:a07161e431576f4391dd8ab9ebe32c973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the atoms of a single constraint group.  <br /></td></tr>
<tr class="separator:a07161e431576f4391dd8ab9ebe32c973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb30a39b83b71a62972f5ae772291a9" id="r_a6cb30a39b83b71a62972f5ae772291a9"><td class="memItemLeft" align="right" valign="top"><a id="a6cb30a39b83b71a62972f5ae772291a9" name="a6cb30a39b83b71a62972f5ae772291a9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getConstraintGroupTotalSize</b> () const</td></tr>
<tr class="memdesc:a6cb30a39b83b71a62972f5ae772291a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total size of the constrained group atoms list. <br /></td></tr>
<tr class="separator:a6cb30a39b83b71a62972f5ae772291a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd7957bcf0338225b7cfe23134d0875" id="r_a6dd7957bcf0338225b7cfe23134d0875"><td class="memItemLeft" align="right" valign="top"><a id="a6dd7957bcf0338225b7cfe23134d0875" name="a6dd7957bcf0338225b7cfe23134d0875"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getNonrigidParticleCount</b> () const</td></tr>
<tr class="memdesc:a6dd7957bcf0338225b7cfe23134d0875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of non-rigid particles in the system. <br /></td></tr>
<tr class="separator:a6dd7957bcf0338225b7cfe23134d0875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94a576bec0f058a5f3c6cf4c5fdc00f" id="r_ad94a576bec0f058a5f3c6cf4c5fdc00f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad94a576bec0f058a5f3c6cf4c5fdc00f">getAtomExclusions</a> (int index) const</td></tr>
<tr class="memdesc:ad94a576bec0f058a5f3c6cf4c5fdc00f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the exclusion list for a particular atom. This will concatenate 1:1, 1:2, 1:3, and 1:4 exclusions, without regard to which is which. To get a specific type of exclusion, use one of the getNonbondedXXExclusions() functions. All functions of this sort will return a complete list such that if exclusions for all atoms are considered in sequence, all exclusions will be double-counted.  <br /></td></tr>
<tr class="separator:ad94a576bec0f058a5f3c6cf4c5fdc00f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81a68312c2ceb0e7294dcced4db6681" id="r_aa81a68312c2ceb0e7294dcced4db6681"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa81a68312c2ceb0e7294dcced4db6681">getNonbonded11Exclusions</a> (int index) const</td></tr>
<tr class="memdesc:aa81a68312c2ceb0e7294dcced4db6681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the 1:1 exclusions for a particular atom. This list will only be populated if the atom is a virtual site or has virtual sites that claim it as their parent.  <br /></td></tr>
<tr class="separator:aa81a68312c2ceb0e7294dcced4db6681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad99755bedf613914a6a21f575cab04f7" id="r_ad99755bedf613914a6a21f575cab04f7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad99755bedf613914a6a21f575cab04f7">getNonbonded12Exclusions</a> (int index) const</td></tr>
<tr class="memdesc:ad99755bedf613914a6a21f575cab04f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all 1:2 exclusions for a particular atom.  <br /></td></tr>
<tr class="separator:ad99755bedf613914a6a21f575cab04f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7433f48b407a8f7874d1edb9619f4bc5" id="r_a7433f48b407a8f7874d1edb9619f4bc5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7433f48b407a8f7874d1edb9619f4bc5">getNonbonded13Exclusions</a> (int index) const</td></tr>
<tr class="memdesc:a7433f48b407a8f7874d1edb9619f4bc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all 1:3 exclusions for a particular atom.  <br /></td></tr>
<tr class="separator:a7433f48b407a8f7874d1edb9619f4bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36711bd0ac95814aa9a4ae7aa0bae0cc" id="r_a36711bd0ac95814aa9a4ae7aa0bae0cc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36711bd0ac95814aa9a4ae7aa0bae0cc">getNonbonded14Exclusions</a> (int index) const</td></tr>
<tr class="memdesc:a36711bd0ac95814aa9a4ae7aa0bae0cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all 1:4 exclusions for a particular atom.  <br /></td></tr>
<tr class="separator:a36711bd0ac95814aa9a4ae7aa0bae0cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5af3281f7f1bd2c1216c1c2a0f419d" id="r_a4d5af3281f7f1bd2c1216c1c2a0f419d"><td class="memTemplParams" colspan="2"><a id="a4d5af3281f7f1bd2c1216c1c2a0f419d" name="a4d5af3281f7f1bd2c1216c1c2a0f419d"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:a4d5af3281f7f1bd2c1216c1c2a0f419d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getChargeParameter</b> (int index) const</td></tr>
<tr class="memdesc:a4d5af3281f7f1bd2c1216c1c2a0f419d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the charge parameter for a specific atom. The quantity is derived from tables at the specified level of precision (float or double), and equals the value obtained from getPartialCharge&lt;T&gt;(index), although that function reaches into a separate array with a great deal of redundant information. <br /></td></tr>
<tr class="separator:a4d5af3281f7f1bd2c1216c1c2a0f419d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4114266696778ab98af4f298bb47a086" id="r_a4114266696778ab98af4f298bb47a086"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structstormm_1_1data__types_1_1char4.html">char4</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4114266696778ab98af4f298bb47a086">matchOverflowAtomName</a> (const std::string &amp;query) const</td></tr>
<tr class="memdesc:a4114266696778ab98af4f298bb47a086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match a long atom name and return its key in the standard list of <a class="el" href="structstormm_1_1char4.html">char4</a> atom names.  <br /></td></tr>
<tr class="separator:a4114266696778ab98af4f298bb47a086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d3eb5d07bb973bb4a4ae8d32fc60168" id="r_a3d3eb5d07bb973bb4a4ae8d32fc60168"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structstormm_1_1data__types_1_1char4.html">char4</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d3eb5d07bb973bb4a4ae8d32fc60168">matchOverflowAtomType</a> (const std::string &amp;query) const</td></tr>
<tr class="memdesc:a3d3eb5d07bb973bb4a4ae8d32fc60168"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match a long atom type and return its key in the standard list of <a class="el" href="structstormm_1_1char4.html">char4</a> atom types.  <br /></td></tr>
<tr class="separator:a3d3eb5d07bb973bb4a4ae8d32fc60168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8efc794c1bd9e72033fb818cca832777" id="r_a8efc794c1bd9e72033fb818cca832777"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structstormm_1_1data__types_1_1char4.html">char4</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8efc794c1bd9e72033fb818cca832777">matchOverflowResidueName</a> (const std::string &amp;query) const</td></tr>
<tr class="memdesc:a8efc794c1bd9e72033fb818cca832777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match a long residue name and return its key among the standard <a class="el" href="structstormm_1_1char4.html">char4</a> residue names.  <br /></td></tr>
<tr class="separator:a8efc794c1bd9e72033fb818cca832777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa567a3f7eb34c9ca7aac833543a47ab9" id="r_aa567a3f7eb34c9ca7aac833543a47ab9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstormm_1_1topology_1_1ValenceKit.html">ValenceKit</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa567a3f7eb34c9ca7aac833543a47ab9">getDoublePrecisionValenceKit</a> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:aa567a3f7eb34c9ca7aac833543a47ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an abstract for calculating valence terms in double precision.  <br /></td></tr>
<tr class="separator:aa567a3f7eb34c9ca7aac833543a47ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20463b2e0ffa255d5af9179ac87a0d1a" id="r_a20463b2e0ffa255d5af9179ac87a0d1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstormm_1_1topology_1_1ValenceKit.html">ValenceKit</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20463b2e0ffa255d5af9179ac87a0d1a">getSinglePrecisionValenceKit</a> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:a20463b2e0ffa255d5af9179ac87a0d1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a single-precision abstract for calculating valence terms.  <br /></td></tr>
<tr class="separator:a20463b2e0ffa255d5af9179ac87a0d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35eb9cb768abd8f8b0404fb300eb09c3" id="r_a35eb9cb768abd8f8b0404fb300eb09c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstormm_1_1topology_1_1NonbondedKit.html">NonbondedKit</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35eb9cb768abd8f8b0404fb300eb09c3">getDoublePrecisionNonbondedKit</a> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:a35eb9cb768abd8f8b0404fb300eb09c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a double-precision abstract for calculating non-bonded energy and forces.  <br /></td></tr>
<tr class="separator:a35eb9cb768abd8f8b0404fb300eb09c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a863a32007974e29a65ee21c1ee10e8f3" id="r_a863a32007974e29a65ee21c1ee10e8f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstormm_1_1topology_1_1NonbondedKit.html">NonbondedKit</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a863a32007974e29a65ee21c1ee10e8f3">getSinglePrecisionNonbondedKit</a> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:a863a32007974e29a65ee21c1ee10e8f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a single-precision abstract for calculating non-bonded energy and forces.  <br /></td></tr>
<tr class="separator:a863a32007974e29a65ee21c1ee10e8f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e86c41c00ee23573dcf60d84c525dbe" id="r_a8e86c41c00ee23573dcf60d84c525dbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstormm_1_1topology_1_1ImplicitSolventKit.html">ImplicitSolventKit</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e86c41c00ee23573dcf60d84c525dbe">getDoublePrecisionImplicitSolventKit</a> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:a8e86c41c00ee23573dcf60d84c525dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a double-precision abstract for calculating implicit solvent energy and forces.  <br /></td></tr>
<tr class="separator:a8e86c41c00ee23573dcf60d84c525dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0d86bad4600871f31a8dd98fc5efbd" id="r_afd0d86bad4600871f31a8dd98fc5efbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstormm_1_1topology_1_1ImplicitSolventKit.html">ImplicitSolventKit</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd0d86bad4600871f31a8dd98fc5efbd">getSinglePrecisionImplicitSolventKit</a> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:afd0d86bad4600871f31a8dd98fc5efbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a single-precision abstract for calculating implicit solvent energy and forces.  <br /></td></tr>
<tr class="separator:afd0d86bad4600871f31a8dd98fc5efbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d2fea73563130f81183ecd1cf35aac" id="r_aa9d2fea73563130f81183ecd1cf35aac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstormm_1_1topology_1_1ChemicalDetailsKit.html">ChemicalDetailsKit</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9d2fea73563130f81183ecd1cf35aac">getChemicalDetailsKit</a> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:aa9d2fea73563130f81183ecd1cf35aac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an abstract of the chemical details of the system, such as atom name and type or residue names and limits.  <br /></td></tr>
<tr class="separator:aa9d2fea73563130f81183ecd1cf35aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5cdc60cd4daf304e245603348b45ff2" id="r_af5cdc60cd4daf304e245603348b45ff2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstormm_1_1topology_1_1VirtualSiteKit.html">VirtualSiteKit</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5cdc60cd4daf304e245603348b45ff2">getDoublePrecisionVirtualSiteKit</a> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:af5cdc60cd4daf304e245603348b45ff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a double-precision abstract for placing virtual sites and transmitting their forces to frame atoms with mass.  <br /></td></tr>
<tr class="separator:af5cdc60cd4daf304e245603348b45ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a629f5621656898ee9a0a82d460591890" id="r_a629f5621656898ee9a0a82d460591890"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstormm_1_1topology_1_1VirtualSiteKit.html">VirtualSiteKit</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a629f5621656898ee9a0a82d460591890">getSinglePrecisionVirtualSiteKit</a> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:a629f5621656898ee9a0a82d460591890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a single-precision abstract for placing virtual sites and transmitting their forces to frame atoms with mass.  <br /></td></tr>
<tr class="separator:a629f5621656898ee9a0a82d460591890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328e861a4c4b2e1beb67ec05abe4fe0f" id="r_a328e861a4c4b2e1beb67ec05abe4fe0f"><td class="memItemLeft" align="right" valign="top">ConstraintKit&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a328e861a4c4b2e1beb67ec05abe4fe0f">getDoublePrecisionConstraintKit</a> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:a328e861a4c4b2e1beb67ec05abe4fe0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an abstract for managing constraints based on double-precision parameters.  <br /></td></tr>
<tr class="separator:a328e861a4c4b2e1beb67ec05abe4fe0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eca7aa889462af414093806b22b4a7f" id="r_a4eca7aa889462af414093806b22b4a7f"><td class="memItemLeft" align="right" valign="top">ConstraintKit&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4eca7aa889462af414093806b22b4a7f">getSinglePrecisionConstraintKit</a> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:a4eca7aa889462af414093806b22b4a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an abstract for managing constraints based on single-precision parameters. While the overall implementation for constraints cannot be implemented entirely in single precision, having the underlying parameters in this form is not, in principle, a drvier of energy drift. It will simply set the system into a slightly different geometry, which is probably still closer to the double-precision result than many cycles of SHAKE or RATTLE would get it anyway.  <br /></td></tr>
<tr class="separator:a4eca7aa889462af414093806b22b4a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29a8a6a22772e4006c2e895701fda33f" id="r_a29a8a6a22772e4006c2e895701fda33f"><td class="memItemLeft" align="right" valign="top"><a id="a29a8a6a22772e4006c2e895701fda33f" name="a29a8a6a22772e4006c2e895701fda33f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setSource</b> (const std::string &amp;new_source)</td></tr>
<tr class="memdesc:a29a8a6a22772e4006c2e895701fda33f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the source file for the topology. Primary use is to impart a destination file for a topology to be written to disk, but can also be used to "disguise" one topology from another even if both are from the same original file. <br /></td></tr>
<tr class="separator:a29a8a6a22772e4006c2e895701fda33f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae7eb635d229f25b3e6a41bfe5a3c0b" id="r_a5ae7eb635d229f25b3e6a41bfe5a3c0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ae7eb635d229f25b3e6a41bfe5a3c0b">setImplicitSolventModel</a> (ImplicitSolventModel igb_in, double dielectric_in=80.0, double saltcon_in=0.0, AtomicRadiusSet radii_set=AtomicRadiusSet::NONE, ExceptionResponse policy=ExceptionResponse::WARN)</td></tr>
<tr class="memdesc:a5ae7eb635d229f25b3e6a41bfe5a3c0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the implicit solvent model. This will leverage a lot of hard-coded constants to fill out some allocated but otherwise blank arrays and impart one particular Generalized Born or other implicit solvent method.  <br /></td></tr>
<tr class="separator:a5ae7eb635d229f25b3e6a41bfe5a3c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb8771c09584c633309df9d11b23053" id="r_aadb8771c09584c633309df9d11b23053"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aadb8771c09584c633309df9d11b23053">printToFile</a> (const std::string &amp;output_file={}, TopologyKind output_style=TopologyKind::AMBER, PrintSituation expectation=PrintSituation::OPEN_NEW, ExceptionResponse pr_policy=ExceptionResponse::DIE) const</td></tr>
<tr class="memdesc:aadb8771c09584c633309df9d11b23053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out a topology in the specified format.  <br /></td></tr>
<tr class="separator:aadb8771c09584c633309df9d11b23053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b08bef83d7f343b9c25a2939a3935b" id="r_a65b08bef83d7f343b9c25a2939a3935b"><td class="memItemLeft" align="right" valign="top"><a id="a65b08bef83d7f343b9c25a2939a3935b" name="a65b08bef83d7f343b9c25a2939a3935b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>printAmberFormat</b> (const std::string &amp;output_file={}, PrintSituation expectation=PrintSituation::OPEN_NEW, ExceptionResponse pr_policy=ExceptionResponse::DIE) const</td></tr>
<tr class="memdesc:a65b08bef83d7f343b9c25a2939a3935b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the contents of the topology in the AMBER file format. Descriptions of input parameters follow from <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html#aadb8771c09584c633309df9d11b23053" title="Print out a topology in the specified format.">printToFile()</a>, above. <br /></td></tr>
<tr class="separator:a65b08bef83d7f343b9c25a2939a3935b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad6a8569e3b30e01fd26e7f6177ec9303" id="r_ad6a8569e3b30e01fd26e7f6177ec9303"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6a8569e3b30e01fd26e7f6177ec9303">AtomGraph</a> (const std::string &amp;file_name, ExceptionResponse policy=ExceptionResponse::WARN, TopologyKind engine_format=TopologyKind::AMBER)</td></tr>
<tr class="memdesc:ad6a8569e3b30e01fd26e7f6177ec9303"><td class="mdescLeft">&#160;</td><td class="mdescRight">The general-purpose constructor for file-based topology creation.  <br /></td></tr>
<tr class="separator:ad6a8569e3b30e01fd26e7f6177ec9303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32dbf60bed616cf4688ca08abc36dde2" id="r_a32dbf60bed616cf4688ca08abc36dde2"><td class="memItemLeft" align="right" valign="top"><a id="a32dbf60bed616cf4688ca08abc36dde2" name="a32dbf60bed616cf4688ca08abc36dde2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AtomGraph</b> (const std::string &amp;file_name, ExceptionResponse policy, TopologyKind engine_format, double coulomb_constant_in, double default_elec14_screening, double default_vdw14_screening, double charge_rounding_tol, double charge_discretization, ApplyConstraints use_bond_constraints_in=ApplyConstraints::NO, ApplyConstraints use_settle_in=ApplyConstraints::NO)</td></tr>
<tr class="separator:a32dbf60bed616cf4688ca08abc36dde2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c1205bdae60227ed6cc1e1390ea82d" id="r_aa6c1205bdae60227ed6cc1e1390ea82d"><td class="memItemLeft" align="right" valign="top"><a id="aa6c1205bdae60227ed6cc1e1390ea82d" name="aa6c1205bdae60227ed6cc1e1390ea82d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AtomGraph</b> (const std::vector&lt; <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> * &gt; &amp;agv, const std::vector&lt; int &gt; &amp;counts, MoleculeOrdering arrangement=MoleculeOrdering::REORDER_ALL, ExceptionResponse policy=ExceptionResponse::DIE)</td></tr>
<tr class="separator:aa6c1205bdae60227ed6cc1e1390ea82d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9132d019e51aeeacea939cb651e60383" id="r_a9132d019e51aeeacea939cb651e60383"><td class="memItemLeft" align="right" valign="top"><a id="a9132d019e51aeeacea939cb651e60383" name="a9132d019e51aeeacea939cb651e60383"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AtomGraph</b> (const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;ag_a, int n_a, const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;ag_b, int n_b, MoleculeOrdering arrangement=MoleculeOrdering::REORDER_ALL, ExceptionResponse policy=ExceptionResponse::DIE)</td></tr>
<tr class="separator:a9132d019e51aeeacea939cb651e60383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7c8408b73753610ec4537d5447a6e0" id="r_a3c7c8408b73753610ec4537d5447a6e0"><td class="memItemLeft" align="right" valign="top"><a id="a3c7c8408b73753610ec4537d5447a6e0" name="a3c7c8408b73753610ec4537d5447a6e0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AtomGraph</b> (const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;ag_a, const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;ag_b, int n_b, MoleculeOrdering arrangement=MoleculeOrdering::REORDER_ALL, ExceptionResponse policy=ExceptionResponse::DIE)</td></tr>
<tr class="separator:a3c7c8408b73753610ec4537d5447a6e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaed92a72351b19c790b5988e08d89bc1" id="r_aaed92a72351b19c790b5988e08d89bc1"><td class="memItemLeft" align="right" valign="top"><a id="aaed92a72351b19c790b5988e08d89bc1" name="aaed92a72351b19c790b5988e08d89bc1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AtomGraph</b> (const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;ag_a, const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;ag_b, MoleculeOrdering arrangement=MoleculeOrdering::REORDER_ALL, ExceptionResponse policy=ExceptionResponse::DIE)</td></tr>
<tr class="separator:aaed92a72351b19c790b5988e08d89bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f33d3c239b3eb1c049332881473a29" id="r_af0f33d3c239b3eb1c049332881473a29"><td class="memItemLeft" align="right" valign="top"><a id="af0f33d3c239b3eb1c049332881473a29" name="af0f33d3c239b3eb1c049332881473a29"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AtomGraph</b> (const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;original, const std::vector&lt; int &gt; &amp;atom_subset, ExceptionResponse policy=ExceptionResponse::DIE, double charge_rounding_tol=default_charge_rounding_tol, double charge_discretization=default_charge_precision_inc, ApplyConstraints use_bond_constraints_in=ApplyConstraints::NO, ApplyConstraints use_settle_in=ApplyConstraints::NO)</td></tr>
<tr class="separator:af0f33d3c239b3eb1c049332881473a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba86a7f652f2efd38d2767b84c793ef" id="r_a3ba86a7f652f2efd38d2767b84c793ef"><td class="memItemLeft" align="right" valign="top"><a id="a3ba86a7f652f2efd38d2767b84c793ef" name="a3ba86a7f652f2efd38d2767b84c793ef"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AtomGraph</b> (const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;original, const std::vector&lt; bool &gt; &amp;mask, ExceptionResponse policy=ExceptionResponse::DIE, double charge_rounding_tol=default_charge_rounding_tol, double charge_discretization=default_charge_precision_inc, ApplyConstraints use_bond_constraints_in=ApplyConstraints::NO, ApplyConstraints use_settle_in=ApplyConstraints::NO)</td></tr>
<tr class="separator:a3ba86a7f652f2efd38d2767b84c793ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a253d079c4682cb91aca88753e70c83d1" id="r_a253d079c4682cb91aca88753e70c83d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a253d079c4682cb91aca88753e70c83d1">getDescriptor</a> (TopologyDescriptor choice) const</td></tr>
<tr class="memdesc:a253d079c4682cb91aca88753e70c83d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a descriptor from within the array of topology descriptors. If this topology were read from an Amber-format file, all descriptors are taken from the preamble in its first ~15 lines.  <br /></td></tr>
<tr class="separator:a253d079c4682cb91aca88753e70c83d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec616d9238eed8ac6dd049dda570ef60" id="r_aec616d9238eed8ac6dd049dda570ef60"><td class="memItemLeft" align="right" valign="top"><a id="aec616d9238eed8ac6dd049dda570ef60" name="aec616d9238eed8ac6dd049dda570ef60"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getDescriptor</b> (SanderDescriptor choice) const</td></tr>
<tr class="separator:aec616d9238eed8ac6dd049dda570ef60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:adfbdbf5fcd6ec34e2a0bcec0f551aed2" id="r_adfbdbf5fcd6ec34e2a0bcec0f551aed2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfbdbf5fcd6ec34e2a0bcec0f551aed2">getResidueLimits</a> () const</td></tr>
<tr class="memdesc:adfbdbf5fcd6ec34e2a0bcec0f551aed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get residue limits for the beginning and ends of up to N residues.  <br /></td></tr>
<tr class="separator:adfbdbf5fcd6ec34e2a0bcec0f551aed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a353ed61d9a5364deef63ab7e49135761" id="r_a353ed61d9a5364deef63ab7e49135761"><td class="memItemLeft" align="right" valign="top"><a id="a353ed61d9a5364deef63ab7e49135761" name="a353ed61d9a5364deef63ab7e49135761"></a>
<a class="el" href="structstormm_1_1data__types_1_1int2.html">int2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getResidueLimits</b> (int index) const</td></tr>
<tr class="separator:a353ed61d9a5364deef63ab7e49135761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:abb303475fe08735cc4f89dc7d62d2fa2" id="r_abb303475fe08735cc4f89dc7d62d2fa2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb303475fe08735cc4f89dc7d62d2fa2">getResidueIndex</a> () const</td></tr>
<tr class="memdesc:abb303475fe08735cc4f89dc7d62d2fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index (topology index, not natural / structure-informed residue number) of a particular residue.  <br /></td></tr>
<tr class="separator:abb303475fe08735cc4f89dc7d62d2fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8cf5771f0b996a30e2aa23315bc861c" id="r_ac8cf5771f0b996a30e2aa23315bc861c"><td class="memItemLeft" align="right" valign="top"><a id="ac8cf5771f0b996a30e2aa23315bc861c" name="ac8cf5771f0b996a30e2aa23315bc861c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getResidueIndex</b> (int atom_index) const</td></tr>
<tr class="separator:ac8cf5771f0b996a30e2aa23315bc861c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9beef3b9fa5765e7bf169b0170ec1e18" id="r_a9beef3b9fa5765e7bf169b0170ec1e18"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9beef3b9fa5765e7bf169b0170ec1e18">getStructuralAtomNumber</a> () const</td></tr>
<tr class="memdesc:a9beef3b9fa5765e7bf169b0170ec1e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the (arbitrarily defined) atom numbers for atoms in the system. For example, a PDB file could ahve its own atom numbering scheme. This provides a way to transcribe that into the <a class="el" href="classstormm_1_1energy_1_1AtomGraph.html" title="A struct to hold information relating to an Amber topology. This struct&#39;s member functions are limite...">AtomGraph</a> object.  <br /></td></tr>
<tr class="separator:a9beef3b9fa5765e7bf169b0170ec1e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d141cb37c5e86ed8666484bdf17f323" id="r_a8d141cb37c5e86ed8666484bdf17f323"><td class="memItemLeft" align="right" valign="top"><a id="a8d141cb37c5e86ed8666484bdf17f323" name="a8d141cb37c5e86ed8666484bdf17f323"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getStructuralAtomNumber</b> (int low_index, int high_index) const</td></tr>
<tr class="separator:a8d141cb37c5e86ed8666484bdf17f323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb213c578a5f2696d6cbafda4026eff3" id="r_afb213c578a5f2696d6cbafda4026eff3"><td class="memItemLeft" align="right" valign="top"><a id="afb213c578a5f2696d6cbafda4026eff3" name="afb213c578a5f2696d6cbafda4026eff3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getStructuralAtomNumber</b> (int index) const</td></tr>
<tr class="separator:afb213c578a5f2696d6cbafda4026eff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a53d58d577eb9451ef46182b6d85ce4b0" id="r_a53d58d577eb9451ef46182b6d85ce4b0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53d58d577eb9451ef46182b6d85ce4b0">getResidueNumber</a> () const</td></tr>
<tr class="memdesc:a53d58d577eb9451ef46182b6d85ce4b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the residue numbers for atoms in the system.  <br /></td></tr>
<tr class="separator:a53d58d577eb9451ef46182b6d85ce4b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb5cd518a22b771e3db1653946e99ff" id="r_a8eb5cd518a22b771e3db1653946e99ff"><td class="memItemLeft" align="right" valign="top"><a id="a8eb5cd518a22b771e3db1653946e99ff" name="a8eb5cd518a22b771e3db1653946e99ff"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getResidueNumber</b> (int low_index, int high_index) const</td></tr>
<tr class="separator:a8eb5cd518a22b771e3db1653946e99ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8760afff924ad37f3d7d65de2bfa8e06" id="r_a8760afff924ad37f3d7d65de2bfa8e06"><td class="memItemLeft" align="right" valign="top"><a id="a8760afff924ad37f3d7d65de2bfa8e06" name="a8760afff924ad37f3d7d65de2bfa8e06"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getResidueNumber</b> (int index) const</td></tr>
<tr class="separator:a8760afff924ad37f3d7d65de2bfa8e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad67c3ed88c9d946d575b31cd16aba8c5" id="r_ad67c3ed88c9d946d575b31cd16aba8c5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad67c3ed88c9d946d575b31cd16aba8c5">getMoleculeLimits</a> () const</td></tr>
<tr class="memdesc:ad67c3ed88c9d946d575b31cd16aba8c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the molecule limits, indices into molecule_contents, for every molecule in the system. This allows that molecules not be contiguous in the topology atom indexing, but will be recoverable by molecule_contents.  <br /></td></tr>
<tr class="separator:ad67c3ed88c9d946d575b31cd16aba8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed41e362450442ea3565e8ee9eb8281" id="r_a0ed41e362450442ea3565e8ee9eb8281"><td class="memItemLeft" align="right" valign="top"><a id="a0ed41e362450442ea3565e8ee9eb8281" name="a0ed41e362450442ea3565e8ee9eb8281"></a>
<a class="el" href="structstormm_1_1data__types_1_1int2.html">int2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getMoleculeLimits</b> (int index) const</td></tr>
<tr class="separator:a0ed41e362450442ea3565e8ee9eb8281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a831ecd2ee7a84a449b373abc679a5000" id="r_a831ecd2ee7a84a449b373abc679a5000"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a831ecd2ee7a84a449b373abc679a5000">getAtomicNumber</a> () const</td></tr>
<tr class="memdesc:a831ecd2ee7a84a449b373abc679a5000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the atomic numbers for atoms in the system.  <br /></td></tr>
<tr class="separator:a831ecd2ee7a84a449b373abc679a5000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae510c9bf5ec42fa965151bddb05d8a5f" id="r_ae510c9bf5ec42fa965151bddb05d8a5f"><td class="memItemLeft" align="right" valign="top"><a id="ae510c9bf5ec42fa965151bddb05d8a5f" name="ae510c9bf5ec42fa965151bddb05d8a5f"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getAtomicNumber</b> (int low_index, int high_index) const</td></tr>
<tr class="separator:ae510c9bf5ec42fa965151bddb05d8a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492f720896f37a3fa559a7deaef6dd87" id="r_a492f720896f37a3fa559a7deaef6dd87"><td class="memItemLeft" align="right" valign="top"><a id="a492f720896f37a3fa559a7deaef6dd87" name="a492f720896f37a3fa559a7deaef6dd87"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getAtomicNumber</b> (int index) const</td></tr>
<tr class="separator:a492f720896f37a3fa559a7deaef6dd87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aedc47d1e225809c371d36b74d679eaa6" id="r_aedc47d1e225809c371d36b74d679eaa6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aedc47d1e225809c371d36b74d679eaa6">getAtomMobility</a> () const</td></tr>
<tr class="memdesc:aedc47d1e225809c371d36b74d679eaa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the mobile atom mask for the system, as a boolean vector translated from the bitmask stored internally.  <br /></td></tr>
<tr class="separator:aedc47d1e225809c371d36b74d679eaa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf11ba29a2d6573dc20ab27aecf12121" id="r_acf11ba29a2d6573dc20ab27aecf12121"><td class="memItemLeft" align="right" valign="top"><a id="acf11ba29a2d6573dc20ab27aecf12121" name="acf11ba29a2d6573dc20ab27aecf12121"></a>
std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getAtomMobility</b> (int low_index, int high_index) const</td></tr>
<tr class="separator:acf11ba29a2d6573dc20ab27aecf12121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab9538c9566bb9b889ff1ebd6c9e508d" id="r_aab9538c9566bb9b889ff1ebd6c9e508d"><td class="memItemLeft" align="right" valign="top"><a id="aab9538c9566bb9b889ff1ebd6c9e508d" name="aab9538c9566bb9b889ff1ebd6c9e508d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>getAtomMobility</b> (int index) const</td></tr>
<tr class="separator:aab9538c9566bb9b889ff1ebd6c9e508d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4a2aef8d3e95c757dfce25264e6f5e8f" id="r_a4a2aef8d3e95c757dfce25264e6f5e8f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a2aef8d3e95c757dfce25264e6f5e8f">getAtomMobilityMask</a> () const</td></tr>
<tr class="memdesc:a4a2aef8d3e95c757dfce25264e6f5e8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the raw mobility bitmask over a particular range.  <br /></td></tr>
<tr class="separator:a4a2aef8d3e95c757dfce25264e6f5e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c4578855a94b0ea836a9bf16b1a70b" id="r_a35c4578855a94b0ea836a9bf16b1a70b"><td class="memItemLeft" align="right" valign="top"><a id="a35c4578855a94b0ea836a9bf16b1a70b" name="a35c4578855a94b0ea836a9bf16b1a70b"></a>
std::vector&lt; uint &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getAtomMobilityMask</b> (int low_index, int high_index) const</td></tr>
<tr class="separator:a35c4578855a94b0ea836a9bf16b1a70b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a017fad73eb157106ac99b8ab99fd1986" id="r_a017fad73eb157106ac99b8ab99fd1986"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a017fad73eb157106ac99b8ab99fd1986">modifyAtomMobility</a> (MobilitySetting movement)</td></tr>
<tr class="memdesc:a017fad73eb157106ac99b8ab99fd1986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change an atom's mobility in the topology.  <br /></td></tr>
<tr class="separator:a017fad73eb157106ac99b8ab99fd1986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf3c8221f26bdef52f64f9674a3154f" id="r_adbf3c8221f26bdef52f64f9674a3154f"><td class="memItemLeft" align="right" valign="top"><a id="adbf3c8221f26bdef52f64f9674a3154f" name="adbf3c8221f26bdef52f64f9674a3154f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>modifyAtomMobility</b> (int low_index, int high_index, MobilitySetting movement)</td></tr>
<tr class="separator:adbf3c8221f26bdef52f64f9674a3154f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b22e7e707a41193ef6e7be47671f1f" id="r_a24b22e7e707a41193ef6e7be47671f1f"><td class="memItemLeft" align="right" valign="top"><a id="a24b22e7e707a41193ef6e7be47671f1f" name="a24b22e7e707a41193ef6e7be47671f1f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>modifyAtomMobility</b> (int index, MobilitySetting movement)</td></tr>
<tr class="separator:a24b22e7e707a41193ef6e7be47671f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d915f6279e4f1f1000efdd89a0dbe4c" id="r_a1d915f6279e4f1f1000efdd89a0dbe4c"><td class="memItemLeft" align="right" valign="top"><a id="a1d915f6279e4f1f1000efdd89a0dbe4c" name="a1d915f6279e4f1f1000efdd89a0dbe4c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>modifyAtomMobility</b> (const std::vector&lt; int &gt; &amp;mask, MobilitySetting movement)</td></tr>
<tr class="separator:a1d915f6279e4f1f1000efdd89a0dbe4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aaff07b8b34e8fe466a65b5b96e5b826c" id="r_aaff07b8b34e8fe466a65b5b96e5b826c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaff07b8b34e8fe466a65b5b96e5b826c">getMoleculeMembership</a> () const</td></tr>
<tr class="memdesc:aaff07b8b34e8fe466a65b5b96e5b826c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get molecule membership for atoms within the system.  <br /></td></tr>
<tr class="separator:aaff07b8b34e8fe466a65b5b96e5b826c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93fe78d8412050978199c1ec0a938629" id="r_a93fe78d8412050978199c1ec0a938629"><td class="memItemLeft" align="right" valign="top"><a id="a93fe78d8412050978199c1ec0a938629" name="a93fe78d8412050978199c1ec0a938629"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getMoleculeMembership</b> (int low_index, int high_index) const</td></tr>
<tr class="separator:a93fe78d8412050978199c1ec0a938629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19518b253dd2166d5705312025e0240b" id="r_a19518b253dd2166d5705312025e0240b"><td class="memItemLeft" align="right" valign="top"><a id="a19518b253dd2166d5705312025e0240b" name="a19518b253dd2166d5705312025e0240b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getMoleculeMembership</b> (int index) const</td></tr>
<tr class="separator:a19518b253dd2166d5705312025e0240b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:acaaf3e861e0585de03e3290943f82b59" id="r_acaaf3e861e0585de03e3290943f82b59"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acaaf3e861e0585de03e3290943f82b59">getMoleculeContents</a> () const</td></tr>
<tr class="memdesc:acaaf3e861e0585de03e3290943f82b59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the contents of a one or more molecules in the system.  <br /></td></tr>
<tr class="separator:acaaf3e861e0585de03e3290943f82b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b46edf7876c195a32f9a16aa2abfbe" id="r_aa2b46edf7876c195a32f9a16aa2abfbe"><td class="memItemLeft" align="right" valign="top"><a id="aa2b46edf7876c195a32f9a16aa2abfbe" name="aa2b46edf7876c195a32f9a16aa2abfbe"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getMoleculeContents</b> (int index) const</td></tr>
<tr class="separator:aa2b46edf7876c195a32f9a16aa2abfbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad31ff4865066ec358d70f3bbc4fcffb1" id="r_ad31ff4865066ec358d70f3bbc4fcffb1"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ad31ff4865066ec358d70f3bbc4fcffb1"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad31ff4865066ec358d70f3bbc4fcffb1">getPartialCharge</a> () const</td></tr>
<tr class="memdesc:ad31ff4865066ec358d70f3bbc4fcffb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the atomic partial charges of atoms in the system.  <br /></td></tr>
<tr class="separator:ad31ff4865066ec358d70f3bbc4fcffb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760085712e752947d8ec3a3df7bbb517" id="r_a760085712e752947d8ec3a3df7bbb517"><td class="memTemplParams" colspan="2"><a id="a760085712e752947d8ec3a3df7bbb517" name="a760085712e752947d8ec3a3df7bbb517"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:a760085712e752947d8ec3a3df7bbb517"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getPartialCharge</b> (int low_index, int high_index) const</td></tr>
<tr class="separator:a760085712e752947d8ec3a3df7bbb517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a980fb535ac7550d9521cc00ebadf2c4d" id="r_a980fb535ac7550d9521cc00ebadf2c4d"><td class="memTemplParams" colspan="2"><a id="a980fb535ac7550d9521cc00ebadf2c4d" name="a980fb535ac7550d9521cc00ebadf2c4d"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:a980fb535ac7550d9521cc00ebadf2c4d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getPartialCharge</b> (int index) const</td></tr>
<tr class="separator:a980fb535ac7550d9521cc00ebadf2c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab19593d08d26638c57a65d738178b471" id="r_ab19593d08d26638c57a65d738178b471"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ab19593d08d26638c57a65d738178b471"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab19593d08d26638c57a65d738178b471">getAtomicMass</a> (MassForm rep=MassForm::ORDINARY) const</td></tr>
<tr class="memdesc:ab19593d08d26638c57a65d738178b471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the masses of atoms in the system. The developer may also choose to take the pre-computed inverse masses (this can be useful when dealing with extra points, as inverses of zero-mass particles must also be set to zero by a conditional statement).  <br /></td></tr>
<tr class="separator:ab19593d08d26638c57a65d738178b471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d56ddd1bcaab51dddc0482041ee63b7" id="r_a0d56ddd1bcaab51dddc0482041ee63b7"><td class="memTemplParams" colspan="2"><a id="a0d56ddd1bcaab51dddc0482041ee63b7" name="a0d56ddd1bcaab51dddc0482041ee63b7"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:a0d56ddd1bcaab51dddc0482041ee63b7"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getAtomicMass</b> (int low_index, int high_index, MassForm rep=MassForm::ORDINARY) const</td></tr>
<tr class="separator:a0d56ddd1bcaab51dddc0482041ee63b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38853b6f56a4ccfea8f0aa5687e0ff98" id="r_a38853b6f56a4ccfea8f0aa5687e0ff98"><td class="memTemplParams" colspan="2"><a id="a38853b6f56a4ccfea8f0aa5687e0ff98" name="a38853b6f56a4ccfea8f0aa5687e0ff98"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:a38853b6f56a4ccfea8f0aa5687e0ff98"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getAtomicMass</b> (int index, MassForm rep=MassForm::ORDINARY) const</td></tr>
<tr class="separator:a38853b6f56a4ccfea8f0aa5687e0ff98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4b74bf6e9b75165108ec785cbd650c64" id="r_a4b74bf6e9b75165108ec785cbd650c64"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; <a class="el" href="structstormm_1_1data__types_1_1char4.html">char4</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b74bf6e9b75165108ec785cbd650c64">getAtomName</a> () const</td></tr>
<tr class="memdesc:a4b74bf6e9b75165108ec785cbd650c64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the names of atoms in the system.  <br /></td></tr>
<tr class="separator:a4b74bf6e9b75165108ec785cbd650c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4907d03e1a5f08543867ed760106fdc0" id="r_a4907d03e1a5f08543867ed760106fdc0"><td class="memItemLeft" align="right" valign="top"><a id="a4907d03e1a5f08543867ed760106fdc0" name="a4907d03e1a5f08543867ed760106fdc0"></a>
std::vector&lt; <a class="el" href="structstormm_1_1data__types_1_1char4.html">char4</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getAtomName</b> (int low_index, int high_index) const</td></tr>
<tr class="separator:a4907d03e1a5f08543867ed760106fdc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab45fc6336ccbb5d48b97191d5d1ba0e6" id="r_ab45fc6336ccbb5d48b97191d5d1ba0e6"><td class="memItemLeft" align="right" valign="top"><a id="ab45fc6336ccbb5d48b97191d5d1ba0e6" name="ab45fc6336ccbb5d48b97191d5d1ba0e6"></a>
<a class="el" href="structstormm_1_1data__types_1_1char4.html">char4</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getAtomName</b> (int index) const</td></tr>
<tr class="separator:ab45fc6336ccbb5d48b97191d5d1ba0e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3283bd76190932c9760b9b80e19cb179" id="r_a3283bd76190932c9760b9b80e19cb179"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; <a class="el" href="structstormm_1_1data__types_1_1char4.html">char4</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3283bd76190932c9760b9b80e19cb179">getAtomType</a> () const</td></tr>
<tr class="memdesc:a3283bd76190932c9760b9b80e19cb179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the types of atoms in the system.  <br /></td></tr>
<tr class="separator:a3283bd76190932c9760b9b80e19cb179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba756bad19525ab88398fd24b5d124fd" id="r_aba756bad19525ab88398fd24b5d124fd"><td class="memItemLeft" align="right" valign="top"><a id="aba756bad19525ab88398fd24b5d124fd" name="aba756bad19525ab88398fd24b5d124fd"></a>
std::vector&lt; <a class="el" href="structstormm_1_1data__types_1_1char4.html">char4</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getAtomType</b> (int low_index, int high_index) const</td></tr>
<tr class="separator:aba756bad19525ab88398fd24b5d124fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26fbb05fe9db90ae352e5face9962ce3" id="r_a26fbb05fe9db90ae352e5face9962ce3"><td class="memItemLeft" align="right" valign="top"><a id="a26fbb05fe9db90ae352e5face9962ce3" name="a26fbb05fe9db90ae352e5face9962ce3"></a>
<a class="el" href="structstormm_1_1data__types_1_1char4.html">char4</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getAtomType</b> (int index) const</td></tr>
<tr class="separator:a26fbb05fe9db90ae352e5face9962ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a86710f8cfc4772e207804100a357f26a" id="r_a86710f8cfc4772e207804100a357f26a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; <a class="el" href="structstormm_1_1data__types_1_1char4.html">char4</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86710f8cfc4772e207804100a357f26a">getResidueName</a> () const</td></tr>
<tr class="memdesc:a86710f8cfc4772e207804100a357f26a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the names of residues in the system.  <br /></td></tr>
<tr class="separator:a86710f8cfc4772e207804100a357f26a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e450afa8ebeb40023a1120a54c7102" id="r_af9e450afa8ebeb40023a1120a54c7102"><td class="memItemLeft" align="right" valign="top"><a id="af9e450afa8ebeb40023a1120a54c7102" name="af9e450afa8ebeb40023a1120a54c7102"></a>
<a class="el" href="structstormm_1_1data__types_1_1char4.html">char4</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getResidueName</b> (int index) const</td></tr>
<tr class="separator:af9e450afa8ebeb40023a1120a54c7102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae937f80aca7c2351cadafc1cfbb1e725" id="r_ae937f80aca7c2351cadafc1cfbb1e725"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae937f80aca7c2351cadafc1cfbb1e725">findVirtualSites</a> () const</td></tr>
<tr class="memdesc:ae937f80aca7c2351cadafc1cfbb1e725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of the general topological indices of one or more virtual sites.  <br /></td></tr>
<tr class="separator:ae937f80aca7c2351cadafc1cfbb1e725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e255d183e8a1b14a3c8c2d675ee596" id="r_aa2e255d183e8a1b14a3c8c2d675ee596"><td class="memItemLeft" align="right" valign="top"><a id="aa2e255d183e8a1b14a3c8c2d675ee596" name="aa2e255d183e8a1b14a3c8c2d675ee596"></a>
std::vector&lt; <a class="el" href="structstormm_1_1data__types_1_1int2.html">int2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>findVirtualSites</b> (int low_index, int high_index) const</td></tr>
<tr class="separator:aa2e255d183e8a1b14a3c8c2d675ee596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a8a021e791de11e45d2dfc075a265ee" id="r_a0a8a021e791de11e45d2dfc075a265ee"><td class="memItemLeft" align="right" valign="top"><a id="a0a8a021e791de11e45d2dfc075a265ee" name="a0a8a021e791de11e45d2dfc075a265ee"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>findVirtualSites</b> (int index) const</td></tr>
<tr class="separator:a0a8a021e791de11e45d2dfc075a265ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1e98c0bb5c3e0fee3e077e00a02a7a6a" id="r_a1e98c0bb5c3e0fee3e077e00a02a7a6a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e98c0bb5c3e0fee3e077e00a02a7a6a">getChargeIndex</a> () const</td></tr>
<tr class="memdesc:a1e98c0bb5c3e0fee3e077e00a02a7a6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the charge type index of atoms in the system.  <br /></td></tr>
<tr class="separator:a1e98c0bb5c3e0fee3e077e00a02a7a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a4244e8062d87f2abaae6972470e3c" id="r_a56a4244e8062d87f2abaae6972470e3c"><td class="memItemLeft" align="right" valign="top"><a id="a56a4244e8062d87f2abaae6972470e3c" name="a56a4244e8062d87f2abaae6972470e3c"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getChargeIndex</b> (int low_index, int high_index) const</td></tr>
<tr class="separator:a56a4244e8062d87f2abaae6972470e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02c88802a4081356f7a584dd62b1a2a" id="r_ae02c88802a4081356f7a584dd62b1a2a"><td class="memItemLeft" align="right" valign="top"><a id="ae02c88802a4081356f7a584dd62b1a2a" name="ae02c88802a4081356f7a584dd62b1a2a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getChargeIndex</b> (int index) const</td></tr>
<tr class="separator:ae02c88802a4081356f7a584dd62b1a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a8264c83cfe67f8f1b1f81671baa56d10" id="r_a8264c83cfe67f8f1b1f81671baa56d10"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8264c83cfe67f8f1b1f81671baa56d10">getLennardJonesIndex</a> () const</td></tr>
<tr class="memdesc:a8264c83cfe67f8f1b1f81671baa56d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Lennard-Jones type index of atoms in the system.  <br /></td></tr>
<tr class="separator:a8264c83cfe67f8f1b1f81671baa56d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b3979c368cc18cb4ae968420ce15b4f" id="r_a0b3979c368cc18cb4ae968420ce15b4f"><td class="memItemLeft" align="right" valign="top"><a id="a0b3979c368cc18cb4ae968420ce15b4f" name="a0b3979c368cc18cb4ae968420ce15b4f"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getLennardJonesIndex</b> (int low_index, int high_index) const</td></tr>
<tr class="separator:a0b3979c368cc18cb4ae968420ce15b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f532177fa4fd02b934bf5c7937461b3" id="r_a1f532177fa4fd02b934bf5c7937461b3"><td class="memItemLeft" align="right" valign="top"><a id="a1f532177fa4fd02b934bf5c7937461b3" name="a1f532177fa4fd02b934bf5c7937461b3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getLennardJonesIndex</b> (int index) const</td></tr>
<tr class="separator:a1f532177fa4fd02b934bf5c7937461b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa4d847e0241f449f8407ad192667f65d" id="r_aa4d847e0241f449f8407ad192667f65d"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:aa4d847e0241f449f8407ad192667f65d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa4d847e0241f449f8407ad192667f65d">getLennardJonesSigma</a> (int index_a, int index_b) const</td></tr>
<tr class="memdesc:aa4d847e0241f449f8407ad192667f65d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Lennard-Jones interaction sigma. The quantity is derived from tables at the specified level of precision (float or double), but computed in double precision based on that information before it is returned in the template data type.  <br /></td></tr>
<tr class="separator:aa4d847e0241f449f8407ad192667f65d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d43a418c9050c209961e5db0767218" id="r_a46d43a418c9050c209961e5db0767218"><td class="memTemplParams" colspan="2"><a id="a46d43a418c9050c209961e5db0767218" name="a46d43a418c9050c209961e5db0767218"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:a46d43a418c9050c209961e5db0767218"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getLennardJonesSigma</b> (int index_a) const</td></tr>
<tr class="separator:a46d43a418c9050c209961e5db0767218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24dab3a458e0b10ab9963c81fd98de1b" id="r_a24dab3a458e0b10ab9963c81fd98de1b"><td class="memTemplParams" colspan="2"><a id="a24dab3a458e0b10ab9963c81fd98de1b" name="a24dab3a458e0b10ab9963c81fd98de1b"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:a24dab3a458e0b10ab9963c81fd98de1b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getLennardJonesSigma</b> () const</td></tr>
<tr class="separator:a24dab3a458e0b10ab9963c81fd98de1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a38dd6ccf8a244ebd37acab0e2ee11fbf" id="r_a38dd6ccf8a244ebd37acab0e2ee11fbf"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a38dd6ccf8a244ebd37acab0e2ee11fbf"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a38dd6ccf8a244ebd37acab0e2ee11fbf">getLennardJonesEpsilon</a> (int index_a, int index_b) const</td></tr>
<tr class="memdesc:a38dd6ccf8a244ebd37acab0e2ee11fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Lennard-Jones interaction epsilon value. The quantity is derived from tables at the specified level of precision (float or double), but computed in double precision based on that information before it is returned in the template data type.  <br /></td></tr>
<tr class="separator:a38dd6ccf8a244ebd37acab0e2ee11fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a157c554faeb0efae2abe3a4520dfa3f8" id="r_a157c554faeb0efae2abe3a4520dfa3f8"><td class="memTemplParams" colspan="2"><a id="a157c554faeb0efae2abe3a4520dfa3f8" name="a157c554faeb0efae2abe3a4520dfa3f8"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:a157c554faeb0efae2abe3a4520dfa3f8"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getLennardJonesEpsilon</b> (int index_a) const</td></tr>
<tr class="separator:a157c554faeb0efae2abe3a4520dfa3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f1ad6b7144948b78bce4f427034f88" id="r_a82f1ad6b7144948b78bce4f427034f88"><td class="memTemplParams" colspan="2"><a id="a82f1ad6b7144948b78bce4f427034f88" name="a82f1ad6b7144948b78bce4f427034f88"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:a82f1ad6b7144948b78bce4f427034f88"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getLennardJonesEpsilon</b> () const</td></tr>
<tr class="separator:a82f1ad6b7144948b78bce4f427034f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a020f0bd5bc03bca64e8a91123edae864" id="r_a020f0bd5bc03bca64e8a91123edae864"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a020f0bd5bc03bca64e8a91123edae864"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a020f0bd5bc03bca64e8a91123edae864">getAtomPBRadius</a> () const</td></tr>
<tr class="memdesc:a020f0bd5bc03bca64e8a91123edae864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Poisson-Boltzmann radius of a particular atom.  <br /></td></tr>
<tr class="separator:a020f0bd5bc03bca64e8a91123edae864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac412fd64d986d20fbdaf1079af17a139" id="r_ac412fd64d986d20fbdaf1079af17a139"><td class="memTemplParams" colspan="2"><a id="ac412fd64d986d20fbdaf1079af17a139" name="ac412fd64d986d20fbdaf1079af17a139"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:ac412fd64d986d20fbdaf1079af17a139"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getAtomPBRadius</b> (int low_index, int high_index) const</td></tr>
<tr class="separator:ac412fd64d986d20fbdaf1079af17a139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af48baa90d4d1c5e8346971fa0f4ba6ac" id="r_af48baa90d4d1c5e8346971fa0f4ba6ac"><td class="memTemplParams" colspan="2"><a id="af48baa90d4d1c5e8346971fa0f4ba6ac" name="af48baa90d4d1c5e8346971fa0f4ba6ac"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:af48baa90d4d1c5e8346971fa0f4ba6ac"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getAtomPBRadius</b> (int index) const</td></tr>
<tr class="separator:af48baa90d4d1c5e8346971fa0f4ba6ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a518cb1e17cb886c855371b907c07ecab" id="r_a518cb1e17cb886c855371b907c07ecab"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a518cb1e17cb886c855371b907c07ecab"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a518cb1e17cb886c855371b907c07ecab">getGBScreeningFactor</a> () const</td></tr>
<tr class="memdesc:a518cb1e17cb886c855371b907c07ecab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get GB screening factors for one or more atoms.  <br /></td></tr>
<tr class="separator:a518cb1e17cb886c855371b907c07ecab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a554228a74128400e8fd29d788352210c" id="r_a554228a74128400e8fd29d788352210c"><td class="memTemplParams" colspan="2"><a id="a554228a74128400e8fd29d788352210c" name="a554228a74128400e8fd29d788352210c"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:a554228a74128400e8fd29d788352210c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getGBScreeningFactor</b> (int low_index, int high_index) const</td></tr>
<tr class="separator:a554228a74128400e8fd29d788352210c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae50e8adc1f638551c42d4acbfaed0c47" id="r_ae50e8adc1f638551c42d4acbfaed0c47"><td class="memTemplParams" colspan="2"><a id="ae50e8adc1f638551c42d4acbfaed0c47" name="ae50e8adc1f638551c42d4acbfaed0c47"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:ae50e8adc1f638551c42d4acbfaed0c47"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getGBScreeningFactor</b> (int index) const</td></tr>
<tr class="separator:ae50e8adc1f638551c42d4acbfaed0c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af597e3802cc99f9e1b04076011df71b0" id="r_af597e3802cc99f9e1b04076011df71b0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af597e3802cc99f9e1b04076011df71b0">getSelfPointer</a> () const</td></tr>
<tr class="memdesc:af597e3802cc99f9e1b04076011df71b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the object itself.  <br /></td></tr>
<tr class="separator:af597e3802cc99f9e1b04076011df71b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5136677c2850a898b11dd568b218a46" id="r_ab5136677c2850a898b11dd568b218a46"><td class="memItemLeft" align="right" valign="top"><a id="ab5136677c2850a898b11dd568b218a46" name="ab5136677c2850a898b11dd568b218a46"></a>
<a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getSelfPointer</b> ()</td></tr>
<tr class="separator:ab5136677c2850a898b11dd568b218a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:abf6aab2fcf6d27049ff9c465723bf057" id="r_abf6aab2fcf6d27049ff9c465723bf057"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf6aab2fcf6d27049ff9c465723bf057">setBondParameters</a> (double new_keq, double new_leq, bool set_keq, bool set_leq, int parm_idx, ExceptionResponse policy=ExceptionResponse::SILENT)</td></tr>
<tr class="memdesc:abf6aab2fcf6d27049ff9c465723bf057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alter the parameters for a bond parameter set. This will alter the parameters in the topology and all bond terms that use the parameters will then be altered. This function does not add or remove bond terms or parameter sets, nor does it change the mapping of bond terms to parameter sets.  <br /></td></tr>
<tr class="separator:abf6aab2fcf6d27049ff9c465723bf057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefcd2a7d75c5ca3ad7bd49d138aa4e50" id="r_aefcd2a7d75c5ca3ad7bd49d138aa4e50"><td class="memItemLeft" align="right" valign="top"><a id="aefcd2a7d75c5ca3ad7bd49d138aa4e50" name="aefcd2a7d75c5ca3ad7bd49d138aa4e50"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setBondParameters</b> (double new_keq, double new_leq, bool set_keq, bool set_leq, <a class="el" href="structstormm_1_1data__types_1_1char4.html">char4</a> type_a, <a class="el" href="structstormm_1_1data__types_1_1char4.html">char4</a> type_b, ExceptionResponse policy=ExceptionResponse::SILENT)</td></tr>
<tr class="separator:aefcd2a7d75c5ca3ad7bd49d138aa4e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3b5dd4b437c13ac77c10ebd55b8f328c" id="r_a3b5dd4b437c13ac77c10ebd55b8f328c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b5dd4b437c13ac77c10ebd55b8f328c">setAngleParameters</a> (double new_keq, double new_teq, bool set_keq, bool set_teq, int parm_idx, ExceptionResponse policy=ExceptionResponse::SILENT)</td></tr>
<tr class="memdesc:a3b5dd4b437c13ac77c10ebd55b8f328c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alter the parameters for an angle parameter set. This will alter the parameters in the topology and all angle terms that use the parameters will then be use the new parameters. This function does not add or remove angle terms or parameter sets, nor does it change the mapping of angle terms to parameter sets.  <br /></td></tr>
<tr class="separator:a3b5dd4b437c13ac77c10ebd55b8f328c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b74a3468713d0a41f3dc15dddecd187" id="r_a0b74a3468713d0a41f3dc15dddecd187"><td class="memItemLeft" align="right" valign="top"><a id="a0b74a3468713d0a41f3dc15dddecd187" name="a0b74a3468713d0a41f3dc15dddecd187"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setAngleParameters</b> (double new_keq, double new_teq, bool set_keq, bool set_teq, <a class="el" href="structstormm_1_1data__types_1_1char4.html">char4</a> type_a, <a class="el" href="structstormm_1_1data__types_1_1char4.html">char4</a> type_b, <a class="el" href="structstormm_1_1data__types_1_1char4.html">char4</a> type_c, ExceptionResponse policy=ExceptionResponse::SILENT)</td></tr>
<tr class="separator:a0b74a3468713d0a41f3dc15dddecd187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4a295f3e46974420ef9031fba384e839" id="r_a4a295f3e46974420ef9031fba384e839"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a295f3e46974420ef9031fba384e839">setDihedralParameters</a> (double new_amplitude, double new_phase_angle, bool set_amplitude, bool set_phase_angle, int parm_idx, ExceptionResponse policy=ExceptionResponse::SILENT)</td></tr>
<tr class="memdesc:a4a295f3e46974420ef9031fba384e839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alter the parameters for a cosine-based dihedral angle parameter set. This will alter the parameters in the topology and all dihedral terms that use the parameters will then be use the new parameters. This function does not add or remove dihedral terms or parameter sets, nor does it change the mapping of dihedral terms to parameter sets.  <br /></td></tr>
<tr class="separator:a4a295f3e46974420ef9031fba384e839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab1993eb902d11314e04eb6136c2aac1" id="r_aab1993eb902d11314e04eb6136c2aac1"><td class="memItemLeft" align="right" valign="top"><a id="aab1993eb902d11314e04eb6136c2aac1" name="aab1993eb902d11314e04eb6136c2aac1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setDihedralParameters</b> (double new_amplitude, double new_phase_angle, bool set_amplitude, bool set_phase_angle, <a class="el" href="structstormm_1_1data__types_1_1char4.html">char4</a> type_a, <a class="el" href="structstormm_1_1data__types_1_1char4.html">char4</a> type_b, <a class="el" href="structstormm_1_1data__types_1_1char4.html">char4</a> type_c, <a class="el" href="structstormm_1_1data__types_1_1char4.html">char4</a> type_d, double periodicity, ExceptionResponse policy=ExceptionResponse::SILENT)</td></tr>
<tr class="separator:aab1993eb902d11314e04eb6136c2aac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a83d6d33332c2c585306bd6d41b2bf43d" id="r_a83d6d33332c2c585306bd6d41b2bf43d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83d6d33332c2c585306bd6d41b2bf43d">setUreyBradleyParameters</a> (double new_keq, double new_leq, bool set_keq, bool set_leq, int parm_idx, ExceptionResponse policy=ExceptionResponse::SILENT)</td></tr>
<tr class="memdesc:a83d6d33332c2c585306bd6d41b2bf43d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alter the parameters for a Urey-Bradley parameter set.  <br /></td></tr>
<tr class="separator:a83d6d33332c2c585306bd6d41b2bf43d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfd8903fdac2f264d67e0f44ce47ec6c" id="r_adfd8903fdac2f264d67e0f44ce47ec6c"><td class="memItemLeft" align="right" valign="top"><a id="adfd8903fdac2f264d67e0f44ce47ec6c" name="adfd8903fdac2f264d67e0f44ce47ec6c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setUreyBradleyParameters</b> (double new_keq, double new_leq, bool set_keq, bool set_leq, <a class="el" href="structstormm_1_1data__types_1_1char4.html">char4</a> type_a, <a class="el" href="structstormm_1_1data__types_1_1char4.html">char4</a> type_b, <a class="el" href="structstormm_1_1data__types_1_1char4.html">char4</a> type_c, ExceptionResponse policy=ExceptionResponse::SILENT)</td></tr>
<tr class="separator:adfd8903fdac2f264d67e0f44ce47ec6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac575bff0c623bf5c51caba9be6038876" id="r_ac575bff0c623bf5c51caba9be6038876"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac575bff0c623bf5c51caba9be6038876">setCharmmImprParameters</a> (double new_stiffness, double new_phase_angle, bool set_stiffness, bool set_phase_angle, int parm_idx, ExceptionResponse policy=ExceptionResponse::SILENT)</td></tr>
<tr class="memdesc:ac575bff0c623bf5c51caba9be6038876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alter the characteristics of a CHARMM improper dihedral parameter set.  <br /></td></tr>
<tr class="separator:ac575bff0c623bf5c51caba9be6038876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9f1938ecbf20b09c4daacfa421fb81" id="r_ada9f1938ecbf20b09c4daacfa421fb81"><td class="memItemLeft" align="right" valign="top"><a id="ada9f1938ecbf20b09c4daacfa421fb81" name="ada9f1938ecbf20b09c4daacfa421fb81"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setCharmmImprParameters</b> (double new_stiffness, double new_phase_angle, bool set_stiffness, bool set_phase_angle, <a class="el" href="structstormm_1_1data__types_1_1char4.html">char4</a> type_a, <a class="el" href="structstormm_1_1data__types_1_1char4.html">char4</a> type_b, <a class="el" href="structstormm_1_1data__types_1_1char4.html">char4</a> type_c, <a class="el" href="structstormm_1_1data__types_1_1char4.html">char4</a> type_d, ExceptionResponse policy=ExceptionResponse::SILENT)</td></tr>
<tr class="separator:ada9f1938ecbf20b09c4daacfa421fb81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a7920a17f5e926018671fd16335071cb7" id="r_a7920a17f5e926018671fd16335071cb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7920a17f5e926018671fd16335071cb7">setWaterResidueName</a> (const <a class="el" href="structstormm_1_1data__types_1_1char4.html">char4</a> new_name)</td></tr>
<tr class="memdesc:a7920a17f5e926018671fd16335071cb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the name of the water residue.  <br /></td></tr>
<tr class="separator:a7920a17f5e926018671fd16335071cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa518eb55b94a638a9056e62407df3c" id="r_a8aa518eb55b94a638a9056e62407df3c"><td class="memItemLeft" align="right" valign="top"><a id="a8aa518eb55b94a638a9056e62407df3c" name="a8aa518eb55b94a638a9056e62407df3c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setWaterResidueName</b> (const std::string &amp;new_name)</td></tr>
<tr class="separator:a8aa518eb55b94a638a9056e62407df3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a552d237e6cd50f46bcb7107611334ae8" id="r_a552d237e6cd50f46bcb7107611334ae8"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a552d237e6cd50f46bcb7107611334ae8">AtomGraphStage</a></td></tr>
<tr class="separator:a552d237e6cd50f46bcb7107611334ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A struct to hold information relating to an Amber topology. This struct's member functions are limited to getters for its private data. Because the primary means of constructing a topology will be complex, i.e. meticulous parsing of a file or expansion of an existing topology based on some new information, the constructors will need to be buried within wrapper functions that perform such procedures. This struct contains all information contained within an Amber prmtop-format file, nothng more, as described on: </p>
<p><a href="http://ambermd.org/FileFormats.php">http://ambermd.org/FileFormats.php</a></p>
<p>The design is intended to be both performant as well as accessible to developers. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad6a8569e3b30e01fd26e7f6177ec9303" name="ad6a8569e3b30e01fd26e7f6177ec9303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6a8569e3b30e01fd26e7f6177ec9303">&#9670;&#160;</a></span>AtomGraph() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">stormm::topology::AtomGraph::AtomGraph </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>file_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExceptionResponse</td>          <td class="paramname"><span class="paramname"><em>policy</em></span><span class="paramdefsep"> = </span><span class="paramdefval">ExceptionResponse::WARN</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TopologyKind</td>          <td class="paramname"><span class="paramname"><em>engine_format</em></span><span class="paramdefsep"> = </span><span class="paramdefval">TopologyKind::AMBER</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The general-purpose constructor for file-based topology creation. </p>
<p>Overloaded:</p><ul>
<li>Take just the file name, the exception response policy, and the kind of topology. APpropriate default values will be applied for each kind of topology.</li>
<li>In addition, take specific values for Coulomb's constant, the general 1:4 screening parameters, and charge discretization.</li>
<li>Extract a subset of the atoms from an existing <a class="el" href="classstormm_1_1energy_1_1AtomGraph.html" title="A struct to hold information relating to an Amber topology. This struct&#39;s member functions are limite...">AtomGraph</a> and create a new <a class="el" href="classstormm_1_1energy_1_1AtomGraph.html" title="A struct to hold information relating to an Amber topology. This struct&#39;s member functions are limite...">AtomGraph</a> from it. All parameters and terms from the original <a class="el" href="classstormm_1_1energy_1_1AtomGraph.html" title="A struct to hold information relating to an Amber topology. This struct&#39;s member functions are limite...">AtomGraph</a> will be carried over, provided that the new <a class="el" href="classstormm_1_1energy_1_1AtomGraph.html" title="A struct to hold information relating to an Amber topology. This struct&#39;s member functions are limite...">AtomGraph</a> contains all of the atoms that each term spans. Exclusions from the original <a class="el" href="classstormm_1_1energy_1_1AtomGraph.html" title="A struct to hold information relating to an Amber topology. This struct&#39;s member functions are limite...">AtomGraph</a> will be inferred from the bonding pattern.</li>
<li>Construct an <a class="el" href="classstormm_1_1energy_1_1AtomGraph.html" title="A struct to hold information relating to an Amber topology. This struct&#39;s member functions are limite...">AtomGraph</a> from two existing objects and perhaps multipliers for both</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_name</td><td>Name of the source file </td></tr>
    <tr><td class="paramname">policy</td><td>The alert level to raise if a problem is encountered </td></tr>
    <tr><td class="paramname">engine_format</td><td>Format of the topology file to read </td></tr>
    <tr><td class="paramname">coulomb_constant_in</td><td>Value of Coulomb's constant, in kcal-A/mol-e^2 </td></tr>
    <tr><td class="paramname">default_elec14_screening</td><td>The 1:4 electrostatic scaling to apply in absense of any other indications </td></tr>
    <tr><td class="paramname">default_vdw14_screening</td><td>The 1:4 van-der Waals scaling to apply in absense of any other indications </td></tr>
    <tr><td class="paramname">charge_rounding_tol</td><td>The maximum tolerance at which to initiate charge rounding </td></tr>
    <tr><td class="paramname">charge_discretization</td><td>Increment with which to discretize charges </td></tr>
    <tr><td class="paramname">ag_a</td><td>The first of two topologies to combine </td></tr>
    <tr><td class="paramname">ag_b</td><td>The second of two topologies to combine </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b5af36f94dfc8922430f31610b9d82c" name="a8b5af36f94dfc8922430f31610b9d82c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b5af36f94dfc8922430f31610b9d82c">&#9670;&#160;</a></span>AtomGraph() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">stormm::topology::AtomGraph::AtomGraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>original</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The copy constructor takes a lot of tedium upon itself to prevent more complexity in working with <a class="el" href="classstormm_1_1energy_1_1AtomGraph.html" title="A struct to hold information relating to an Amber topology. This struct&#39;s member functions are limite...">AtomGraph</a> objects downstream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">original</td><td>The original <a class="el" href="classstormm_1_1energy_1_1AtomGraph.html" title="A struct to hold information relating to an Amber topology. This struct&#39;s member functions are limite...">AtomGraph</a>. A deep copy of all data and repair of all pointers in the present object will be undertaken. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad8d79ebd487db56bced1642e823d8b77" name="ad8d79ebd487db56bced1642e823d8b77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8d79ebd487db56bced1642e823d8b77">&#9670;&#160;</a></span>AtomGraph() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">stormm::topology::AtomGraph::AtomGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>original</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The move constructor makes prodigious use of std::move for each string and <a class="el" href="classstormm_1_1energy_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> member variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">original</td><td>The original <a class="el" href="classstormm_1_1energy_1_1AtomGraph.html" title="A struct to hold information relating to an Amber topology. This struct&#39;s member functions are limite...">AtomGraph</a> to move into this one. The std::move function handles movement of the underlying <a class="el" href="classstormm_1_1energy_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> objects. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa68367674e283799bf8e522a849b9960" name="aa68367674e283799bf8e522a849b9960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa68367674e283799bf8e522a849b9960">&#9670;&#160;</a></span>buildFromPrmtop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::topology::AtomGraph::buildFromPrmtop </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>file_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExceptionResponse</td>          <td class="paramname"><span class="paramname"><em>policy</em></span><span class="paramdefsep"> = </span><span class="paramdefval">ExceptionResponse::WARN</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>coulomb_constant_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">amber_ancient_bioq</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>default_elec14_screening</em></span><span class="paramdefsep"> = </span><span class="paramdefval">amber_default_elec14_screen</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>default_vdw14_screening</em></span><span class="paramdefsep"> = </span><span class="paramdefval">amber_default_vdw14_screen</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>charge_rounding_tol</em></span><span class="paramdefsep"> = </span><span class="paramdefval">default_charge_rounding_tol</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>charge_discretization</em></span><span class="paramdefsep"> = </span><span class="paramdefval">default_charge_precision_inc</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build an <a class="el" href="classstormm_1_1energy_1_1AtomGraph.html" title="A struct to hold information relating to an Amber topology. This struct&#39;s member functions are limite...">AtomGraph</a> form a file. This is called by the general-purpose constructor or also by the developer after instantiating an empty object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_name</td><td>Name of the source file </td></tr>
    <tr><td class="paramname">policy</td><td>Indicates the alert level to raise if a problem is encountered </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae937f80aca7c2351cadafc1cfbb1e725" name="ae937f80aca7c2351cadafc1cfbb1e725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae937f80aca7c2351cadafc1cfbb1e725">&#9670;&#160;</a></span>findVirtualSites()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; stormm::topology::AtomGraph::findVirtualSites </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of the general topological indices of one or more virtual sites. </p>
<p>Overloaded:</p><ul>
<li>Get a list of all virtual sites, indexed by their order in the general topology</li>
<li>Get virtual sites within a range, limits given by ordering in the general topology, results given as indices into the general topology (part x) plus indices into the array of virtual sites (part y). For the first case, "get all virtual sites," the index in the returned array of general topology atom indices serves as an implicit indicator of the index into the list of virtual sites.</li>
<li>Get the topological index of one virtual site out of the list of virtual sites</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">low_index</td><td>The start of a stretch of atoms in the general topology </td></tr>
    <tr><td class="paramname">high_index</td><td>The end of a stretch of atoms in the general topology </td></tr>
    <tr><td class="paramname">index</td><td>A specific virtual site index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a820b6cf62ea4f263705ea64d7bf48d6f" name="a820b6cf62ea4f263705ea64d7bf48d6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a820b6cf62ea4f263705ea64d7bf48d6f">&#9670;&#160;</a></span>getAngleTerm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">AngleTerm&lt; T &gt; stormm::topology::AtomGraph::getAngleTerm </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect the atom indices and actual parameters for implement one of the system's harmonic bond angle bending terms. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The bond angle term to query, indexed according to the list of bond angle terms </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad94a576bec0f058a5f3c6cf4c5fdc00f" name="ad94a576bec0f058a5f3c6cf4c5fdc00f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad94a576bec0f058a5f3c6cf4c5fdc00f">&#9670;&#160;</a></span>getAtomExclusions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; stormm::topology::AtomGraph::getAtomExclusions </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the exclusion list for a particular atom. This will concatenate 1:1, 1:2, 1:3, and 1:4 exclusions, without regard to which is which. To get a specific type of exclusion, use one of the getNonbondedXXExclusions() functions. All functions of this sort will return a complete list such that if exclusions for all atoms are considered in sequence, all exclusions will be double-counted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The atom of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab19593d08d26638c57a65d738178b471" name="ab19593d08d26638c57a65d738178b471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab19593d08d26638c57a65d738178b471">&#9670;&#160;</a></span>getAtomicMass()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; stormm::topology::AtomGraph::getAtomicMass </td>
          <td>(</td>
          <td class="paramtype">MassForm</td>          <td class="paramname"><span class="paramname"><em>rep</em></span><span class="paramdefsep"> = </span><span class="paramdefval">MassForm::ORDINARY</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the masses of atoms in the system. The developer may also choose to take the pre-computed inverse masses (this can be useful when dealing with extra points, as inverses of zero-mass particles must also be set to zero by a conditional statement). </p>
<p>Overloaded:</p><ul>
<li>Get masses of all atoms in the system, indexed from 0</li>
<li>Get masses of a stretch of atoms in the system</li>
<li>Get the mass of a particular atom</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rep</td><td>The representation of the mass to take: ORDINARY or INVERSE </td></tr>
    <tr><td class="paramname">low_index</td><td>The start of a stretch of atoms </td></tr>
    <tr><td class="paramname">high_index</td><td>The end of a stretch of atoms </td></tr>
    <tr><td class="paramname">index</td><td>A specific atom index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a831ecd2ee7a84a449b373abc679a5000" name="a831ecd2ee7a84a449b373abc679a5000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a831ecd2ee7a84a449b373abc679a5000">&#9670;&#160;</a></span>getAtomicNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; stormm::topology::AtomGraph::getAtomicNumber </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the atomic numbers for atoms in the system. </p>
<p>Overloaded:</p><ul>
<li>Get the atomic numbers of all atoms in the system, as a std::vector&lt;int&gt;</li>
<li>Get the atomic numbers of a stretch of atoms in the system, as a std::vector&lt;int&gt;</li>
<li>Get the atomic number of a specific atom</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">low_index</td><td>Index of the first atom for which to read a Z number </td></tr>
    <tr><td class="paramname">high_index</td><td>Index of the last atom for which to read a Z number </td></tr>
    <tr><td class="paramname">index</td><td>Index of a specific atom </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aedc47d1e225809c371d36b74d679eaa6" name="aedc47d1e225809c371d36b74d679eaa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedc47d1e225809c371d36b74d679eaa6">&#9670;&#160;</a></span>getAtomMobility()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; bool &gt; stormm::topology::AtomGraph::getAtomMobility </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the mobile atom mask for the system, as a boolean vector translated from the bitmask stored internally. </p>
<p>Overloaded:</p><ul>
<li>Get the mobility of all atoms in the system, as a std::vector&lt;bool&gt;</li>
<li>Get the mobility of a stretch of atoms in the system</li>
<li>Get the mobility of a particular atom</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">low_index</td><td>Index of the first atom for which to read the mobility </td></tr>
    <tr><td class="paramname">high_index</td><td>Index of the last atom for which to read the mobility </td></tr>
    <tr><td class="paramname">index</td><td>Index of a specific atom </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a2aef8d3e95c757dfce25264e6f5e8f" name="a4a2aef8d3e95c757dfce25264e6f5e8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a2aef8d3e95c757dfce25264e6f5e8f">&#9670;&#160;</a></span>getAtomMobilityMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint &gt; stormm::topology::AtomGraph::getAtomMobilityMask </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the raw mobility bitmask over a particular range. </p>
<p>Overloaded:</p><ul>
<li>Get the mobility of all atoms in the system, as a std::vector&lt;uint&gt;</li>
<li>Get the mobility of a stretch of atoms in the system</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">low_index</td><td>Index of the first atom for which to read the mobility </td></tr>
    <tr><td class="paramname">high_index</td><td>Index of the last atom for which to read the mobility </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b74bf6e9b75165108ec785cbd650c64" name="a4b74bf6e9b75165108ec785cbd650c64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b74bf6e9b75165108ec785cbd650c64">&#9670;&#160;</a></span>getAtomName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; <a class="el" href="structstormm_1_1data__types_1_1char4.html">char4</a> &gt; &amp; stormm::topology::AtomGraph::getAtomName </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the names of atoms in the system. </p>
<p>Overloaded:</p><ul>
<li>Get names of all atoms in the system, indexed from 0</li>
<li>Get names of a stretch of atoms in the system</li>
<li>Get the name of a particular atom</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">low_index</td><td>The start of a stretch of atoms </td></tr>
    <tr><td class="paramname">high_index</td><td>The end of a stretch of atoms </td></tr>
    <tr><td class="paramname">index</td><td>A specific atom index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a020f0bd5bc03bca64e8a91123edae864" name="a020f0bd5bc03bca64e8a91123edae864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a020f0bd5bc03bca64e8a91123edae864">&#9670;&#160;</a></span>getAtomPBRadius()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; stormm::topology::AtomGraph::getAtomPBRadius </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Poisson-Boltzmann radius of a particular atom. </p>
<p>Overloaded:</p><ul>
<li>Get Poisson-Boltzmann radii of all atoms in the system, indexed from 0</li>
<li>Get Poisson-Boltzmann radii for a stretch of atoms in the system</li>
<li>Get the Poisson-Boltzmann radius of a particular atom</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">low_index</td><td>The start of a stretch of atoms </td></tr>
    <tr><td class="paramname">high_index</td><td>The end of a stretch of atoms </td></tr>
    <tr><td class="paramname">index</td><td>A specific atom index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3283bd76190932c9760b9b80e19cb179" name="a3283bd76190932c9760b9b80e19cb179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3283bd76190932c9760b9b80e19cb179">&#9670;&#160;</a></span>getAtomType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; <a class="el" href="structstormm_1_1data__types_1_1char4.html">char4</a> &gt; &amp; stormm::topology::AtomGraph::getAtomType </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the types of atoms in the system. </p>
<p>Overloaded:</p><ul>
<li>Get types of all atoms in the system, indexed from 0</li>
<li>Get types of a stretch of atoms in the system</li>
<li>Get the type of a particular atom</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">low_index</td><td>The start of a stretch of atoms </td></tr>
    <tr><td class="paramname">high_index</td><td>The end of a stretch of atoms </td></tr>
    <tr><td class="paramname">index</td><td>A specific atom index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a561b6dc629f72c2f8a3e9bc79805bb" name="a0a561b6dc629f72c2f8a3e9bc79805bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a561b6dc629f72c2f8a3e9bc79805bb">&#9670;&#160;</a></span>getBondTerm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">BondTerm&lt; T &gt; stormm::topology::AtomGraph::getBondTerm </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect the atom indices and actual parameters for implement one of the system's harmonic bond stretching terms. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The bond term to query, indexed according to the list of bond terms </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e98c0bb5c3e0fee3e077e00a02a7a6a" name="a1e98c0bb5c3e0fee3e077e00a02a7a6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e98c0bb5c3e0fee3e077e00a02a7a6a">&#9670;&#160;</a></span>getChargeIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; stormm::topology::AtomGraph::getChargeIndex </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the charge type index of atoms in the system. </p>
<p>Overloaded:</p><ul>
<li>Get charge indices of all atoms in the system, indexed from 0</li>
<li>Get charge indices of a stretch of atoms in the system</li>
<li>Get the charge index of a particular atom</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">low_index</td><td>The start of a stretch of atoms </td></tr>
    <tr><td class="paramname">high_index</td><td>The end of a stretch of atoms </td></tr>
    <tr><td class="paramname">index</td><td>A specific atom index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f43094f2ff71ee760494260e29f4240" name="a3f43094f2ff71ee760494260e29f4240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f43094f2ff71ee760494260e29f4240">&#9670;&#160;</a></span>getCharmmImprTerm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CharmmImprTerm&lt; T &gt; stormm::topology::AtomGraph::getCharmmImprTerm </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect the atom indices and actual parameters to implement one of the system's CHARMM improper terms. The special-pupose, unguarded struct that holds the result also provides the original parameter index, if of interest. This is for computing the potential energy and forces in the most straightforward manner possible, albeit slow. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The CHARMM improper term to query, indexed according to the list of CHARMM improper terms (not the general atom list) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9d2fea73563130f81183ecd1cf35aac" name="aa9d2fea73563130f81183ecd1cf35aac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9d2fea73563130f81183ecd1cf35aac">&#9670;&#160;</a></span>getChemicalDetailsKit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstormm_1_1topology_1_1ChemicalDetailsKit.html">ChemicalDetailsKit</a> stormm::topology::AtomGraph::getChemicalDetailsKit </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an abstract of the chemical details of the system, such as atom name and type or residue names and limits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tier</td><td>Indicator of whether pointers should target the CPU or the GPU layer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa020e1c2cd7c704253230bae4ce30d21" name="aa020e1c2cd7c704253230bae4ce30d21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa020e1c2cd7c704253230bae4ce30d21">&#9670;&#160;</a></span>getCmapDimension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stormm::topology::AtomGraph::getCmapDimension </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the dimension of a particular CMAP surface (all CMAPs are assumed to be square) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The CMAP surface of interest (along the list of available CMAP surfaces, not the list of CMAP terms) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a578338544f90cf6f49371cdd4e856ba5" name="a578338544f90cf6f49371cdd4e856ba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a578338544f90cf6f49371cdd4e856ba5">&#9670;&#160;</a></span>getCmapTerm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CmapTerm&lt; T &gt; stormm::topology::AtomGraph::getCmapTerm </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect the atom indices and a pointer to the surface to implement one of the system's CMAP terms. The special-purpose, unguarded struct that holds the result also provides the original parameter index, if of interest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The CMAP term to query, indexed according to the list of CMAP terms (not the general atom list) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07161e431576f4391dd8ab9ebe32c973" name="a07161e431576f4391dd8ab9ebe32c973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07161e431576f4391dd8ab9ebe32c973">&#9670;&#160;</a></span>getConstraintGroupAtoms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; stormm::topology::AtomGraph::getConstraintGroupAtoms </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the atoms of a single constraint group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the constraint group within the topology </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a253d079c4682cb91aca88753e70c83d1" name="a253d079c4682cb91aca88753e70c83d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a253d079c4682cb91aca88753e70c83d1">&#9670;&#160;</a></span>getDescriptor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stormm::topology::AtomGraph::getDescriptor </td>
          <td>(</td>
          <td class="paramtype">TopologyDescriptor</td>          <td class="paramname"><span class="paramname"><em>choice</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a descriptor from within the array of topology descriptors. If this topology were read from an Amber-format file, all descriptors are taken from the preamble in its first ~15 lines. </p>
<p>Overloaded:</p><ul>
<li>Take one of the longer, clarified enumerations from the TopologyDescriptor class</li>
<li>Take one of the shorter enumerations pulled from the Amber sander program and the online documentation (<a href="http://ambermd.org/FileFormats.php">http://ambermd.org/FileFormats.php</a>)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">choice</td><td>Index of the descriptor in the list. Call this function using the enum classes TopologyDescriptors or SanderDescriptors (see above) for easy, annotated access. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a052efb1a0f8c827101142168afdedc4a" name="a052efb1a0f8c827101142168afdedc4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a052efb1a0f8c827101142168afdedc4a">&#9670;&#160;</a></span>getDihedralTerm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DihedralTerm&lt; T &gt; stormm::topology::AtomGraph::getDihedralTerm </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect the atom indices and actual parameters for implement one of the system's cosine-based dihedral torsion terms. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The dihedral term to query, indexed according to the list of dihedral terms </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a328e861a4c4b2e1beb67ec05abe4fe0f" name="a328e861a4c4b2e1beb67ec05abe4fe0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a328e861a4c4b2e1beb67ec05abe4fe0f">&#9670;&#160;</a></span>getDoublePrecisionConstraintKit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConstraintKit&lt; double &gt; stormm::topology::AtomGraph::getDoublePrecisionConstraintKit </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an abstract for managing constraints based on double-precision parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tier</td><td>Indicator of whether pointers should target the CPU or the GPU layer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e86c41c00ee23573dcf60d84c525dbe" name="a8e86c41c00ee23573dcf60d84c525dbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e86c41c00ee23573dcf60d84c525dbe">&#9670;&#160;</a></span>getDoublePrecisionImplicitSolventKit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstormm_1_1topology_1_1ImplicitSolventKit.html">ImplicitSolventKit</a>&lt; double &gt; stormm::topology::AtomGraph::getDoublePrecisionImplicitSolventKit </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a double-precision abstract for calculating implicit solvent energy and forces. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tier</td><td>Indicator of whether pointers should target the CPU or the GPU layer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35eb9cb768abd8f8b0404fb300eb09c3" name="a35eb9cb768abd8f8b0404fb300eb09c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35eb9cb768abd8f8b0404fb300eb09c3">&#9670;&#160;</a></span>getDoublePrecisionNonbondedKit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstormm_1_1topology_1_1NonbondedKit.html">NonbondedKit</a>&lt; double &gt; stormm::topology::AtomGraph::getDoublePrecisionNonbondedKit </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a double-precision abstract for calculating non-bonded energy and forces. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tier</td><td>Indicator of whether pointers should target the CPU or the GPU layer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa567a3f7eb34c9ca7aac833543a47ab9" name="aa567a3f7eb34c9ca7aac833543a47ab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa567a3f7eb34c9ca7aac833543a47ab9">&#9670;&#160;</a></span>getDoublePrecisionValenceKit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstormm_1_1topology_1_1ValenceKit.html">ValenceKit</a>&lt; double &gt; stormm::topology::AtomGraph::getDoublePrecisionValenceKit </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an abstract for calculating valence terms in double precision. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tier</td><td>Indicator of whether pointers should target the CPU or the GPU layer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5cdc60cd4daf304e245603348b45ff2" name="af5cdc60cd4daf304e245603348b45ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5cdc60cd4daf304e245603348b45ff2">&#9670;&#160;</a></span>getDoublePrecisionVirtualSiteKit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstormm_1_1topology_1_1VirtualSiteKit.html">VirtualSiteKit</a>&lt; double &gt; stormm::topology::AtomGraph::getDoublePrecisionVirtualSiteKit </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a double-precision abstract for placing virtual sites and transmitting their forces to frame atoms with mass. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tier</td><td>Indicator of whether pointers should target the CPU or the GPU layer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad6ba883d001355455d81cdef475d18b9" name="ad6ba883d001355455d81cdef475d18b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6ba883d001355455d81cdef475d18b9">&#9670;&#160;</a></span>getFullAtomName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string stormm::topology::AtomGraph::getFullAtomName </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the full name (including the residue and structural residue number) of an atom, as a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The topological index of the atom of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a518cb1e17cb886c855371b907c07ecab" name="a518cb1e17cb886c855371b907c07ecab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a518cb1e17cb886c855371b907c07ecab">&#9670;&#160;</a></span>getGBScreeningFactor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; stormm::topology::AtomGraph::getGBScreeningFactor </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get GB screening factors for one or more atoms. </p>
<p>Overloaded:</p><ul>
<li>Get GB screening factors of all atoms in the system, indexed from 0</li>
<li>Get GB screening factors for a stretch of atoms in the system</li>
<li>Get the GB screening factor of a particular atom</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">low_index</td><td>The start of a stretch of atoms </td></tr>
    <tr><td class="paramname">high_index</td><td>The end of a stretch of atoms </td></tr>
    <tr><td class="paramname">index</td><td>A specific atom index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38dd6ccf8a244ebd37acab0e2ee11fbf" name="a38dd6ccf8a244ebd37acab0e2ee11fbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38dd6ccf8a244ebd37acab0e2ee11fbf">&#9670;&#160;</a></span>getLennardJonesEpsilon()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T stormm::topology::AtomGraph::getLennardJonesEpsilon </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index_a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index_b</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Lennard-Jones interaction epsilon value. The quantity is derived from tables at the specified level of precision (float or double), but computed in double precision based on that information before it is returned in the template data type. </p>
<p>Overloaded:</p><ul>
<li>Get a single atom's self-interaction epsilon</li>
<li>Get the epsilon for a pair of atoms (may not obey combining rules, e.g. CHARMM NB-Fix)</li>
<li>Get a table for the self-interaction epsilon values of all types present in the topology</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index_a</td><td>Index for the first atom </td></tr>
    <tr><td class="paramname">index_b</td><td>Index for the second atom </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8264c83cfe67f8f1b1f81671baa56d10" name="a8264c83cfe67f8f1b1f81671baa56d10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8264c83cfe67f8f1b1f81671baa56d10">&#9670;&#160;</a></span>getLennardJonesIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; stormm::topology::AtomGraph::getLennardJonesIndex </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Lennard-Jones type index of atoms in the system. </p>
<p>Overloaded:</p><ul>
<li>Get Lennard-Jones indices of all atoms in the system, indexed from 0</li>
<li>Get Lennard-Jones indices of a stretch of atoms in the system</li>
<li>Get the Lennard-Jones index of a particular atom</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">low_index</td><td>The start of a stretch of atoms </td></tr>
    <tr><td class="paramname">high_index</td><td>The end of a stretch of atoms </td></tr>
    <tr><td class="paramname">index</td><td>A specific atom index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4d847e0241f449f8407ad192667f65d" name="aa4d847e0241f449f8407ad192667f65d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d847e0241f449f8407ad192667f65d">&#9670;&#160;</a></span>getLennardJonesSigma()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T stormm::topology::AtomGraph::getLennardJonesSigma </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index_a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index_b</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Lennard-Jones interaction sigma. The quantity is derived from tables at the specified level of precision (float or double), but computed in double precision based on that information before it is returned in the template data type. </p>
<p>Overloaded:</p><ul>
<li>Get a single atom's self-interaction sigma</li>
<li>Get the sigma for a pair of atoms (may not obey combining rules, e.g. CHARMM NB-Fix)</li>
<li>Get a table for the self-interaction sigma values of all types present in the topology</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index_a</td><td>Index for the first atom </td></tr>
    <tr><td class="paramname">index_b</td><td>Index for the second atom </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acaaf3e861e0585de03e3290943f82b59" name="acaaf3e861e0585de03e3290943f82b59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaaf3e861e0585de03e3290943f82b59">&#9670;&#160;</a></span>getMoleculeContents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; stormm::topology::AtomGraph::getMoleculeContents </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the contents of a one or more molecules in the system. </p>
<p>Overloaded:</p><ul>
<li>Get the contents of all molecules</li>
<li>Get the contents of one particular molecule</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of a specific molecule </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37ecdb9ee2a0fccff83874bc7243bc3b" name="a37ecdb9ee2a0fccff83874bc7243bc3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37ecdb9ee2a0fccff83874bc7243bc3b">&#9670;&#160;</a></span>getMoleculeKind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MoleculeKind stormm::topology::AtomGraph::getMoleculeKind </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>mol_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the kind of a specific molecule wihtin the topology. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mol_index</td><td>The index of the molecule of interesta </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad67c3ed88c9d946d575b31cd16aba8c5" name="ad67c3ed88c9d946d575b31cd16aba8c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad67c3ed88c9d946d575b31cd16aba8c5">&#9670;&#160;</a></span>getMoleculeLimits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; stormm::topology::AtomGraph::getMoleculeLimits </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the molecule limits, indices into molecule_contents, for every molecule in the system. This allows that molecules not be contiguous in the topology atom indexing, but will be recoverable by molecule_contents. </p>
<p>Overloaded:</p><ul>
<li>Get all molecule limits as a std::vector&lt;int&gt;</li>
<li>Get the initial and final indices of a specific molecule in molecule_contents as an <a class="el" href="structstormm_1_1int2.html">int2</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of a specific molecule </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaff07b8b34e8fe466a65b5b96e5b826c" name="aaff07b8b34e8fe466a65b5b96e5b826c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaff07b8b34e8fe466a65b5b96e5b826c">&#9670;&#160;</a></span>getMoleculeMembership()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; stormm::topology::AtomGraph::getMoleculeMembership </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get molecule membership for atoms within the system. </p>
<p>Overloaded:</p><ul>
<li>Get the molecular membership of all atoms in the system, indexed from 0</li>
<li>Get the molecular membership a stretch of atoms in the system</li>
<li>Get the molecule index that a particular atom is part of</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">low_index</td><td>Index of the first atom for which to read the mobility </td></tr>
    <tr><td class="paramname">high_index</td><td>Index of the last atom for which to read the mobility </td></tr>
    <tr><td class="paramname">index</td><td>Index of a specific atom </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa81a68312c2ceb0e7294dcced4db6681" name="aa81a68312c2ceb0e7294dcced4db6681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa81a68312c2ceb0e7294dcced4db6681">&#9670;&#160;</a></span>getNonbonded11Exclusions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; stormm::topology::AtomGraph::getNonbonded11Exclusions </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the 1:1 exclusions for a particular atom. This list will only be populated if the atom is a virtual site or has virtual sites that claim it as their parent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The atom of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad99755bedf613914a6a21f575cab04f7" name="ad99755bedf613914a6a21f575cab04f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad99755bedf613914a6a21f575cab04f7">&#9670;&#160;</a></span>getNonbonded12Exclusions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; stormm::topology::AtomGraph::getNonbonded12Exclusions </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all 1:2 exclusions for a particular atom. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The atom of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7433f48b407a8f7874d1edb9619f4bc5" name="a7433f48b407a8f7874d1edb9619f4bc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7433f48b407a8f7874d1edb9619f4bc5">&#9670;&#160;</a></span>getNonbonded13Exclusions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; stormm::topology::AtomGraph::getNonbonded13Exclusions </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all 1:3 exclusions for a particular atom. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The atom of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a36711bd0ac95814aa9a4ae7aa0bae0cc" name="a36711bd0ac95814aa9a4ae7aa0bae0cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36711bd0ac95814aa9a4ae7aa0bae0cc">&#9670;&#160;</a></span>getNonbonded14Exclusions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; stormm::topology::AtomGraph::getNonbonded14Exclusions </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all 1:4 exclusions for a particular atom. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The atom of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad31ff4865066ec358d70f3bbc4fcffb1" name="ad31ff4865066ec358d70f3bbc4fcffb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad31ff4865066ec358d70f3bbc4fcffb1">&#9670;&#160;</a></span>getPartialCharge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; stormm::topology::AtomGraph::getPartialCharge </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the atomic partial charges of atoms in the system. </p>
<p>Overloaded:</p><ul>
<li>Get partial charges of all atoms in the system, indexed from 0</li>
<li>Get partial charges of a stretch of atoms in the system</li>
<li>Get the partial charge of a particular atom</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">low_index</td><td>The start of a stretch of atoms </td></tr>
    <tr><td class="paramname">high_index</td><td>The end of a stretch of atoms </td></tr>
    <tr><td class="paramname">index</td><td>A specific atom index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96a8df0b247b19aa13619a9b7b29694d" name="a96a8df0b247b19aa13619a9b7b29694d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a8df0b247b19aa13619a9b7b29694d">&#9670;&#160;</a></span>getParticlesPerMolecule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; stormm::topology::AtomGraph::getParticlesPerMolecule </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the sizes of all molecules in the system. Rather redundant with the molecule limits being accessible, but convenient. </p>
<p>Overloaded:</p><ul>
<li>Get the sizes of all molecules as a std::vector&lt;int&gt;</li>
<li>Get the size of a single molecule</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of a specific residue </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb303475fe08735cc4f89dc7d62d2fa2" name="abb303475fe08735cc4f89dc7d62d2fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb303475fe08735cc4f89dc7d62d2fa2">&#9670;&#160;</a></span>getResidueIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; stormm::topology::AtomGraph::getResidueIndex </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the index (topology index, not natural / structure-informed residue number) of a particular residue. </p>
<p>Overloaded:</p><ul>
<li>Get all residue indices as a std::vector&lt;int&gt;</li>
<li>Get the residue index of a particular atom</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">atom_index</td><td>Index of the atom in question </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adfbdbf5fcd6ec34e2a0bcec0f551aed2" name="adfbdbf5fcd6ec34e2a0bcec0f551aed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfbdbf5fcd6ec34e2a0bcec0f551aed2">&#9670;&#160;</a></span>getResidueLimits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; int &gt; &amp; stormm::topology::AtomGraph::getResidueLimits </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get residue limits for the beginning and ends of up to N residues. </p>
<p>Overloaded:</p><ul>
<li>Get all residue limits as a std::vector&lt;int&gt;</li>
<li>Get the initial and final atom indices of a specific residue as an <a class="el" href="structstormm_1_1int2.html">int2</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of a specific residue </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86710f8cfc4772e207804100a357f26a" name="a86710f8cfc4772e207804100a357f26a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86710f8cfc4772e207804100a357f26a">&#9670;&#160;</a></span>getResidueName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; <a class="el" href="structstormm_1_1data__types_1_1char4.html">char4</a> &gt; &amp; stormm::topology::AtomGraph::getResidueName </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the names of residues in the system. </p>
<p>Overloaded:</p><ul>
<li>Get names of all residues in the system, indexed from 0</li>
<li>Get the name of a particular residue</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>A specific residue index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53d58d577eb9451ef46182b6d85ce4b0" name="a53d58d577eb9451ef46182b6d85ce4b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53d58d577eb9451ef46182b6d85ce4b0">&#9670;&#160;</a></span>getResidueNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; stormm::topology::AtomGraph::getResidueNumber </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the residue numbers for atoms in the system. </p>
<p>Overloaded:</p><ul>
<li>Get the residue numbers of all atoms in the system, as a std::vector&lt;int&gt;</li>
<li>Get the residue numbers of a stretch of atoms in the system, as a std::vector&lt;int&gt;</li>
<li>Get the residue number of a specific atom</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">low_index</td><td>Index of the first atom for which to read a residue number </td></tr>
    <tr><td class="paramname">high_index</td><td>Index of the last atom for which to read a residue number </td></tr>
    <tr><td class="paramname">index</td><td>Index of a specific atom </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af597e3802cc99f9e1b04076011df71b0" name="af597e3802cc99f9e1b04076011df71b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af597e3802cc99f9e1b04076011df71b0">&#9670;&#160;</a></span>getSelfPointer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> * stormm::topology::AtomGraph::getSelfPointer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the object itself. </p>
<p>Overloaded:</p><ul>
<li>Get a const pointer to a const <a class="el" href="classstormm_1_1energy_1_1AtomGraph.html" title="A struct to hold information relating to an Amber topology. This struct&#39;s member functions are limite...">AtomGraph</a></li>
<li>Get a non-const pointer to a mutable <a class="el" href="classstormm_1_1energy_1_1AtomGraph.html" title="A struct to hold information relating to an Amber topology. This struct&#39;s member functions are limite...">AtomGraph</a> </li>
</ul>

</div>
</div>
<a id="a4eca7aa889462af414093806b22b4a7f" name="a4eca7aa889462af414093806b22b4a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eca7aa889462af414093806b22b4a7f">&#9670;&#160;</a></span>getSinglePrecisionConstraintKit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConstraintKit&lt; float &gt; stormm::topology::AtomGraph::getSinglePrecisionConstraintKit </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an abstract for managing constraints based on single-precision parameters. While the overall implementation for constraints cannot be implemented entirely in single precision, having the underlying parameters in this form is not, in principle, a drvier of energy drift. It will simply set the system into a slightly different geometry, which is probably still closer to the double-precision result than many cycles of SHAKE or RATTLE would get it anyway. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tier</td><td>Indicator of whether pointers should target the CPU or the GPU layer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd0d86bad4600871f31a8dd98fc5efbd" name="afd0d86bad4600871f31a8dd98fc5efbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd0d86bad4600871f31a8dd98fc5efbd">&#9670;&#160;</a></span>getSinglePrecisionImplicitSolventKit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstormm_1_1topology_1_1ImplicitSolventKit.html">ImplicitSolventKit</a>&lt; float &gt; stormm::topology::AtomGraph::getSinglePrecisionImplicitSolventKit </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a single-precision abstract for calculating implicit solvent energy and forces. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tier</td><td>Indicator of whether pointers should target the CPU or the GPU layer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a863a32007974e29a65ee21c1ee10e8f3" name="a863a32007974e29a65ee21c1ee10e8f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a863a32007974e29a65ee21c1ee10e8f3">&#9670;&#160;</a></span>getSinglePrecisionNonbondedKit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstormm_1_1topology_1_1NonbondedKit.html">NonbondedKit</a>&lt; float &gt; stormm::topology::AtomGraph::getSinglePrecisionNonbondedKit </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a single-precision abstract for calculating non-bonded energy and forces. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tier</td><td>Indicator of whether pointers should target the CPU or the GPU layer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20463b2e0ffa255d5af9179ac87a0d1a" name="a20463b2e0ffa255d5af9179ac87a0d1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20463b2e0ffa255d5af9179ac87a0d1a">&#9670;&#160;</a></span>getSinglePrecisionValenceKit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstormm_1_1topology_1_1ValenceKit.html">ValenceKit</a>&lt; float &gt; stormm::topology::AtomGraph::getSinglePrecisionValenceKit </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a single-precision abstract for calculating valence terms. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tier</td><td>Indicator of whether pointers should target the CPU or the GPU layer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a629f5621656898ee9a0a82d460591890" name="a629f5621656898ee9a0a82d460591890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a629f5621656898ee9a0a82d460591890">&#9670;&#160;</a></span>getSinglePrecisionVirtualSiteKit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstormm_1_1topology_1_1VirtualSiteKit.html">VirtualSiteKit</a>&lt; float &gt; stormm::topology::AtomGraph::getSinglePrecisionVirtualSiteKit </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a single-precision abstract for placing virtual sites and transmitting their forces to frame atoms with mass. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tier</td><td>Indicator of whether pointers should target the CPU or the GPU layer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9beef3b9fa5765e7bf169b0170ec1e18" name="a9beef3b9fa5765e7bf169b0170ec1e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9beef3b9fa5765e7bf169b0170ec1e18">&#9670;&#160;</a></span>getStructuralAtomNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; stormm::topology::AtomGraph::getStructuralAtomNumber </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the (arbitrarily defined) atom numbers for atoms in the system. For example, a PDB file could ahve its own atom numbering scheme. This provides a way to transcribe that into the <a class="el" href="classstormm_1_1energy_1_1AtomGraph.html" title="A struct to hold information relating to an Amber topology. This struct&#39;s member functions are limite...">AtomGraph</a> object. </p>
<p>Overloaded:</p><ul>
<li>Get the structural atom numbers of all atoms in the system, as a std::vector&lt;int&gt;</li>
<li>Get structural atom numbers of a stretch of atoms in the system, as a std::vector&lt;int&gt;</li>
<li>Get the structural atom number of a specific atom</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">low_index</td><td>Index of the first atom for which to read a residue number </td></tr>
    <tr><td class="paramname">high_index</td><td>Index of the last atom for which to read a residue number </td></tr>
    <tr><td class="paramname">index</td><td>Index of a specific atom </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09d71afd37ae4bf909f7cca1ff54ceeb" name="a09d71afd37ae4bf909f7cca1ff54ceeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09d71afd37ae4bf909f7cca1ff54ceeb">&#9670;&#160;</a></span>getUreyBradleyTerm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">UreyBradleyTerm&lt; T &gt; stormm::topology::AtomGraph::getUreyBradleyTerm </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect the atom indices and actual parameters to implement one of the system's Urey-Bradley terms. The special-purpose, unguarded struct that holds the result also provides the original parameter index, if of interest. This is for computing the potential energy and forces in the most straightforward manner possible, albeit slow. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The Urey-Bradley term to query, indexed according to the list of Urey-Bradley terms (not the general atom list) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8738095c48c67ab3a37842607d3597ff" name="a8738095c48c67ab3a37842607d3597ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8738095c48c67ab3a37842607d3597ff">&#9670;&#160;</a></span>getVirtualSiteFrameAtom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stormm::topology::AtomGraph::getVirtualSiteFrameAtom </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nfrm</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the general topology index of one of a virtual site's frame atoms. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The virtual site of interest, indexed according to its place in the list of virtual sites (not the general topology atom list) </td></tr>
    <tr><td class="paramname">nfrm</td><td>The frame atom to pull out (values of 1:4 for one, two, three, or four-atom frames are acceptable) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a78d76a16dbdd948a944f7219c89b9d" name="a7a78d76a16dbdd948a944f7219c89b9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a78d76a16dbdd948a944f7219c89b9d">&#9670;&#160;</a></span>getVirtualSiteFrameDimension()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T stormm::topology::AtomGraph::getVirtualSiteFrameDimension </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ndim</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the dimensions (could be length in A, could be scaling factor for a distance or cross product) of one virtual site's frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The virtual site of interest, indexed according to its place in the list of virtual sites (not the general topology atom list) </td></tr>
    <tr><td class="paramname">ndim</td><td>The frame dimension to pull out (values of 1-3 for frames with one, two, or three details are acceptable) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a15fca03a580f470d5bcdde57c6df2288" name="a15fca03a580f470d5bcdde57c6df2288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15fca03a580f470d5bcdde57c6df2288">&#9670;&#160;</a></span>getVirtualSiteFrameType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VirtualSiteKind stormm::topology::AtomGraph::getVirtualSiteFrameType </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the frame type of a particular virtual site. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The virtual site of interest, indexed according to its place in the list of virtual sites (not the general topology atom list) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a91ef34fd71594b3c252ed7427b9b7f6b" name="a91ef34fd71594b3c252ed7427b9b7f6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91ef34fd71594b3c252ed7427b9b7f6b">&#9670;&#160;</a></span>getVirtualSiteIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stormm::topology::AtomGraph::getVirtualSiteIndex </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>atom_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExceptionResponse</td>          <td class="paramname"><span class="paramname"><em>policy</em></span><span class="paramdefsep"> = </span><span class="paramdefval">ExceptionResponse::DIE</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the virtual site index of an atom index. If the atom index is not a virtual site, this function will throw an error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">atom_index</td><td>Index of the atom in question </td></tr>
    <tr><td class="paramname">policy</td><td>Action to take if the atom turns out not to be a virtual site at all </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4114266696778ab98af4f298bb47a086" name="a4114266696778ab98af4f298bb47a086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4114266696778ab98af4f298bb47a086">&#9670;&#160;</a></span>matchOverflowAtomName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structstormm_1_1data__types_1_1char4.html">char4</a> &gt; stormm::topology::AtomGraph::matchOverflowAtomName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>query</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Match a long atom name and return its key in the standard list of <a class="el" href="structstormm_1_1char4.html">char4</a> atom names. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>The extended atom name to match </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d3eb5d07bb973bb4a4ae8d32fc60168" name="a3d3eb5d07bb973bb4a4ae8d32fc60168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d3eb5d07bb973bb4a4ae8d32fc60168">&#9670;&#160;</a></span>matchOverflowAtomType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structstormm_1_1data__types_1_1char4.html">char4</a> &gt; stormm::topology::AtomGraph::matchOverflowAtomType </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>query</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Match a long atom type and return its key in the standard list of <a class="el" href="structstormm_1_1char4.html">char4</a> atom types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>The extended atom type name to match </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8efc794c1bd9e72033fb818cca832777" name="a8efc794c1bd9e72033fb818cca832777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8efc794c1bd9e72033fb818cca832777">&#9670;&#160;</a></span>matchOverflowResidueName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structstormm_1_1data__types_1_1char4.html">char4</a> &gt; stormm::topology::AtomGraph::matchOverflowResidueName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>query</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Match a long residue name and return its key among the standard <a class="el" href="structstormm_1_1char4.html">char4</a> residue names. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>The extended residue name to match </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a017fad73eb157106ac99b8ab99fd1986" name="a017fad73eb157106ac99b8ab99fd1986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a017fad73eb157106ac99b8ab99fd1986">&#9670;&#160;</a></span>modifyAtomMobility()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::topology::AtomGraph::modifyAtomMobility </td>
          <td>(</td>
          <td class="paramtype">MobilitySetting</td>          <td class="paramname"><span class="paramname"><em>movement</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change an atom's mobility in the topology. </p>
<p>Overloaded:</p><ul>
<li>Change all atoms to become mobile or not, or toggle mobility.</li>
<li>Change a specific stretch of atoms to become mobile or not, or toggle mobility.</li>
<li>Make a specific atom mobile or not, or toggle mobility.</li>
<li>Make a scattered selection of atoms mask mobile or not, or toggle the mobility.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">movement</td><td>The desired atom mobility (OFF, ON, or TOGGLE) </td></tr>
    <tr><td class="paramname">low_index</td><td>The start of a stretch of atoms </td></tr>
    <tr><td class="paramname">high_index</td><td>The end of a stretch of atoms </td></tr>
    <tr><td class="paramname">index</td><td>A specific atom index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5bb2dbe08db5eda24dd446b20bfc56aa" name="a5bb2dbe08db5eda24dd446b20bfc56aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bb2dbe08db5eda24dd446b20bfc56aa">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp; stormm::topology::AtomGraph::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another <a class="el" href="classstormm_1_1energy_1_1AtomGraph.html" title="A struct to hold information relating to an Amber topology. This struct&#39;s member functions are limite...">AtomGraph</a> to form the basis for re-assigning members of this one </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab3bc6196852d2b207843c9796143723e" name="ab3bc6196852d2b207843c9796143723e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3bc6196852d2b207843c9796143723e">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp; stormm::topology::AtomGraph::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another <a class="el" href="classstormm_1_1energy_1_1AtomGraph.html" title="A struct to hold information relating to an Amber topology. This struct&#39;s member functions are limite...">AtomGraph</a> to form the basis for re-assigning members of this one </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aadb8771c09584c633309df9d11b23053" name="aadb8771c09584c633309df9d11b23053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadb8771c09584c633309df9d11b23053">&#9670;&#160;</a></span>printToFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::topology::AtomGraph::printToFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>output_file</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TopologyKind</td>          <td class="paramname"><span class="paramname"><em>output_style</em></span><span class="paramdefsep"> = </span><span class="paramdefval">TopologyKind::AMBER</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PrintSituation</td>          <td class="paramname"><span class="paramname"><em>expectation</em></span><span class="paramdefsep"> = </span><span class="paramdefval">PrintSituation::OPEN_NEW</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExceptionResponse</td>          <td class="paramname"><span class="paramname"><em>pr_policy</em></span><span class="paramdefsep"> = </span><span class="paramdefval">ExceptionResponse::DIE</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print out a topology in the specified format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output_file</td><td>The name of the file to print. If an empty string is given, the source file will be scheduled for overwriting, pending a user-specifiable directive as to whether overwriting is enabled. </td></tr>
    <tr><td class="paramname">output_style</td><td>The format of topology to write, each format being readable by specific third-party molecular mechancis packages </td></tr>
    <tr><td class="paramname">expectation</td><td>Indicates what state the output file is expected to be found in, if such a file may be found to already exist at all </td></tr>
    <tr><td class="paramname">pr_policy</td><td>Specifies the course of action to take if errors are encountered </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b5dd4b437c13ac77c10ebd55b8f328c" name="a3b5dd4b437c13ac77c10ebd55b8f328c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b5dd4b437c13ac77c10ebd55b8f328c">&#9670;&#160;</a></span>setAngleParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::topology::AtomGraph::setAngleParameters </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>new_keq</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>new_teq</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>set_keq</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>set_teq</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>parm_idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExceptionResponse</td>          <td class="paramname"><span class="paramname"><em>policy</em></span><span class="paramdefsep"> = </span><span class="paramdefval">ExceptionResponse::SILENT</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alter the parameters for an angle parameter set. This will alter the parameters in the topology and all angle terms that use the parameters will then be use the new parameters. This function does not add or remove angle terms or parameter sets, nor does it change the mapping of angle terms to parameter sets. </p>
<p>Overloaded:</p><ul>
<li>Accept the atom types for each atom in the angle</li>
<li>Accept the parameter set index for the angle</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_keq</td><td>The new stiffness constant to apply </td></tr>
    <tr><td class="paramname">new_teq</td><td>The new angular equilibrium constant to apply </td></tr>
    <tr><td class="paramname">set_keq</td><td>Whether to change the stiffness constant </td></tr>
    <tr><td class="paramname">set_teq</td><td>Whether to change the equilibrium </td></tr>
    <tr><td class="paramname">parm_idx</td><td>Index of the angle parameter set from within the topology's table (one cannot depend on this index to be consistent across topologies of different systems making use of the same force field) </td></tr>
    <tr><td class="paramname">type_a</td><td>Atom type of the first atom in the angle (this will be consistent across multiple topologies using the same force field) </td></tr>
    <tr><td class="paramname">type_b</td><td>Atom type of the second atom in the angle </td></tr>
    <tr><td class="paramname">type_c</td><td>Atom type of the third atom in the angle </td></tr>
    <tr><td class="paramname">policy</td><td>Behavior if an angle parameter set matching the index or atom types is not found in the topology </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf6aab2fcf6d27049ff9c465723bf057" name="abf6aab2fcf6d27049ff9c465723bf057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf6aab2fcf6d27049ff9c465723bf057">&#9670;&#160;</a></span>setBondParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::topology::AtomGraph::setBondParameters </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>new_keq</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>new_leq</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>set_keq</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>set_leq</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>parm_idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExceptionResponse</td>          <td class="paramname"><span class="paramname"><em>policy</em></span><span class="paramdefsep"> = </span><span class="paramdefval">ExceptionResponse::SILENT</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alter the parameters for a bond parameter set. This will alter the parameters in the topology and all bond terms that use the parameters will then be altered. This function does not add or remove bond terms or parameter sets, nor does it change the mapping of bond terms to parameter sets. </p>
<p>Overloaded:</p><ul>
<li>Accept the atom types for each atom in the bond</li>
<li>Accept the parameter set index for the bond</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_keq</td><td>The new stiffness constant to apply </td></tr>
    <tr><td class="paramname">new_leq</td><td>The new equilibrium constant to apply </td></tr>
    <tr><td class="paramname">set_keq</td><td>Whether to change the stiffness constant </td></tr>
    <tr><td class="paramname">set_leq</td><td>Whether to change the equilibrium </td></tr>
    <tr><td class="paramname">parm_idx</td><td>Index of the bond parameter set from within the topology's table (one cannot depend on this index to be consistent across topologies of different systems making use of the same force field) </td></tr>
    <tr><td class="paramname">type_a</td><td>Atom type of the first atom in the bond (this will be consistent across multiple topologies using the same force field) </td></tr>
    <tr><td class="paramname">type_b</td><td>Atom type of the second atom in the bond </td></tr>
    <tr><td class="paramname">policy</td><td>Behavior if a bond parameter set matching the index or atom types is not found in the topology </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac575bff0c623bf5c51caba9be6038876" name="ac575bff0c623bf5c51caba9be6038876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac575bff0c623bf5c51caba9be6038876">&#9670;&#160;</a></span>setCharmmImprParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::topology::AtomGraph::setCharmmImprParameters </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>new_stiffness</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>new_phase_angle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>set_stiffness</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>set_phase_angle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>parm_idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExceptionResponse</td>          <td class="paramname"><span class="paramname"><em>policy</em></span><span class="paramdefsep"> = </span><span class="paramdefval">ExceptionResponse::SILENT</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alter the characteristics of a CHARMM improper dihedral parameter set. </p>
<p>Overloaded:</p><ul>
<li>Accept the atom types for each atom in the CHARMM improper term</li>
<li>Accept the parameter set index for the CHARMM improper term</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_stiffness</td><td>The new stiffness constant to apply </td></tr>
    <tr><td class="paramname">new_phase_angle</td><td>The new phase angle constant to apply </td></tr>
    <tr><td class="paramname">set_stiffness</td><td>Whether to change the stiffness constant </td></tr>
    <tr><td class="paramname">set_phase_angle</td><td>Whether to change the equilibrium </td></tr>
    <tr><td class="paramname">parm_idx</td><td>Index of the CHARMM improper dihedral parameter set from within the topology's table (one cannot depend on this index to be consistent across topologies of different systems making use of the same force field) </td></tr>
    <tr><td class="paramname">type_a</td><td>Atom type of the first atom in the improper (this will be consistent across multiple topologies using the same force field) </td></tr>
    <tr><td class="paramname">type_b</td><td>Atom type of the second atom in the improper </td></tr>
    <tr><td class="paramname">type_c</td><td>Atom type of the third atom in the improper </td></tr>
    <tr><td class="paramname">type_d</td><td>Atom type of the fourth atom in the improper </td></tr>
    <tr><td class="paramname">policy</td><td>Behavior if a CHARMM improper dihedral parameter set matching the index or atom types and periodicity is not found in the topology </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a295f3e46974420ef9031fba384e839" name="a4a295f3e46974420ef9031fba384e839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a295f3e46974420ef9031fba384e839">&#9670;&#160;</a></span>setDihedralParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::topology::AtomGraph::setDihedralParameters </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>new_amplitude</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>new_phase_angle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>set_amplitude</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>set_phase_angle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>parm_idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExceptionResponse</td>          <td class="paramname"><span class="paramname"><em>policy</em></span><span class="paramdefsep"> = </span><span class="paramdefval">ExceptionResponse::SILENT</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alter the parameters for a cosine-based dihedral angle parameter set. This will alter the parameters in the topology and all dihedral terms that use the parameters will then be use the new parameters. This function does not add or remove dihedral terms or parameter sets, nor does it change the mapping of dihedral terms to parameter sets. </p>
<p>Overloaded:</p><ul>
<li>Accept the atom types for each atom in the dihedral angle</li>
<li>Accept the parameter set index for the dihedral angle</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_amplitude</td><td>The new cosine series term amplitude constant to apply </td></tr>
    <tr><td class="paramname">new_phase_angle</td><td>The new phase angle to apply </td></tr>
    <tr><td class="paramname">set_amplitude</td><td>Whether to change the amplitude constant </td></tr>
    <tr><td class="paramname">set_phase_angle</td><td>Whether to change the equilibrium </td></tr>
    <tr><td class="paramname">parm_idx</td><td>Index of the dihedral angle parameter set from within the topology's table (one cannot depend on this index to be consistent across topologies of different systems making use of the same force field) </td></tr>
    <tr><td class="paramname">type_a</td><td>Atom type of the first atom in the dihedral (this will be consistent across multiple topologies using the same force field) </td></tr>
    <tr><td class="paramname">type_b</td><td>Atom type of the second atom in the dihedral </td></tr>
    <tr><td class="paramname">type_c</td><td>Atom type of the third atom in the dihedral </td></tr>
    <tr><td class="paramname">type_d</td><td>Atom type of the fourth atom in the dihedral </td></tr>
    <tr><td class="paramname">periodicity</td><td>Periodicity of the dihedral parameter set (this disambiguates dihedral parameters that apply on top of one another to the same four atom types) </td></tr>
    <tr><td class="paramname">policy</td><td>Behavior if a dihedral parameter set matching the index or atom types and periodicity is not found in the topology </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ae7eb635d229f25b3e6a41bfe5a3c0b" name="a5ae7eb635d229f25b3e6a41bfe5a3c0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ae7eb635d229f25b3e6a41bfe5a3c0b">&#9670;&#160;</a></span>setImplicitSolventModel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::topology::AtomGraph::setImplicitSolventModel </td>
          <td>(</td>
          <td class="paramtype">ImplicitSolventModel</td>          <td class="paramname"><span class="paramname"><em>igb_in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>dielectric_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">80.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>saltcon_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AtomicRadiusSet</td>          <td class="paramname"><span class="paramname"><em>radii_set</em></span><span class="paramdefsep"> = </span><span class="paramdefval">AtomicRadiusSet::NONE</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExceptionResponse</td>          <td class="paramname"><span class="paramname"><em>policy</em></span><span class="paramdefsep"> = </span><span class="paramdefval">ExceptionResponse::WARN</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the implicit solvent model. This will leverage a lot of hard-coded constants to fill out some allocated but otherwise blank arrays and impart one particular Generalized Born or other implicit solvent method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">igb_in</td><td>The implicit solvent model to impart onto the system </td></tr>
    <tr><td class="paramname">dielectric_in</td><td>The desired dielectric constant </td></tr>
    <tr><td class="paramname">saltcon_in</td><td>The intended salt concentration (affects the GB decay parameter Kappa) </td></tr>
    <tr><td class="paramname">radii_set</td><td>Radii to impart to the topology (this is often coupled to the choice of implicit solvent model, but for purposes of experimentation or new model development might be flexible) </td></tr>
    <tr><td class="paramname">policy</td><td>Indicator of what to do if the topology's PB radii to not meet the implicit solvent model requirements, or there is some other problem </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83d6d33332c2c585306bd6d41b2bf43d" name="a83d6d33332c2c585306bd6d41b2bf43d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83d6d33332c2c585306bd6d41b2bf43d">&#9670;&#160;</a></span>setUreyBradleyParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::topology::AtomGraph::setUreyBradleyParameters </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>new_keq</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>new_leq</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>set_keq</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>set_leq</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>parm_idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExceptionResponse</td>          <td class="paramname"><span class="paramname"><em>policy</em></span><span class="paramdefsep"> = </span><span class="paramdefval">ExceptionResponse::SILENT</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alter the parameters for a Urey-Bradley parameter set. </p>
<p>Overloaded:</p><ul>
<li>Accept the atom types for each atom in the Urey-Bradley term</li>
<li>Accept the parameter set index for the Urey-Bradley term</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_keq</td><td>The new stiffness constant to apply </td></tr>
    <tr><td class="paramname">new_leq</td><td>The new equilibrium constant to apply </td></tr>
    <tr><td class="paramname">set_keq</td><td>Whether to change the stiffness constant </td></tr>
    <tr><td class="paramname">set_leq</td><td>Whether to change the equilibrium </td></tr>
    <tr><td class="paramname">parm_idx</td><td>Index of the bond parameter set from within the topology's table (one cannot depend on this index to be consistent across topologies of different systems making use of the same force field) </td></tr>
    <tr><td class="paramname">type_a</td><td>Atom type of the first atom in the Urey-Bradley term, the I atom (this will be consistent across multiple topologies using the same force field) </td></tr>
    <tr><td class="paramname">type_b</td><td>Atom type of the second atom in the Urey-Bradley term (the K atom) </td></tr>
    <tr><td class="paramname">policy</td><td>Behavior if a Urey-Bradley parameter set matching the index or atom types is not found in the topology </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7920a17f5e926018671fd16335071cb7" name="a7920a17f5e926018671fd16335071cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7920a17f5e926018671fd16335071cb7">&#9670;&#160;</a></span>setWaterResidueName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::topology::AtomGraph::setWaterResidueName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstormm_1_1data__types_1_1char4.html">char4</a></td>          <td class="paramname"><span class="paramname"><em>new_name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the name of the water residue. </p>
<p>Overloaded:</p><ul>
<li>Set the name based on a <a class="el" href="structstormm_1_1char4.html">char4</a> (the native representation in the topology)</li>
<li>Set the name based on up to four characters from a string</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_name</td><td>The new water residue name to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a552d237e6cd50f46bcb7107611334ae8" name="a552d237e6cd50f46bcb7107611334ae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a552d237e6cd50f46bcb7107611334ae8">&#9670;&#160;</a></span>AtomGraphStage</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class AtomGraphStage</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allow the AtomGraphStage to access private members directly to modify and guide construction of topologies used in STORMM's production calculations. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/Topology/<a class="el" href="atomgraph_8h_source.html">atomgraph.h</a></li>
<li>src/Topology/<b>atomgraph_combination.cpp</b></li>
<li>src/Topology/<b>atomgraph_constructors.cpp</b></li>
<li>src/Topology/<b>atomgraph_detailers.cpp</b></li>
<li>src/Topology/<b>atomgraph_extraction.cpp</b></li>
<li>src/Topology/<b>atomgraph_getters.cpp</b></li>
<li>src/Topology/<b>atomgraph_miscellaneous.cpp</b></li>
<li>src/Topology/<b>atomgraph_setters.cpp</b></li>
<li>src/Topology/<b>atomgraph_writing.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2
</small></address>
</div><!-- doc-content -->
</body>
</html>
