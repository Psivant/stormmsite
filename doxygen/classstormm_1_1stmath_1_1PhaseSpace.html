<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>STORMM Source Documentation: stormm::stmath::PhaseSpace Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">STORMM Source Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>stormm</b></li><li class="navelem"><b>stmath</b></li><li class="navelem"><a class="el" href="classstormm_1_1stmath_1_1PhaseSpace.html">PhaseSpace</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classstormm_1_1stmath_1_1PhaseSpace-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">stormm::stmath::PhaseSpace Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>An object to complement a topology and hold positions, velocities, and forces of all particles in a system. This is not designed to be the most performant representation of the system's structure. Rather, it serves to hold a high-precision representation of a single system and transport it between CPUs and high-performance accelerators.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="phasespace_8h_source.html">phasespace.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac5214aa3cb13c820135e799b88e1d11d" id="r_ac5214aa3cb13c820135e799b88e1d11d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5214aa3cb13c820135e799b88e1d11d">PhaseSpace</a> (<a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html">PhaseSpace</a> &amp;&amp;original)</td></tr>
<tr class="memdesc:ac5214aa3cb13c820135e799b88e1d11d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The move constructor prepares the original <a class="el" href="classstormm_1_1stmath_1_1PhaseSpace.html" title="An object to complement a topology and hold positions, velocities, and forces of all particles in a s...">PhaseSpace</a> object for destruction.  <br /></td></tr>
<tr class="separator:ac5214aa3cb13c820135e799b88e1d11d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ffc0b5512385d5365242eb8b48e0a69" id="r_a8ffc0b5512385d5365242eb8b48e0a69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html">PhaseSpace</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ffc0b5512385d5365242eb8b48e0a69">operator=</a> (const <a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html">PhaseSpace</a> &amp;other)</td></tr>
<tr class="memdesc:a8ffc0b5512385d5365242eb8b48e0a69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator likewise handles assignment of internal POINTER-kind <a class="el" href="classstormm_1_1stmath_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> objects.  <br /></td></tr>
<tr class="separator:a8ffc0b5512385d5365242eb8b48e0a69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63198eeb645200ac1c90b3b465c6976c" id="r_a63198eeb645200ac1c90b3b465c6976c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html">PhaseSpace</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63198eeb645200ac1c90b3b465c6976c">operator=</a> (<a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html">PhaseSpace</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a63198eeb645200ac1c90b3b465c6976c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The move assignment operator looks much like the copy assignment operator.  <br /></td></tr>
<tr class="separator:a63198eeb645200ac1c90b3b465c6976c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab561b7d7d8a43240b3bf62d805627e89" id="r_ab561b7d7d8a43240b3bf62d805627e89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab561b7d7d8a43240b3bf62d805627e89">buildFromFile</a> (const std::string &amp;file_name_in, const CoordinateFileKind file_kind=CoordinateFileKind::UNKNOWN, int frame_number=0)</td></tr>
<tr class="memdesc:ab561b7d7d8a43240b3bf62d805627e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the object from information in some coordinate, restart, or trajectory file.  <br /></td></tr>
<tr class="separator:ab561b7d7d8a43240b3bf62d805627e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e11122dc31841e513f92b1efac3365b" id="r_a6e11122dc31841e513f92b1efac3365b"><td class="memItemLeft" align="right" valign="top"><a id="a6e11122dc31841e513f92b1efac3365b" name="a6e11122dc31841e513f92b1efac3365b"></a>
HybridFormat&#160;</td><td class="memItemRight" valign="bottom"><b>getFormat</b> () const</td></tr>
<tr class="memdesc:a6e11122dc31841e513f92b1efac3365b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classstormm_1_1stmath_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> format taken by the object, indicating on which resources its memory is present. <br /></td></tr>
<tr class="separator:a6e11122dc31841e513f92b1efac3365b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac76f0b61fea1707f8d3b296743680309" id="r_ac76f0b61fea1707f8d3b296743680309"><td class="memItemLeft" align="right" valign="top"><a id="ac76f0b61fea1707f8d3b296743680309" name="ac76f0b61fea1707f8d3b296743680309"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getFileName</b> () const</td></tr>
<tr class="memdesc:ac76f0b61fea1707f8d3b296743680309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the file associated with this object. <br /></td></tr>
<tr class="separator:ac76f0b61fea1707f8d3b296743680309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae943c7166f9f4a3880cba0e74af8bd08" id="r_ae943c7166f9f4a3880cba0e74af8bd08"><td class="memItemLeft" align="right" valign="top"><a id="ae943c7166f9f4a3880cba0e74af8bd08" name="ae943c7166f9f4a3880cba0e74af8bd08"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getAtomCount</b> () const</td></tr>
<tr class="memdesc:ae943c7166f9f4a3880cba0e74af8bd08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of atoms (particles, including virtual sites) in the object. <br /></td></tr>
<tr class="separator:ae943c7166f9f4a3880cba0e74af8bd08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a931b3917a76d93e32881b634cec9abcd" id="r_a931b3917a76d93e32881b634cec9abcd"><td class="memItemLeft" align="right" valign="top"><a id="a931b3917a76d93e32881b634cec9abcd" name="a931b3917a76d93e32881b634cec9abcd"></a>
UnitCellType&#160;</td><td class="memItemRight" valign="bottom"><b>getUnitCellType</b> () const</td></tr>
<tr class="memdesc:a931b3917a76d93e32881b634cec9abcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unit cell type of the coordinate system. <br /></td></tr>
<tr class="separator:a931b3917a76d93e32881b634cec9abcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac50a584249c2fcd031fc18ae864b9ef2" id="r_ac50a584249c2fcd031fc18ae864b9ef2"><td class="memItemLeft" align="right" valign="top"><a id="ac50a584249c2fcd031fc18ae864b9ef2" name="ac50a584249c2fcd031fc18ae864b9ef2"></a>
CoordinateCycle&#160;</td><td class="memItemRight" valign="bottom"><b>getCyclePosition</b> () const</td></tr>
<tr class="memdesc:ac50a584249c2fcd031fc18ae864b9ef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the time cycle stage indicating the arrays holding current coordinates. <br /></td></tr>
<tr class="separator:ac50a584249c2fcd031fc18ae864b9ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a1099939eec28419829fff64a0b6ba" id="r_a55a1099939eec28419829fff64a0b6ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55a1099939eec28419829fff64a0b6ba">exportToFile</a> (const std::string &amp;file_name, double current_time=0.0, TrajectoryKind traj_kind=TrajectoryKind::POSITIONS, CoordinateFileKind output_kind=CoordinateFileKind::AMBER_INPCRD, PrintSituation expectation=PrintSituation::UNKNOWN) const</td></tr>
<tr class="memdesc:a55a1099939eec28419829fff64a0b6ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the phase space data into a trajectory or checkpoint file.  <br /></td></tr>
<tr class="separator:a55a1099939eec28419829fff64a0b6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b574ecadcb82362b6c9d26fd020abf" id="r_ae8b574ecadcb82362b6c9d26fd020abf"><td class="memItemLeft" align="right" valign="top"><a id="ae8b574ecadcb82362b6c9d26fd020abf" name="ae8b574ecadcb82362b6c9d26fd020abf"></a>
const <a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html">PhaseSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getSelfPointer</b> () const</td></tr>
<tr class="memdesc:ae8b574ecadcb82362b6c9d26fd020abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the object itself (useful when the object has been passed as a const reference and a pointer is needed). <br /></td></tr>
<tr class="separator:ae8b574ecadcb82362b6c9d26fd020abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:adb455680e43b998deefc46f371b120a8" id="r_adb455680e43b998deefc46f371b120a8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb455680e43b998deefc46f371b120a8">PhaseSpace</a> (int atom_count_in=0, UnitCellType unit_cell_in=UnitCellType::NONE, HybridFormat format_in=default_hpc_format)</td></tr>
<tr class="memdesc:adb455680e43b998deefc46f371b120a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construction of a phase space object, like a topology, is typically done from a file.  <br /></td></tr>
<tr class="separator:adb455680e43b998deefc46f371b120a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba43316b214f3253e2380976eea9860" id="r_a0ba43316b214f3253e2380976eea9860"><td class="memItemLeft" align="right" valign="top"><a id="a0ba43316b214f3253e2380976eea9860" name="a0ba43316b214f3253e2380976eea9860"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PhaseSpace</b> (const std::string &amp;file_name_in, CoordinateFileKind file_kind=CoordinateFileKind::UNKNOWN, int frame_number=0, HybridFormat format_in=default_hpc_format)</td></tr>
<tr class="separator:a0ba43316b214f3253e2380976eea9860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bbab77a0288970cd21d448225b0b50f" id="r_a6bbab77a0288970cd21d448225b0b50f"><td class="memItemLeft" align="right" valign="top"><a id="a6bbab77a0288970cd21d448225b0b50f" name="a6bbab77a0288970cd21d448225b0b50f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PhaseSpace</b> (const std::string &amp;file_name_in, const AtomGraph &amp;ag, CoordinateFileKind file_kind=CoordinateFileKind::UNKNOWN, int frame_number=0, HybridFormat format_in=default_hpc_format)</td></tr>
<tr class="separator:a6bbab77a0288970cd21d448225b0b50f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac20545a8a2ec1df6bff9ebb361ecc4a9" id="r_ac20545a8a2ec1df6bff9ebb361ecc4a9"><td class="memItemLeft" align="right" valign="top"><a id="ac20545a8a2ec1df6bff9ebb361ecc4a9" name="ac20545a8a2ec1df6bff9ebb361ecc4a9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PhaseSpace</b> (const std::vector&lt; <a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html">PhaseSpace</a> * &gt; &amp;input_crd, const std::vector&lt; AtomGraph * &gt; &amp;input_top, const std::vector&lt; int &gt; &amp;counts)</td></tr>
<tr class="separator:ac20545a8a2ec1df6bff9ebb361ecc4a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adebab349a252c4bf1282381ee32dcefc" id="r_adebab349a252c4bf1282381ee32dcefc"><td class="memItemLeft" align="right" valign="top"><a id="adebab349a252c4bf1282381ee32dcefc" name="adebab349a252c4bf1282381ee32dcefc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PhaseSpace</b> (const <a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html">PhaseSpace</a> *ps_a, const AtomGraph *ag_a, const <a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html">PhaseSpace</a> *ps_b, const AtomGraph *ag_b)</td></tr>
<tr class="separator:adebab349a252c4bf1282381ee32dcefc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8235f10f001818fb5eb1bcaf8312652" id="r_af8235f10f001818fb5eb1bcaf8312652"><td class="memItemLeft" align="right" valign="top"><a id="af8235f10f001818fb5eb1bcaf8312652" name="af8235f10f001818fb5eb1bcaf8312652"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PhaseSpace</b> (const <a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html">PhaseSpace</a> &amp;ps_a, const AtomGraph &amp;ag_a, const <a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html">PhaseSpace</a> &amp;ps_b, const AtomGraph &amp;ag_b)</td></tr>
<tr class="separator:af8235f10f001818fb5eb1bcaf8312652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a223216a44c4f273a746542b190af63ab" id="r_a223216a44c4f273a746542b190af63ab"><td class="memItemLeft" align="right" valign="top"><a id="a223216a44c4f273a746542b190af63ab" name="a223216a44c4f273a746542b190af63ab"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PhaseSpace</b> (const <a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html">PhaseSpace</a> &amp;original, const std::vector&lt; int &gt; &amp;atom_list, HybridFormat format_in=default_hpc_format)</td></tr>
<tr class="separator:a223216a44c4f273a746542b190af63ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d4f2769d0e3580c08d7aa220e991f7a" id="r_a5d4f2769d0e3580c08d7aa220e991f7a"><td class="memItemLeft" align="right" valign="top"><a id="a5d4f2769d0e3580c08d7aa220e991f7a" name="a5d4f2769d0e3580c08d7aa220e991f7a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PhaseSpace</b> (const <a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html">PhaseSpace</a> &amp;original, const std::vector&lt; uint &gt; &amp;mask, HybridFormat format_in=default_hpc_format)</td></tr>
<tr class="separator:a5d4f2769d0e3580c08d7aa220e991f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a92b6cd527eceba95aaab49c6a6a8199c" id="r_a92b6cd527eceba95aaab49c6a6a8199c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92b6cd527eceba95aaab49c6a6a8199c">PhaseSpace</a> (const <a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html">PhaseSpace</a> &amp;original)</td></tr>
<tr class="memdesc:a92b6cd527eceba95aaab49c6a6a8199c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The copy constructor handles assignment of internal POINTER-kind <a class="el" href="classstormm_1_1stmath_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> objects.  <br /></td></tr>
<tr class="separator:a92b6cd527eceba95aaab49c6a6a8199c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a48f172126bf1857e0030b49b6410e" id="r_a30a48f172126bf1857e0030b49b6410e"><td class="memItemLeft" align="right" valign="top"><a id="a30a48f172126bf1857e0030b49b6410e" name="a30a48f172126bf1857e0030b49b6410e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PhaseSpace</b> (const <a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html">PhaseSpace</a> &amp;original, HybridFormat format_in)</td></tr>
<tr class="separator:a30a48f172126bf1857e0030b49b6410e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:adf3a8fc51583dfcf2b2eeaf25bbfcad7" id="r_adf3a8fc51583dfcf2b2eeaf25bbfcad7"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:adf3a8fc51583dfcf2b2eeaf25bbfcad7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adf3a8fc51583dfcf2b2eeaf25bbfcad7">fill</a> (const T *xcrd, const T *ycrd, const T *zcrd, TrajectoryKind kind=TrajectoryKind::POSITIONS, CoordinateCycle cycle_in=CoordinateCycle::WHITE, int scale_bits=0, const double *box_dims=nullptr)</td></tr>
<tr class="memdesc:adf3a8fc51583dfcf2b2eeaf25bbfcad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the object from information in three arrays.  <br /></td></tr>
<tr class="separator:adf3a8fc51583dfcf2b2eeaf25bbfcad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc09867563050ce8fe5e65311dd2e6d6" id="r_adc09867563050ce8fe5e65311dd2e6d6"><td class="memTemplParams" colspan="2"><a id="adc09867563050ce8fe5e65311dd2e6d6" name="adc09867563050ce8fe5e65311dd2e6d6"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:adc09867563050ce8fe5e65311dd2e6d6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fill</b> (const std::vector&lt; T &gt; &amp;xcrd, const std::vector&lt; T &gt; &amp;ycrd, const std::vector&lt; T &gt; &amp;zcrd, TrajectoryKind kind=TrajectoryKind::POSITIONS, CoordinateCycle cycle_in=CoordinateCycle::WHITE, int scale_bits=0, const std::vector&lt; double &gt; &amp;box_dims={})</td></tr>
<tr class="separator:adc09867563050ce8fe5e65311dd2e6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a19c2366a5bc2691a2eec6b68874de49e" id="r_a19c2366a5bc2691a2eec6b68874de49e"><td class="memItemLeft" align="right" valign="top">const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19c2366a5bc2691a2eec6b68874de49e">getCoordinatePointer</a> (CartesianDimension dim, TrajectoryKind kind, CoordinateCycle orientation, HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:a19c2366a5bc2691a2eec6b68874de49e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the particle X, Y, or Z coordinates, velocities, or forces, on either the host or device. Use this when the entire abstract is unnecessary or would be inefficient to retrieve.  <br /></td></tr>
<tr class="separator:a19c2366a5bc2691a2eec6b68874de49e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a236cb511532fbbbd477ae1e8acbcf771" id="r_a236cb511532fbbbd477ae1e8acbcf771"><td class="memItemLeft" align="right" valign="top"><a id="a236cb511532fbbbd477ae1e8acbcf771" name="a236cb511532fbbbd477ae1e8acbcf771"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><b>getCoordinatePointer</b> (CartesianDimension dim, TrajectoryKind kind, CoordinateCycle orientation, HybridTargetLevel tier=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:a236cb511532fbbbd477ae1e8acbcf771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e5a8b03c8f1e96c218b25da1d30860" id="r_a02e5a8b03c8f1e96c218b25da1d30860"><td class="memItemLeft" align="right" valign="top"><a id="a02e5a8b03c8f1e96c218b25da1d30860" name="a02e5a8b03c8f1e96c218b25da1d30860"></a>
const double *&#160;</td><td class="memItemRight" valign="bottom"><b>getCoordinatePointer</b> (CartesianDimension dim, TrajectoryKind kind=TrajectoryKind::POSITIONS, HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="separator:a02e5a8b03c8f1e96c218b25da1d30860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9491c9167998af05f6c3325cb50b19c1" id="r_a9491c9167998af05f6c3325cb50b19c1"><td class="memItemLeft" align="right" valign="top"><a id="a9491c9167998af05f6c3325cb50b19c1" name="a9491c9167998af05f6c3325cb50b19c1"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><b>getCoordinatePointer</b> (CartesianDimension dim, TrajectoryKind kind=TrajectoryKind::POSITIONS, HybridTargetLevel tier=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:a9491c9167998af05f6c3325cb50b19c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5cae395a4acd49cfb7fdfd3823a3979" id="r_ae5cae395a4acd49cfb7fdfd3823a3979"><td class="memItemLeft" align="right" valign="top"><a id="ae5cae395a4acd49cfb7fdfd3823a3979" name="ae5cae395a4acd49cfb7fdfd3823a3979"></a>
const double *&#160;</td><td class="memItemRight" valign="bottom"><b>getCoordinatePointer</b> (CartesianDimension dim, CoordinateCycle orientation, HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="separator:ae5cae395a4acd49cfb7fdfd3823a3979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f37f3838f96324199535db7cbe31da4" id="r_a5f37f3838f96324199535db7cbe31da4"><td class="memItemLeft" align="right" valign="top"><a id="a5f37f3838f96324199535db7cbe31da4" name="a5f37f3838f96324199535db7cbe31da4"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><b>getCoordinatePointer</b> (CartesianDimension dim, CoordinateCycle orientation, HybridTargetLevel tier=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:a5f37f3838f96324199535db7cbe31da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a8278fe07fd8ac7c5136021c19d791cea" id="r_a8278fe07fd8ac7c5136021c19d791cea"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8278fe07fd8ac7c5136021c19d791cea">getInterlacedCoordinates</a> (TrajectoryKind kind=TrajectoryKind::POSITIONS, HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:a8278fe07fd8ac7c5136021c19d791cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the coordinates returned in an X/Y/Z interlaced manner.  <br /></td></tr>
<tr class="separator:a8278fe07fd8ac7c5136021c19d791cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf2baba1e0ad60a4fa1fd68988d22c5a" id="r_acf2baba1e0ad60a4fa1fd68988d22c5a"><td class="memItemLeft" align="right" valign="top"><a id="acf2baba1e0ad60a4fa1fd68988d22c5a" name="acf2baba1e0ad60a4fa1fd68988d22c5a"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getInterlacedCoordinates</b> (CoordinateCycle orientation, TrajectoryKind kind=TrajectoryKind::POSITIONS, HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="separator:acf2baba1e0ad60a4fa1fd68988d22c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adadc153b6849d59bd90d40936e4dd57c" id="r_adadc153b6849d59bd90d40936e4dd57c"><td class="memItemLeft" align="right" valign="top"><a id="adadc153b6849d59bd90d40936e4dd57c" name="adadc153b6849d59bd90d40936e4dd57c"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getInterlacedCoordinates</b> (int low_index, int high_index, TrajectoryKind kind=TrajectoryKind::POSITIONS, HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="separator:adadc153b6849d59bd90d40936e4dd57c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a7635f72ec14e42934de56a38adfb8" id="r_ae3a7635f72ec14e42934de56a38adfb8"><td class="memItemLeft" align="right" valign="top"><a id="ae3a7635f72ec14e42934de56a38adfb8" name="ae3a7635f72ec14e42934de56a38adfb8"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getInterlacedCoordinates</b> (int low_index, int high_index, CoordinateCycle orientation, TrajectoryKind kind=TrajectoryKind::POSITIONS, HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="separator:ae3a7635f72ec14e42934de56a38adfb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a96704b639d575c3e70f1e0df578bf0b9" id="r_a96704b639d575c3e70f1e0df578bf0b9"><td class="memItemLeft" align="right" valign="top">const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96704b639d575c3e70f1e0df578bf0b9">getBoxSpaceTransformPointer</a> (CoordinateCycle orientation, HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:a96704b639d575c3e70f1e0df578bf0b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the box space transformation matrix that can track its evolution in the <a class="el" href="classstormm_1_1stmath_1_1PhaseSpace.html" title="An object to complement a topology and hold positions, velocities, and forces of all particles in a s...">PhaseSpace</a> object's <a class="el" href="classstormm_1_1stmath_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> data arrays, on either the host or device.  <br /></td></tr>
<tr class="separator:a96704b639d575c3e70f1e0df578bf0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ef7fbbc708c6d6e010d76fdb00d8ad" id="r_aa2ef7fbbc708c6d6e010d76fdb00d8ad"><td class="memItemLeft" align="right" valign="top"><a id="aa2ef7fbbc708c6d6e010d76fdb00d8ad" name="aa2ef7fbbc708c6d6e010d76fdb00d8ad"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><b>getBoxSpaceTransformPointer</b> (CoordinateCycle orientation, HybridTargetLevel tier=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:aa2ef7fbbc708c6d6e010d76fdb00d8ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d1d4a52fc8bdad541aac63255a65849" id="r_a2d1d4a52fc8bdad541aac63255a65849"><td class="memItemLeft" align="right" valign="top"><a id="a2d1d4a52fc8bdad541aac63255a65849" name="a2d1d4a52fc8bdad541aac63255a65849"></a>
const double *&#160;</td><td class="memItemRight" valign="bottom"><b>getBoxSpaceTransformPointer</b> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="separator:a2d1d4a52fc8bdad541aac63255a65849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a430597c70f59ac636eee1497ddb32dda" id="r_a430597c70f59ac636eee1497ddb32dda"><td class="memItemLeft" align="right" valign="top"><a id="a430597c70f59ac636eee1497ddb32dda" name="a430597c70f59ac636eee1497ddb32dda"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><b>getBoxSpaceTransformPointer</b> (HybridTargetLevel tier=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:a430597c70f59ac636eee1497ddb32dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa5104f96072e693b9ee668b3681ec1be" id="r_aa5104f96072e693b9ee668b3681ec1be"><td class="memItemLeft" align="right" valign="top">const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5104f96072e693b9ee668b3681ec1be">getInverseTransformPointer</a> (CoordinateCycle orientation, HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:aa5104f96072e693b9ee668b3681ec1be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the inverse (back to real space) transformation matrix that can track its evolution in the <a class="el" href="classstormm_1_1stmath_1_1PhaseSpace.html" title="An object to complement a topology and hold positions, velocities, and forces of all particles in a s...">PhaseSpace</a> object's <a class="el" href="classstormm_1_1stmath_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> data arrays, on either the host or device.  <br /></td></tr>
<tr class="separator:aa5104f96072e693b9ee668b3681ec1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d67f5f65225746d85aa53464d7ae261" id="r_a0d67f5f65225746d85aa53464d7ae261"><td class="memItemLeft" align="right" valign="top"><a id="a0d67f5f65225746d85aa53464d7ae261" name="a0d67f5f65225746d85aa53464d7ae261"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><b>getInverseTransformPointer</b> (CoordinateCycle orientation, HybridTargetLevel tier=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:a0d67f5f65225746d85aa53464d7ae261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85121eda50b8c36b7d448963e1c9bf7d" id="r_a85121eda50b8c36b7d448963e1c9bf7d"><td class="memItemLeft" align="right" valign="top"><a id="a85121eda50b8c36b7d448963e1c9bf7d" name="a85121eda50b8c36b7d448963e1c9bf7d"></a>
const double *&#160;</td><td class="memItemRight" valign="bottom"><b>getInverseTransformPointer</b> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="separator:a85121eda50b8c36b7d448963e1c9bf7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed9d6decdcc5720fb227d60c3b37085" id="r_a0ed9d6decdcc5720fb227d60c3b37085"><td class="memItemLeft" align="right" valign="top"><a id="a0ed9d6decdcc5720fb227d60c3b37085" name="a0ed9d6decdcc5720fb227d60c3b37085"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><b>getInverseTransformPointer</b> (HybridTargetLevel tier=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:a0ed9d6decdcc5720fb227d60c3b37085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1d8bf8c0d2d996f79d17dd8a8af20361" id="r_a1d8bf8c0d2d996f79d17dd8a8af20361"><td class="memItemLeft" align="right" valign="top">const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d8bf8c0d2d996f79d17dd8a8af20361">getBoxSizePointer</a> (CoordinateCycle orientation, HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:a1d8bf8c0d2d996f79d17dd8a8af20361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the box dimensions that can track its evolution in the <a class="el" href="classstormm_1_1stmath_1_1PhaseSpace.html" title="An object to complement a topology and hold positions, velocities, and forces of all particles in a s...">PhaseSpace</a> object's <a class="el" href="classstormm_1_1stmath_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> data arrays, on either the host or device.  <br /></td></tr>
<tr class="separator:a1d8bf8c0d2d996f79d17dd8a8af20361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a360f797788efc90ef8d0c98f150afaf3" id="r_a360f797788efc90ef8d0c98f150afaf3"><td class="memItemLeft" align="right" valign="top"><a id="a360f797788efc90ef8d0c98f150afaf3" name="a360f797788efc90ef8d0c98f150afaf3"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><b>getBoxSizePointer</b> (CoordinateCycle orientation, HybridTargetLevel tier=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:a360f797788efc90ef8d0c98f150afaf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa454e251b796dff5822e509b9968a4a0" id="r_aa454e251b796dff5822e509b9968a4a0"><td class="memItemLeft" align="right" valign="top"><a id="aa454e251b796dff5822e509b9968a4a0" name="aa454e251b796dff5822e509b9968a4a0"></a>
const double *&#160;</td><td class="memItemRight" valign="bottom"><b>getBoxSizePointer</b> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="separator:aa454e251b796dff5822e509b9968a4a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae62c95be3db0488265bb9e7e30b1b95" id="r_aae62c95be3db0488265bb9e7e30b1b95"><td class="memItemLeft" align="right" valign="top"><a id="aae62c95be3db0488265bb9e7e30b1b95" name="aae62c95be3db0488265bb9e7e30b1b95"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><b>getBoxSizePointer</b> (HybridTargetLevel tier=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:aae62c95be3db0488265bb9e7e30b1b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aea00e86a55ac783f62fc08c08910bb56" id="r_aea00e86a55ac783f62fc08c08910bb56"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea00e86a55ac783f62fc08c08910bb56">getBoxSpaceTransform</a> (CoordinateCycle orientation, HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:aea00e86a55ac783f62fc08c08910bb56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the transformation matrix to take coordinates into box (fractional) space. The result should be interpreted as a 3x3 matrix in column-major format.  <br /></td></tr>
<tr class="separator:aea00e86a55ac783f62fc08c08910bb56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5341888f82a2a94097ff8aaec28c085" id="r_af5341888f82a2a94097ff8aaec28c085"><td class="memItemLeft" align="right" valign="top"><a id="af5341888f82a2a94097ff8aaec28c085" name="af5341888f82a2a94097ff8aaec28c085"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getBoxSpaceTransform</b> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="separator:af5341888f82a2a94097ff8aaec28c085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4677e1af1e9dac1bc18d5e43abb4a314" id="r_a4677e1af1e9dac1bc18d5e43abb4a314"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4677e1af1e9dac1bc18d5e43abb4a314">getInverseTransform</a> (CoordinateCycle orientation, HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:a4677e1af1e9dac1bc18d5e43abb4a314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the transformation matrix to take coordinates from fractional space back into real space. The result should be interpreted as a 3x3 matrix in column-major format.  <br /></td></tr>
<tr class="separator:a4677e1af1e9dac1bc18d5e43abb4a314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b057eb274484264bee76850f94447ee" id="r_a4b057eb274484264bee76850f94447ee"><td class="memItemLeft" align="right" valign="top"><a id="a4b057eb274484264bee76850f94447ee" name="a4b057eb274484264bee76850f94447ee"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getInverseTransform</b> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="separator:a4b057eb274484264bee76850f94447ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a8e1b8cfb54f60bf17f41ba872904de06" id="r_a8e1b8cfb54f60bf17f41ba872904de06"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; double &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e1b8cfb54f60bf17f41ba872904de06">getCoordinateHandle</a> (CartesianDimension dim, TrajectoryKind kind, CoordinateCycle orientation) const</td></tr>
<tr class="memdesc:a8e1b8cfb54f60bf17f41ba872904de06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to one of the coordinate arrays, a pointer to a POINTER-kind <a class="el" href="classstormm_1_1stmath_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> object.  <br /></td></tr>
<tr class="separator:a8e1b8cfb54f60bf17f41ba872904de06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913a09e822781c90a0aa495e116976d8" id="r_a913a09e822781c90a0aa495e116976d8"><td class="memItemLeft" align="right" valign="top"><a id="a913a09e822781c90a0aa495e116976d8" name="a913a09e822781c90a0aa495e116976d8"></a>
const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; double &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>getCoordinateHandle</b> (CartesianDimension dim, TrajectoryKind kind=TrajectoryKind::POSITIONS) const</td></tr>
<tr class="separator:a913a09e822781c90a0aa495e116976d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe67d167866e6cde89cc0f099661b6da" id="r_abe67d167866e6cde89cc0f099661b6da"><td class="memItemLeft" align="right" valign="top"><a id="abe67d167866e6cde89cc0f099661b6da" name="abe67d167866e6cde89cc0f099661b6da"></a>
<a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; double &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>getCoordinateHandle</b> (CartesianDimension dim, TrajectoryKind kind, CoordinateCycle orientation)</td></tr>
<tr class="separator:abe67d167866e6cde89cc0f099661b6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f623db351e2ffc51a731b869e9f8e0" id="r_a37f623db351e2ffc51a731b869e9f8e0"><td class="memItemLeft" align="right" valign="top"><a id="a37f623db351e2ffc51a731b869e9f8e0" name="a37f623db351e2ffc51a731b869e9f8e0"></a>
<a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; double &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>getCoordinateHandle</b> (CartesianDimension dim, TrajectoryKind kind=TrajectoryKind::POSITIONS)</td></tr>
<tr class="separator:a37f623db351e2ffc51a731b869e9f8e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae0f650c9e842b91a69a685c8bfb82e00" id="r_ae0f650c9e842b91a69a685c8bfb82e00"><td class="memItemLeft" align="right" valign="top"><a id="ae0f650c9e842b91a69a685c8bfb82e00" name="ae0f650c9e842b91a69a685c8bfb82e00"></a>
const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; double &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>getBoxTransformHandle</b> (CoordinateCycle orientation) const</td></tr>
<tr class="memdesc:ae0f650c9e842b91a69a685c8bfb82e00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the box space transform. Overloading follows from <a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html#a8e1b8cfb54f60bf17f41ba872904de06" title="Get a pointer to one of the coordinate arrays, a pointer to a POINTER-kind Hybrid object.">getCoordinateHandle()</a>, above. <br /></td></tr>
<tr class="separator:ae0f650c9e842b91a69a685c8bfb82e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a632df74ffb9d97dce03382b67c02f2cc" id="r_a632df74ffb9d97dce03382b67c02f2cc"><td class="memItemLeft" align="right" valign="top"><a id="a632df74ffb9d97dce03382b67c02f2cc" name="a632df74ffb9d97dce03382b67c02f2cc"></a>
const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; double &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>getBoxTransformHandle</b> () const</td></tr>
<tr class="separator:a632df74ffb9d97dce03382b67c02f2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8610ca584b6463d7fc68dad3f6289c9" id="r_ac8610ca584b6463d7fc68dad3f6289c9"><td class="memItemLeft" align="right" valign="top"><a id="ac8610ca584b6463d7fc68dad3f6289c9" name="ac8610ca584b6463d7fc68dad3f6289c9"></a>
<a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; double &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>getBoxTransformHandle</b> (CoordinateCycle orientation)</td></tr>
<tr class="separator:ac8610ca584b6463d7fc68dad3f6289c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a0c71d77df126cf8c0350b2f59a757" id="r_af8a0c71d77df126cf8c0350b2f59a757"><td class="memItemLeft" align="right" valign="top"><a id="af8a0c71d77df126cf8c0350b2f59a757" name="af8a0c71d77df126cf8c0350b2f59a757"></a>
<a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; double &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>getBoxTransformHandle</b> ()</td></tr>
<tr class="separator:af8a0c71d77df126cf8c0350b2f59a757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a18fbaea499918f73a6e90e843e9e92d3" id="r_a18fbaea499918f73a6e90e843e9e92d3"><td class="memItemLeft" align="right" valign="top"><a id="a18fbaea499918f73a6e90e843e9e92d3" name="a18fbaea499918f73a6e90e843e9e92d3"></a>
const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; double &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>getInverseTransformHandle</b> (CoordinateCycle orientation) const</td></tr>
<tr class="memdesc:a18fbaea499918f73a6e90e843e9e92d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the inverse transform that takes coordinates back into real space. Overloading follows from <a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html#a8e1b8cfb54f60bf17f41ba872904de06" title="Get a pointer to one of the coordinate arrays, a pointer to a POINTER-kind Hybrid object.">getCoordinateHandle()</a>, above. <br /></td></tr>
<tr class="separator:a18fbaea499918f73a6e90e843e9e92d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc904a4e7b6494530918851dac8a5974" id="r_abc904a4e7b6494530918851dac8a5974"><td class="memItemLeft" align="right" valign="top"><a id="abc904a4e7b6494530918851dac8a5974" name="abc904a4e7b6494530918851dac8a5974"></a>
const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; double &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>getInverseTransformHandle</b> () const</td></tr>
<tr class="separator:abc904a4e7b6494530918851dac8a5974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adadcfc11960b43417cb2a9b77d13507d" id="r_adadcfc11960b43417cb2a9b77d13507d"><td class="memItemLeft" align="right" valign="top"><a id="adadcfc11960b43417cb2a9b77d13507d" name="adadcfc11960b43417cb2a9b77d13507d"></a>
<a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; double &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>getInverseTransformHandle</b> (CoordinateCycle orientation)</td></tr>
<tr class="separator:adadcfc11960b43417cb2a9b77d13507d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37df2f25832a3fae3a123c662896b3d" id="r_ae37df2f25832a3fae3a123c662896b3d"><td class="memItemLeft" align="right" valign="top"><a id="ae37df2f25832a3fae3a123c662896b3d" name="ae37df2f25832a3fae3a123c662896b3d"></a>
<a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; double &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>getInverseTransformHandle</b> ()</td></tr>
<tr class="separator:ae37df2f25832a3fae3a123c662896b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a8e485b65591ab961e1ddc2df429cedba" id="r_a8e485b65591ab961e1ddc2df429cedba"><td class="memItemLeft" align="right" valign="top"><a id="a8e485b65591ab961e1ddc2df429cedba" name="a8e485b65591ab961e1ddc2df429cedba"></a>
const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; double &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>getBoxDimensionsHandle</b> (CoordinateCycle orientation) const</td></tr>
<tr class="memdesc:a8e485b65591ab961e1ddc2df429cedba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the transform that takes coordinates back into real space. Overloading follows from <a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html#a8e1b8cfb54f60bf17f41ba872904de06" title="Get a pointer to one of the coordinate arrays, a pointer to a POINTER-kind Hybrid object.">getCoordinateHandle()</a>, above. <br /></td></tr>
<tr class="separator:a8e485b65591ab961e1ddc2df429cedba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ac2011dac12a2ecb700ba9590cb083" id="r_a53ac2011dac12a2ecb700ba9590cb083"><td class="memItemLeft" align="right" valign="top"><a id="a53ac2011dac12a2ecb700ba9590cb083" name="a53ac2011dac12a2ecb700ba9590cb083"></a>
const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; double &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>getBoxDimensionsHandle</b> () const</td></tr>
<tr class="separator:a53ac2011dac12a2ecb700ba9590cb083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b84b0d7e8d6d6785930764cb4178516" id="r_a9b84b0d7e8d6d6785930764cb4178516"><td class="memItemLeft" align="right" valign="top"><a id="a9b84b0d7e8d6d6785930764cb4178516" name="a9b84b0d7e8d6d6785930764cb4178516"></a>
<a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; double &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>getBoxDimensionsHandle</b> (CoordinateCycle orientation)</td></tr>
<tr class="separator:a9b84b0d7e8d6d6785930764cb4178516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae07d4af247c7e6651a56bba8e154a232" id="r_ae07d4af247c7e6651a56bba8e154a232"><td class="memItemLeft" align="right" valign="top"><a id="ae07d4af247c7e6651a56bba8e154a232" name="ae07d4af247c7e6651a56bba8e154a232"></a>
<a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; double &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>getBoxDimensionsHandle</b> ()</td></tr>
<tr class="separator:ae07d4af247c7e6651a56bba8e154a232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4047f0cc2c19e5d9687d1ff0d272b0af" id="r_a4047f0cc2c19e5d9687d1ff0d272b0af"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; double &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4047f0cc2c19e5d9687d1ff0d272b0af">getStorageHandle</a> () const</td></tr>
<tr class="memdesc:a4047f0cc2c19e5d9687d1ff0d272b0af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the ARRAY-kind <a class="el" href="classstormm_1_1stmath_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> object that holds the actual data. Needed by <a class="el" href="classstormm_1_1stmath_1_1CoordinateFrame.html" title="Store the coordinates and box information for a frame, only. This abridged struct can serve when the ...">CoordinateFrame</a> objects which want to be pointers into a <a class="el" href="classstormm_1_1stmath_1_1PhaseSpace.html" title="An object to complement a topology and hold positions, velocities, and forces of all particles in a s...">PhaseSpace</a> object.  <br /></td></tr>
<tr class="separator:a4047f0cc2c19e5d9687d1ff0d272b0af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28c90dcf43ba813c14023266fc1fa654" id="r_a28c90dcf43ba813c14023266fc1fa654"><td class="memItemLeft" align="right" valign="top"><a id="a28c90dcf43ba813c14023266fc1fa654" name="a28c90dcf43ba813c14023266fc1fa654"></a>
<a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; double &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>getStorageHandle</b> ()</td></tr>
<tr class="separator:a28c90dcf43ba813c14023266fc1fa654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0c8e13c38b0b023302ce4f28a5778cb5" id="r_a0c8e13c38b0b023302ce4f28a5778cb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c8e13c38b0b023302ce4f28a5778cb5">initializeForces</a> (CoordinateCycle orientation)</td></tr>
<tr class="memdesc:a0c8e13c38b0b023302ce4f28a5778cb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the forces (set them to zero)  <br /></td></tr>
<tr class="separator:a0c8e13c38b0b023302ce4f28a5778cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1169c8a4de0d5891feeff039f5950eb" id="r_ae1169c8a4de0d5891feeff039f5950eb"><td class="memItemLeft" align="right" valign="top"><a id="ae1169c8a4de0d5891feeff039f5950eb" name="ae1169c8a4de0d5891feeff039f5950eb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>initializeForces</b> ()</td></tr>
<tr class="separator:ae1169c8a4de0d5891feeff039f5950eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad983dc270429206162c46bbf2f6e65df" id="r_ad983dc270429206162c46bbf2f6e65df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad983dc270429206162c46bbf2f6e65df">updateCyclePosition</a> ()</td></tr>
<tr class="memdesc:ad983dc270429206162c46bbf2f6e65df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the cycle position.  <br /></td></tr>
<tr class="separator:ad983dc270429206162c46bbf2f6e65df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d38520726e642c70ddf8427d00680e" id="r_aa8d38520726e642c70ddf8427d00680e"><td class="memItemLeft" align="right" valign="top"><a id="aa8d38520726e642c70ddf8427d00680e" name="aa8d38520726e642c70ddf8427d00680e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>updateCyclePosition</b> (CoordinateCycle time_point)</td></tr>
<tr class="separator:aa8d38520726e642c70ddf8427d00680e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad2779d7735416fdde3d35a3a3de5cd3d" id="r_ad2779d7735416fdde3d35a3a3de5cd3d"><td class="memItemLeft" align="right" valign="top">const PhaseSpaceReader&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2779d7735416fdde3d35a3a3de5cd3d">data</a> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:ad2779d7735416fdde3d35a3a3de5cd3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the abstract for this object, containing C-style pointers for the most rapid access to any of its member variables.  <br /></td></tr>
<tr class="separator:ad2779d7735416fdde3d35a3a3de5cd3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26fee17bc4cbd35beb1e975cc06d3c56" id="r_a26fee17bc4cbd35beb1e975cc06d3c56"><td class="memItemLeft" align="right" valign="top"><a id="a26fee17bc4cbd35beb1e975cc06d3c56" name="a26fee17bc4cbd35beb1e975cc06d3c56"></a>
const PhaseSpaceReader&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> (CoordinateCycle orientation, HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="separator:a26fee17bc4cbd35beb1e975cc06d3c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8da21a950b7cd2c49f5067460a36973" id="r_ad8da21a950b7cd2c49f5067460a36973"><td class="memItemLeft" align="right" valign="top"><a id="ad8da21a950b7cd2c49f5067460a36973" name="ad8da21a950b7cd2c49f5067460a36973"></a>
PhaseSpaceWriter&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> (HybridTargetLevel tier=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:ad8da21a950b7cd2c49f5067460a36973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b04fd9951b9b4d9dcb012eac76c83f" id="r_a82b04fd9951b9b4d9dcb012eac76c83f"><td class="memItemLeft" align="right" valign="top"><a id="a82b04fd9951b9b4d9dcb012eac76c83f" name="a82b04fd9951b9b4d9dcb012eac76c83f"></a>
PhaseSpaceWriter&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> (CoordinateCycle orientation, HybridTargetLevel tier=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:a82b04fd9951b9b4d9dcb012eac76c83f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An object to complement a topology and hold positions, velocities, and forces of all particles in a system. This is not designed to be the most performant representation of the system's structure. Rather, it serves to hold a high-precision representation of a single system and transport it between CPUs and high-performance accelerators. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="adb455680e43b998deefc46f371b120a8" name="adb455680e43b998deefc46f371b120a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb455680e43b998deefc46f371b120a8">&#9670;&#160;</a></span>PhaseSpace() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">stormm::trajectory::PhaseSpace::PhaseSpace </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>atom_count_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnitCellType</td>          <td class="paramname"><span class="paramname"><em>unit_cell_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">UnitCellType::NONE</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HybridFormat</td>          <td class="paramname"><span class="paramname"><em>format_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">default_hpc_format</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construction of a phase space object, like a topology, is typically done from a file. </p>
<p>Overloaded:</p><ul>
<li>Constructor fot an object with a number of atoms but no other information (assists in delegation of initialization)</li>
<li>Constructors for coordinate sets read from trajectory or restart files, with the option of a specific frame number (if unspecified, the first frame is read). A topology may also be specified to check the atom count and sanity of the coordinates presented.</li>
<li>Constructors for combining <a class="el" href="classstormm_1_1stmath_1_1PhaseSpace.html" title="An object to complement a topology and hold positions, velocities, and forces of all particles in a s...">PhaseSpace</a> objects from multiple existing objects</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_name</td><td>Name of the file from which to obtain coordinates </td></tr>
    <tr><td class="paramname">file_kind</td><td>The type of coordinate-containing input file </td></tr>
    <tr><td class="paramname">ag_reference</td><td>Topology with which to check atom count, proximity of bonded atoms, and sanity of bond angles (optional) </td></tr>
    <tr><td class="paramname">caller</td><td>Name of the calling function (to help backtrace errors) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92b6cd527eceba95aaab49c6a6a8199c" name="a92b6cd527eceba95aaab49c6a6a8199c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92b6cd527eceba95aaab49c6a6a8199c">&#9670;&#160;</a></span>PhaseSpace() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">stormm::trajectory::PhaseSpace::PhaseSpace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html">PhaseSpace</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>original</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The copy constructor handles assignment of internal POINTER-kind <a class="el" href="classstormm_1_1stmath_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> objects. </p>
<p>Overloaded:</p><ul>
<li>Take the original object's memory layout</li>
<li>Apply an alternate memory layout. The content will be determined by whatever content is available in the original object at each tier of memory: if the new object is to have a memory component on the GPU device and the original object also has a memory component on the GPU, then this is the state that will be copied over. Otherwise, the original object's data from the CPU host will become the new object's GPU component. This priority of "copy data from what exists at the same level, otherwise take from the other
    level" applies everywhere.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">original</td><td>The <a class="el" href="classstormm_1_1stmath_1_1PhaseSpace.html" title="An object to complement a topology and hold positions, velocities, and forces of all particles in a s...">PhaseSpace</a> object from which to make a deep copy </td></tr>
    <tr><td class="paramname">format_in</td><td>An alternate memory format in which to lay out the new <a class="el" href="classstormm_1_1stmath_1_1CoordinateFrame.html" title="Store the coordinates and box information for a frame, only. This abridged struct can serve when the ...">CoordinateFrame</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5214aa3cb13c820135e799b88e1d11d" name="ac5214aa3cb13c820135e799b88e1d11d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5214aa3cb13c820135e799b88e1d11d">&#9670;&#160;</a></span>PhaseSpace() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">stormm::trajectory::PhaseSpace::PhaseSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html">PhaseSpace</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>original</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The move constructor prepares the original <a class="el" href="classstormm_1_1stmath_1_1PhaseSpace.html" title="An object to complement a topology and hold positions, velocities, and forces of all particles in a s...">PhaseSpace</a> object for destruction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">original</td><td>The <a class="el" href="classstormm_1_1stmath_1_1PhaseSpace.html" title="An object to complement a topology and hold positions, velocities, and forces of all particles in a s...">PhaseSpace</a> object from which to preserve content </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab561b7d7d8a43240b3bf62d805627e89" name="ab561b7d7d8a43240b3bf62d805627e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab561b7d7d8a43240b3bf62d805627e89">&#9670;&#160;</a></span>buildFromFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::trajectory::PhaseSpace::buildFromFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>file_name_in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoordinateFileKind</td>          <td class="paramname"><span class="paramname"><em>file_kind</em></span><span class="paramdefsep"> = </span><span class="paramdefval">CoordinateFileKind::UNKNOWN</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>frame_number</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill the object from information in some coordinate, restart, or trajectory file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_name</td><td>Name of the file from which to obtain coordinates </td></tr>
    <tr><td class="paramname">file_kind</td><td>The type of coordinate-containing input file </td></tr>
    <tr><td class="paramname">frame_number</td><td>The frame number to read (if the file is a trajectory, not a single point from the system's phase space) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2779d7735416fdde3d35a3a3de5cd3d" name="ad2779d7735416fdde3d35a3a3de5cd3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2779d7735416fdde3d35a3a3de5cd3d">&#9670;&#160;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const PhaseSpaceReader stormm::trajectory::PhaseSpace::data </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the abstract for this object, containing C-style pointers for the most rapid access to any of its member variables. </p>
<p>Overloaded:</p><ul>
<li>Get a read-only abstract from a const <a class="el" href="classstormm_1_1stmath_1_1PhaseSpace.html" title="An object to complement a topology and hold positions, velocities, and forces of all particles in a s...">PhaseSpace</a> object</li>
<li>Get a writeable abstract from a mutable <a class="el" href="classstormm_1_1stmath_1_1PhaseSpace.html" title="An object to complement a topology and hold positions, velocities, and forces of all particles in a s...">PhaseSpace</a> object</li>
<li>Get either object oriented with the present, alternate positional arrays set as holding the current coordinates (three such abstracts can be rotated over successive cycles of dynamics to let the coordinates evolve, protected against race conditions, without swapping the actual locations in memory)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tier</td><td>Specify pointers on the host or device </td></tr>
    <tr><td class="paramname">orientation</td><td>Arbitrarily selected point on the time cycle to have the reader or writer take as the current coordinates </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55a1099939eec28419829fff64a0b6ba" name="a55a1099939eec28419829fff64a0b6ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55a1099939eec28419829fff64a0b6ba">&#9670;&#160;</a></span>exportToFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::trajectory::PhaseSpace::exportToFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>file_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>current_time</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TrajectoryKind</td>          <td class="paramname"><span class="paramname"><em>traj_kind</em></span><span class="paramdefsep"> = </span><span class="paramdefval">TrajectoryKind::POSITIONS</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoordinateFileKind</td>          <td class="paramname"><span class="paramname"><em>output_kind</em></span><span class="paramdefsep"> = </span><span class="paramdefval">CoordinateFileKind::AMBER_INPCRD</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PrintSituation</td>          <td class="paramname"><span class="paramname"><em>expectation</em></span><span class="paramdefsep"> = </span><span class="paramdefval">PrintSituation::UNKNOWN</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put the phase space data into a trajectory or checkpoint file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_name</td><td>Name of the file to write </td></tr>
    <tr><td class="paramname">current_time</td><td>Time progress of the simulation </td></tr>
    <tr><td class="paramname">traj_kind</td><td>The type of trajectory to print (coordinates, velocities, or forces) </td></tr>
    <tr><td class="paramname">output_kind</td><td>The format of the file to write (checkpoint files print position and velocity data by obligation, but trajectory files can contain either of these as well as forces) </td></tr>
    <tr><td class="paramname">expectation</td><td>The condition in which the output file is expected to be found </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf3a8fc51583dfcf2b2eeaf25bbfcad7" name="adf3a8fc51583dfcf2b2eeaf25bbfcad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf3a8fc51583dfcf2b2eeaf25bbfcad7">&#9670;&#160;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stormm::trajectory::PhaseSpace::fill </td>
          <td>(</td>
          <td class="paramtype">const T *</td>          <td class="paramname"><span class="paramname"><em>xcrd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *</td>          <td class="paramname"><span class="paramname"><em>ycrd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *</td>          <td class="paramname"><span class="paramname"><em>zcrd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TrajectoryKind</td>          <td class="paramname"><span class="paramname"><em>kind</em></span><span class="paramdefsep"> = </span><span class="paramdefval">TrajectoryKind::POSITIONS</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoordinateCycle</td>          <td class="paramname"><span class="paramname"><em>cycle_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">CoordinateCycle::WHITE</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>scale_bits</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *</td>          <td class="paramname"><span class="paramname"><em>box_dims</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill the object from information in three arrays. </p>
<p>Overloaded:</p><ul>
<li>Fill from three C-style arrays</li>
<li>Fill from three Standard Template Library vector objects</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xcrd</td><td>Cartesian X coordinates of positions, velocities, or forces </td></tr>
    <tr><td class="paramname">ycrd</td><td>Cartesian Y coordinates of positions, velocities, or forces </td></tr>
    <tr><td class="paramname">zcrd</td><td>Cartesian Z coordinates of positions, velocities, or forces </td></tr>
    <tr><td class="paramname">kind</td><td>Type of coordinates coming in: fill the positions, velocities, or forces </td></tr>
    <tr><td class="paramname">cycle_in</td><td>The point in the coordinate cycle to fill </td></tr>
    <tr><td class="paramname">scale_bits</td><td>The number of bits after the decimal, applicable to fixed-precision representations of xcrd, ycrd, and zcrd (the box dimensions are always given as a double-precision array, in units of Angstroms) </td></tr>
    <tr><td class="paramname">box_dims</td><td>Box dimensions, from which the tranformation matrices will be derived </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d8bf8c0d2d996f79d17dd8a8af20361" name="a1d8bf8c0d2d996f79d17dd8a8af20361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d8bf8c0d2d996f79d17dd8a8af20361">&#9670;&#160;</a></span>getBoxSizePointer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double * stormm::trajectory::PhaseSpace::getBoxSizePointer </td>
          <td>(</td>
          <td class="paramtype">CoordinateCycle</td>          <td class="paramname"><span class="paramname"><em>orientation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the box dimensions that can track its evolution in the <a class="el" href="classstormm_1_1stmath_1_1PhaseSpace.html" title="An object to complement a topology and hold positions, velocities, and forces of all particles in a s...">PhaseSpace</a> object's <a class="el" href="classstormm_1_1stmath_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> data arrays, on either the host or device. </p>
<p>Overloaded:</p><ul>
<li>Get a const pointer for a const <a class="el" href="classstormm_1_1stmath_1_1PhaseSpace.html" title="An object to complement a topology and hold positions, velocities, and forces of all particles in a s...">PhaseSpace</a> object's data</li>
<li>Get a non-const pointer to a mutable <a class="el" href="classstormm_1_1stmath_1_1PhaseSpace.html" title="An object to complement a topology and hold positions, velocities, and forces of all particles in a s...">PhaseSpace</a> object's data</li>
<li>Indicate a specific point in the time cycle, or accept whatever the object sees as its own current stage of the cycle</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orientation</td><td>A specific point in the time cycle to query </td></tr>
    <tr><td class="paramname">tier</td><td>Level at which to extract the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea00e86a55ac783f62fc08c08910bb56" name="aea00e86a55ac783f62fc08c08910bb56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea00e86a55ac783f62fc08c08910bb56">&#9670;&#160;</a></span>getBoxSpaceTransform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; stormm::trajectory::PhaseSpace::getBoxSpaceTransform </td>
          <td>(</td>
          <td class="paramtype">CoordinateCycle</td>          <td class="paramname"><span class="paramname"><em>orientation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the transformation matrix to take coordinates into box (fractional) space. The result should be interpreted as a 3x3 matrix in column-major format. </p>
<p>Overloaded:</p><ul>
<li>Indicate a specific point in the time cycle</li>
<li>Accept whatever the object sees as its own current stage of the cycle</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orientation</td><td>A specific point in the time cycle to query </td></tr>
    <tr><td class="paramname">tier</td><td>Level at which to retrieve the data (if STORMM is compiled to run on a GPU) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96704b639d575c3e70f1e0df578bf0b9" name="a96704b639d575c3e70f1e0df578bf0b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96704b639d575c3e70f1e0df578bf0b9">&#9670;&#160;</a></span>getBoxSpaceTransformPointer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double * stormm::trajectory::PhaseSpace::getBoxSpaceTransformPointer </td>
          <td>(</td>
          <td class="paramtype">CoordinateCycle</td>          <td class="paramname"><span class="paramname"><em>orientation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the box space transformation matrix that can track its evolution in the <a class="el" href="classstormm_1_1stmath_1_1PhaseSpace.html" title="An object to complement a topology and hold positions, velocities, and forces of all particles in a s...">PhaseSpace</a> object's <a class="el" href="classstormm_1_1stmath_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> data arrays, on either the host or device. </p>
<p>Overloaded:</p><ul>
<li>Get a const pointer for a const <a class="el" href="classstormm_1_1stmath_1_1PhaseSpace.html" title="An object to complement a topology and hold positions, velocities, and forces of all particles in a s...">PhaseSpace</a> object's data</li>
<li>Get a non-const pointer to a mutable <a class="el" href="classstormm_1_1stmath_1_1PhaseSpace.html" title="An object to complement a topology and hold positions, velocities, and forces of all particles in a s...">PhaseSpace</a> object's data</li>
<li>Indicate a specific point in the time cycle, or accept whatever the object sees as its own current stage of the cycle</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orientation</td><td>A specific point in the time cycle to query </td></tr>
    <tr><td class="paramname">tier</td><td>Level at which to extract the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e1b8cfb54f60bf17f41ba872904de06" name="a8e1b8cfb54f60bf17f41ba872904de06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e1b8cfb54f60bf17f41ba872904de06">&#9670;&#160;</a></span>getCoordinateHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; double &gt; * stormm::trajectory::PhaseSpace::getCoordinateHandle </td>
          <td>(</td>
          <td class="paramtype">CartesianDimension</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TrajectoryKind</td>          <td class="paramname"><span class="paramname"><em>kind</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoordinateCycle</td>          <td class="paramname"><span class="paramname"><em>orientation</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to one of the coordinate arrays, a pointer to a POINTER-kind <a class="el" href="classstormm_1_1stmath_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> object. </p>
<p>Overloaded:</p><ul>
<li>Specify a stage in the time cycle at which to query coordinates. This may be necessary, step by step, as the object advances in its time cycle.</li>
<li>Accept coordinates from the object's current point in the time cycle. The pointer will remain set to this array even if the <a class="el" href="classstormm_1_1stmath_1_1PhaseSpace.html" title="An object to complement a topology and hold positions, velocities, and forces of all particles in a s...">PhaseSpace</a> object later advances in its time cycle.</li>
<li>Get a const pointer to data within a const object, or a non-const pointer to data in a mutable object.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>Indicate Cartesian X, Y, or Z values </td></tr>
    <tr><td class="paramname">kind</td><td>Indicate positions, velocities, or forces </td></tr>
    <tr><td class="paramname">orientation</td><td>The point in the time cycle (WHITE or BLACK) at which to set the pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a19c2366a5bc2691a2eec6b68874de49e" name="a19c2366a5bc2691a2eec6b68874de49e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19c2366a5bc2691a2eec6b68874de49e">&#9670;&#160;</a></span>getCoordinatePointer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double * stormm::trajectory::PhaseSpace::getCoordinatePointer </td>
          <td>(</td>
          <td class="paramtype">CartesianDimension</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TrajectoryKind</td>          <td class="paramname"><span class="paramname"><em>kind</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoordinateCycle</td>          <td class="paramname"><span class="paramname"><em>orientation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the particle X, Y, or Z coordinates, velocities, or forces, on either the host or device. Use this when the entire abstract is unnecessary or would be inefficient to retrieve. </p>
<p>Overloaded:</p><ul>
<li>Get a const pointer for a const <a class="el" href="classstormm_1_1stmath_1_1PhaseSpace.html" title="An object to complement a topology and hold positions, velocities, and forces of all particles in a s...">PhaseSpace</a> object's data</li>
<li>Get a non-const pointer to a mutable <a class="el" href="classstormm_1_1stmath_1_1PhaseSpace.html" title="An object to complement a topology and hold positions, velocities, and forces of all particles in a s...">PhaseSpace</a> object's data</li>
<li>Specify the cycle position, or assume that the object's current position in the time cycle is desired</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>Cartesian dimension of interest </td></tr>
    <tr><td class="paramname">kind</td><td>Specify coordinates, velocities, or forces&ndash;anything that could be thought of as a trajectory </td></tr>
    <tr><td class="paramname">tier</td><td>Level at which to extract the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8278fe07fd8ac7c5136021c19d791cea" name="a8278fe07fd8ac7c5136021c19d791cea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8278fe07fd8ac7c5136021c19d791cea">&#9670;&#160;</a></span>getInterlacedCoordinates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; stormm::trajectory::PhaseSpace::getInterlacedCoordinates </td>
          <td>(</td>
          <td class="paramtype">TrajectoryKind</td>          <td class="paramname"><span class="paramname"><em>kind</em></span><span class="paramdefsep"> = </span><span class="paramdefval">TrajectoryKind::POSITIONS</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the coordinates returned in an X/Y/Z interlaced manner. </p>
<p>Overloaded:</p><ul>
<li>Get all coordinates</li>
<li>Get coordinates for a range of atoms</li>
<li>Choose the point in the time cycle or accept the object's "current" state</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">low_index</td><td>The lower atom index of a range </td></tr>
    <tr><td class="paramname">high_index</td><td>The upper atom index of a range </td></tr>
    <tr><td class="paramname">kind</td><td>Specify coordinates, velocities, or forces&ndash;anything that could be thought of as a trajectory </td></tr>
    <tr><td class="paramname">tier</td><td>Level at which to extract the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4677e1af1e9dac1bc18d5e43abb4a314" name="a4677e1af1e9dac1bc18d5e43abb4a314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4677e1af1e9dac1bc18d5e43abb4a314">&#9670;&#160;</a></span>getInverseTransform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; stormm::trajectory::PhaseSpace::getInverseTransform </td>
          <td>(</td>
          <td class="paramtype">CoordinateCycle</td>          <td class="paramname"><span class="paramname"><em>orientation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the transformation matrix to take coordinates from fractional space back into real space. The result should be interpreted as a 3x3 matrix in column-major format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orientation</td><td>A specific point in the time cycle to query </td></tr>
    <tr><td class="paramname">tier</td><td>Level at which to retrieve the data (if STORMM is compiled to run on a GPU) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5104f96072e693b9ee668b3681ec1be" name="aa5104f96072e693b9ee668b3681ec1be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5104f96072e693b9ee668b3681ec1be">&#9670;&#160;</a></span>getInverseTransformPointer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double * stormm::trajectory::PhaseSpace::getInverseTransformPointer </td>
          <td>(</td>
          <td class="paramtype">CoordinateCycle</td>          <td class="paramname"><span class="paramname"><em>orientation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the inverse (back to real space) transformation matrix that can track its evolution in the <a class="el" href="classstormm_1_1stmath_1_1PhaseSpace.html" title="An object to complement a topology and hold positions, velocities, and forces of all particles in a s...">PhaseSpace</a> object's <a class="el" href="classstormm_1_1stmath_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> data arrays, on either the host or device. </p>
<p>Overloaded:</p><ul>
<li>Get a const pointer for a const <a class="el" href="classstormm_1_1stmath_1_1PhaseSpace.html" title="An object to complement a topology and hold positions, velocities, and forces of all particles in a s...">PhaseSpace</a> object's data</li>
<li>Get a non-const pointer to a mutable <a class="el" href="classstormm_1_1stmath_1_1PhaseSpace.html" title="An object to complement a topology and hold positions, velocities, and forces of all particles in a s...">PhaseSpace</a> object's data</li>
<li>Indicate a specific point in the time cycle, or accept whatever the object sees as its own current stage of the cycle</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orientation</td><td>A specific point in the time cycle to query </td></tr>
    <tr><td class="paramname">tier</td><td>Level at which to extract the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4047f0cc2c19e5d9687d1ff0d272b0af" name="a4047f0cc2c19e5d9687d1ff0d272b0af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4047f0cc2c19e5d9687d1ff0d272b0af">&#9670;&#160;</a></span>getStorageHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; double &gt; * stormm::trajectory::PhaseSpace::getStorageHandle </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the ARRAY-kind <a class="el" href="classstormm_1_1stmath_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> object that holds the actual data. Needed by <a class="el" href="classstormm_1_1stmath_1_1CoordinateFrame.html" title="Store the coordinates and box information for a frame, only. This abridged struct can serve when the ...">CoordinateFrame</a> objects which want to be pointers into a <a class="el" href="classstormm_1_1stmath_1_1PhaseSpace.html" title="An object to complement a topology and hold positions, velocities, and forces of all particles in a s...">PhaseSpace</a> object. </p>
<p>Overloaded:</p><ul>
<li>Get a const pointer to a const <a class="el" href="classstormm_1_1stmath_1_1PhaseSpace.html" title="An object to complement a topology and hold positions, velocities, and forces of all particles in a s...">PhaseSpace</a> object's data storage</li>
<li>Get a non-const pointer to a mutable PhaeSpace object's data storage </li>
</ul>

</div>
</div>
<a id="a0c8e13c38b0b023302ce4f28a5778cb5" name="a0c8e13c38b0b023302ce4f28a5778cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c8e13c38b0b023302ce4f28a5778cb5">&#9670;&#160;</a></span>initializeForces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::trajectory::PhaseSpace::initializeForces </td>
          <td>(</td>
          <td class="paramtype">CoordinateCycle</td>          <td class="paramname"><span class="paramname"><em>orientation</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the forces (set them to zero) </p>
<p>Overloaded:</p><ul>
<li>Update forces for an arbitrary point in the time cycle</li>
<li>Update forces for the object's current position in the cycle</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orentation</td><td>A selected point in the time cycle (WHITE or BLACK) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ffc0b5512385d5365242eb8b48e0a69" name="a8ffc0b5512385d5365242eb8b48e0a69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ffc0b5512385d5365242eb8b48e0a69">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html">PhaseSpace</a> &amp; stormm::trajectory::PhaseSpace::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html">PhaseSpace</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment operator likewise handles assignment of internal POINTER-kind <a class="el" href="classstormm_1_1stmath_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another way to say original, in a different semantic context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63198eeb645200ac1c90b3b465c6976c" name="a63198eeb645200ac1c90b3b465c6976c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63198eeb645200ac1c90b3b465c6976c">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html">PhaseSpace</a> &amp; stormm::trajectory::PhaseSpace::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html">PhaseSpace</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The move assignment operator looks much like the copy assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another way to say original, in a different semantic context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad983dc270429206162c46bbf2f6e65df" name="ad983dc270429206162c46bbf2f6e65df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad983dc270429206162c46bbf2f6e65df">&#9670;&#160;</a></span>updateCyclePosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::trajectory::PhaseSpace::updateCyclePosition </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the cycle position. </p>
<p>Overloaded:</p><ul>
<li>Advance the cycle position based on its current setting (no input argument): present &gt;&gt; future &gt;&gt; past &gt;&gt; present &gt;&gt; ...</li>
<li>Set the cycle position to an arbitrary point</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time_point</td><td>The point in the time cycle that shall become the <a class="el" href="classstormm_1_1stmath_1_1PhaseSpace.html" title="An object to complement a topology and hold positions, velocities, and forces of all particles in a s...">PhaseSpace</a> object's "present" coordinates. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/Trajectory/<a class="el" href="phasespace_8h_source.html">phasespace.h</a></li>
<li>src/Trajectory/<b>phasespace.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2
</small></address>
</div><!-- doc-content -->
</body>
</html>
