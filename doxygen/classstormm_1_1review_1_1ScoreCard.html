<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>STORMM Source Documentation: stormm::review::ScoreCard Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">STORMM Source Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>stormm</b></li><li class="navelem"><b>review</b></li><li class="navelem"><a class="el" href="classstormm_1_1review_1_1ScoreCard.html">ScoreCard</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classstormm_1_1review_1_1ScoreCard-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">stormm::review::ScoreCard Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Track the energy components of a collection of systems in an HPC-capable array. This object uses the familiar trick of defining an enumerator (StateVariables) with a final entry to indicate its total length, so that if more energy components need to be tracked in the future the storage and indexing can automatically adjust with new entries.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="scorecard_8h_source.html">scorecard.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aae5531c4e2aa693af1507c9d38f0c753" id="r_aae5531c4e2aa693af1507c9d38f0c753"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae5531c4e2aa693af1507c9d38f0c753">ScoreCard</a> (int system_count_in, int capacity_in=16, int nrg_scale_bits_in=default_energy_scale_bits)</td></tr>
<tr class="memdesc:aae5531c4e2aa693af1507c9d38f0c753"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructor requires only the number of systems.  <br /></td></tr>
<tr class="separator:aae5531c4e2aa693af1507c9d38f0c753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae633b9b65cd9dec525d01757f570c30c" id="r_ae633b9b65cd9dec525d01757f570c30c"><td class="memItemLeft" align="right" valign="top"><a id="ae633b9b65cd9dec525d01757f570c30c" name="ae633b9b65cd9dec525d01757f570c30c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getSystemCount</b> () const</td></tr>
<tr class="memdesc:ae633b9b65cd9dec525d01757f570c30c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of systems that this object is tracking. <br /></td></tr>
<tr class="separator:ae633b9b65cd9dec525d01757f570c30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f63f42435e43caf48babfca768aff41" id="r_a5f63f42435e43caf48babfca768aff41"><td class="memItemLeft" align="right" valign="top"><a id="a5f63f42435e43caf48babfca768aff41" name="a5f63f42435e43caf48babfca768aff41"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getSampleSize</b> () const</td></tr>
<tr class="memdesc:a5f63f42435e43caf48babfca768aff41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of steps that have been sampled. <br /></td></tr>
<tr class="separator:a5f63f42435e43caf48babfca768aff41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01fb1ae19ed795664e7facf479d9bad" id="r_af01fb1ae19ed795664e7facf479d9bad"><td class="memItemLeft" align="right" valign="top"><a id="af01fb1ae19ed795664e7facf479d9bad" name="af01fb1ae19ed795664e7facf479d9bad"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getDataStride</b> () const</td></tr>
<tr class="memdesc:af01fb1ae19ed795664e7facf479d9bad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the stride used to store separate results for each system in the instantaneous accumulator arrays. <br /></td></tr>
<tr class="separator:af01fb1ae19ed795664e7facf479d9bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf6f5f45aec9cc3cfd1a555aa2c3547" id="r_addf6f5f45aec9cc3cfd1a555aa2c3547"><td class="memItemLeft" align="right" valign="top"><a id="addf6f5f45aec9cc3cfd1a555aa2c3547" name="addf6f5f45aec9cc3cfd1a555aa2c3547"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getSampleCapacity</b> () const</td></tr>
<tr class="memdesc:addf6f5f45aec9cc3cfd1a555aa2c3547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sample capacity (the number of individual energy measurements that the object is prepared to store). <br /></td></tr>
<tr class="separator:addf6f5f45aec9cc3cfd1a555aa2c3547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4bf9454ef7b9498fc1f2963bf567ac9" id="r_ae4bf9454ef7b9498fc1f2963bf567ac9"><td class="memItemLeft" align="right" valign="top"><a id="ae4bf9454ef7b9498fc1f2963bf567ac9" name="ae4bf9454ef7b9498fc1f2963bf567ac9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getEnergyScaleBits</b> () const</td></tr>
<tr class="memdesc:ae4bf9454ef7b9498fc1f2963bf567ac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of bits of fixed precision to which results are stored. <br /></td></tr>
<tr class="separator:ae4bf9454ef7b9498fc1f2963bf567ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89bf8d1a524d5bbb42ea5ff557aac2e9" id="r_a89bf8d1a524d5bbb42ea5ff557aac2e9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89bf8d1a524d5bbb42ea5ff557aac2e9">getTimeStep</a> (int time_index) const</td></tr>
<tr class="memdesc:a89bf8d1a524d5bbb42ea5ff557aac2e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the time step at which a particular energy value was taken.  <br /></td></tr>
<tr class="separator:a89bf8d1a524d5bbb42ea5ff557aac2e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae39575d3d5c399d7426e7d61696829b3" id="r_ae39575d3d5c399d7426e7d61696829b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae39575d3d5c399d7426e7d61696829b3">reserve</a> (int new_capacity)</td></tr>
<tr class="memdesc:ae39575d3d5c399d7426e7d61696829b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve space for storing sampled energy component values.  <br /></td></tr>
<tr class="separator:ae39575d3d5c399d7426e7d61696829b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa646b2b3319786cc6895be6bd5b3c658" id="r_aa646b2b3319786cc6895be6bd5b3c658"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa646b2b3319786cc6895be6bd5b3c658">contribute</a> (StateVariable var, llint amount, int system_index=0)</td></tr>
<tr class="memdesc:aa646b2b3319786cc6895be6bd5b3c658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place a result into one of the instantaneous state variable accumulators. This is for CPU activity; on the GPU, the contributions will occur as part of each energy kernel using pointers. This will automatically update running accumulators for statistical tracking. It is add + commit, below.  <br /></td></tr>
<tr class="separator:aa646b2b3319786cc6895be6bd5b3c658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4fa92298f4f5180712f351a07c2bc62" id="r_ae4fa92298f4f5180712f351a07c2bc62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4fa92298f4f5180712f351a07c2bc62">add</a> (StateVariable var, llint amount, int system_index=0)</td></tr>
<tr class="memdesc:ae4fa92298f4f5180712f351a07c2bc62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a result to a growing total in one of the instantaneous state variable accumulators. This is for CPU activity; on the GPU, the contributions will occur as part of each energy kernel using pointers.  <br /></td></tr>
<tr class="separator:ae4fa92298f4f5180712f351a07c2bc62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f8b654a44cc77593042a7e8018d121" id="r_a03f8b654a44cc77593042a7e8018d121"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03f8b654a44cc77593042a7e8018d121">computePotentialEnergy</a> (HybridTargetLevel tier=HybridTargetLevel::HOST, const GpuDetails &amp;gpu=null_gpu)</td></tr>
<tr class="memdesc:a03f8b654a44cc77593042a7e8018d121"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute total potential energies for all systems in the instantaneous accumulators as well as all time series accumulators. This total is not automatically computed by various interaction evaluations, which only compute individual "components" of this quantity.  <br /></td></tr>
<tr class="separator:a03f8b654a44cc77593042a7e8018d121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015a86d739b43ccd32b8320ad5f71ac0" id="r_a015a86d739b43ccd32b8320ad5f71ac0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a015a86d739b43ccd32b8320ad5f71ac0">computeTotalEnergy</a> (HybridTargetLevel tier=HybridTargetLevel::HOST, const GpuDetails &amp;gpu=null_gpu)</td></tr>
<tr class="memdesc:a015a86d739b43ccd32b8320ad5f71ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute total energies for all systems in the instantaneous accumulators as well as all time series accumulators. This total is not automatically computed by various interaction evaluations, which only compute individual "components" of this quantity.  <br /></td></tr>
<tr class="separator:a015a86d739b43ccd32b8320ad5f71ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c05a671fe933f2c8089fc74a55ef91" id="r_af9c05a671fe933f2c8089fc74a55ef91"><td class="memItemLeft" align="right" valign="top"><a id="af9c05a671fe933f2c8089fc74a55ef91" name="af9c05a671fe933f2c8089fc74a55ef91"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>incrementSampleCount</b> ()</td></tr>
<tr class="memdesc:af9c05a671fe933f2c8089fc74a55ef91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the number of sampled steps. This will automatically allocate additional capacity if the sampled step count reaches the object's capacity. <br /></td></tr>
<tr class="separator:af9c05a671fe933f2c8089fc74a55ef91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2cb03021139d2fca395bfbe5507ba6f" id="r_aa2cb03021139d2fca395bfbe5507ba6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2cb03021139d2fca395bfbe5507ba6f">resetSampleCount</a> (int count_in=0)</td></tr>
<tr class="memdesc:aa2cb03021139d2fca395bfbe5507ba6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the sample counter (this is implicitly done by <a class="el" href="classstormm_1_1energy_1_1ScoreCard.html#a3588a0688ec6cd1ee5f65ea8c850aa96" title="Initialize some or all instantaneous state variable accumulators. If all state variable accumulators ...">initialize()</a> if that function is called to operate on all start variables and all systems, on either the host or HPC device).  <br /></td></tr>
<tr class="separator:aa2cb03021139d2fca395bfbe5507ba6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2272b9bd48a7115d41e8be4c65a1689" id="r_af2272b9bd48a7115d41e8be4c65a1689"><td class="memItemLeft" align="right" valign="top"><a id="af2272b9bd48a7115d41e8be4c65a1689" name="af2272b9bd48a7115d41e8be4c65a1689"></a>
const <a class="el" href="classstormm_1_1energy_1_1ScoreCard.html">ScoreCard</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getSelfPointer</b> () const</td></tr>
<tr class="memdesc:af2272b9bd48a7115d41e8be4c65a1689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const pointer to this object. <br /></td></tr>
<tr class="separator:af2272b9bd48a7115d41e8be4c65a1689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab05860447c4f78902c87aa27cb639d6f" id="r_ab05860447c4f78902c87aa27cb639d6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab05860447c4f78902c87aa27cb639d6f">setLastTimeStep</a> (int time_index, HybridTargetLevel tier=HybridTargetLevel::HOST)</td></tr>
<tr class="memdesc:ab05860447c4f78902c87aa27cb639d6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the time index for the most recent stored set of energies.  <br /></td></tr>
<tr class="separator:ab05860447c4f78902c87aa27cb639d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aef23d2b197bcaea68d8d607def275859" id="r_aef23d2b197bcaea68d8d607def275859"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef23d2b197bcaea68d8d607def275859">ScoreCard</a> (const <a class="el" href="classstormm_1_1energy_1_1ScoreCard.html">ScoreCard</a> &amp;original)=default</td></tr>
<tr class="memdesc:aef23d2b197bcaea68d8d607def275859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy and move constructors help make the energy tracker a first-class C++ object. The defaults apply as there are no const member variables and no POINTER-kind <a class="el" href="classstormm_1_1review_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> objects.  <br /></td></tr>
<tr class="separator:aef23d2b197bcaea68d8d607def275859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce60ea03af9d9cea8842f3ae188d002" id="r_adce60ea03af9d9cea8842f3ae188d002"><td class="memItemLeft" align="right" valign="top"><a id="adce60ea03af9d9cea8842f3ae188d002" name="adce60ea03af9d9cea8842f3ae188d002"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ScoreCard</b> (<a class="el" href="classstormm_1_1energy_1_1ScoreCard.html">ScoreCard</a> &amp;&amp;original)=default</td></tr>
<tr class="separator:adce60ea03af9d9cea8842f3ae188d002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a2fc4e26cfbd3ab01363153e3e1cea6b5" id="r_a2fc4e26cfbd3ab01363153e3e1cea6b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstormm_1_1energy_1_1ScoreCard.html">ScoreCard</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2fc4e26cfbd3ab01363153e3e1cea6b5">operator=</a> (const <a class="el" href="classstormm_1_1energy_1_1ScoreCard.html">ScoreCard</a> &amp;other)=default</td></tr>
<tr class="memdesc:a2fc4e26cfbd3ab01363153e3e1cea6b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy and move assignment operators complete the support for integrating this energy tracker with Standard Template Library mechanics. The defaults apply as there are no const member variables and no POINTER-kind <a class="el" href="classstormm_1_1review_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> objects.  <br /></td></tr>
<tr class="separator:a2fc4e26cfbd3ab01363153e3e1cea6b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc0faf4e5bac8dd6c42718c29aabfce" id="r_accc0faf4e5bac8dd6c42718c29aabfce"><td class="memItemLeft" align="right" valign="top"><a id="accc0faf4e5bac8dd6c42718c29aabfce" name="accc0faf4e5bac8dd6c42718c29aabfce"></a>
<a class="el" href="classstormm_1_1energy_1_1ScoreCard.html">ScoreCard</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classstormm_1_1energy_1_1ScoreCard.html">ScoreCard</a> &amp;&amp;other)=default</td></tr>
<tr class="separator:accc0faf4e5bac8dd6c42718c29aabfce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a49f62dd8f37b303b3bb9f03220440b12" id="r_a49f62dd8f37b303b3bb9f03220440b12"><td class="memTemplParams" colspan="2"><a id="a49f62dd8f37b303b3bb9f03220440b12" name="a49f62dd8f37b303b3bb9f03220440b12"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:a49f62dd8f37b303b3bb9f03220440b12"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getEnergyScalingFactor</b> () const</td></tr>
<tr class="memdesc:a49f62dd8f37b303b3bb9f03220440b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the energy scaling factors in single- or double-precision floating point format. <br /></td></tr>
<tr class="separator:a49f62dd8f37b303b3bb9f03220440b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4993aef08550ca06804589e89c6d63e0" id="r_a4993aef08550ca06804589e89c6d63e0"><td class="memTemplParams" colspan="2"><a id="a4993aef08550ca06804589e89c6d63e0" name="a4993aef08550ca06804589e89c6d63e0"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:a4993aef08550ca06804589e89c6d63e0"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getInverseEnergyScalingFactor</b> () const</td></tr>
<tr class="separator:a4993aef08550ca06804589e89c6d63e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1d8f30ae0c156b229a2d046285ac1164" id="r_a1d8f30ae0c156b229a2d046285ac1164"><td class="memItemLeft" align="right" valign="top">const ScoreCardReader&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d8f30ae0c156b229a2d046285ac1164">data</a> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:a1d8f30ae0c156b229a2d046285ac1164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the appropriate abstract based on the const-ness of the abstract.  <br /></td></tr>
<tr class="separator:a1d8f30ae0c156b229a2d046285ac1164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7717dba38d4a50859aead68d5dd15216" id="r_a7717dba38d4a50859aead68d5dd15216"><td class="memItemLeft" align="right" valign="top"><a id="a7717dba38d4a50859aead68d5dd15216" name="a7717dba38d4a50859aead68d5dd15216"></a>
ScoreCardWriter&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> (HybridTargetLevel tier=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:a7717dba38d4a50859aead68d5dd15216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3588a0688ec6cd1ee5f65ea8c850aa96" id="r_a3588a0688ec6cd1ee5f65ea8c850aa96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3588a0688ec6cd1ee5f65ea8c850aa96">initialize</a> (StateVariable var, int system_index=0, HybridTargetLevel tier=HybridTargetLevel::HOST, const GpuDetails &amp;gpu=null_gpu)</td></tr>
<tr class="memdesc:a3588a0688ec6cd1ee5f65ea8c850aa96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize some or all instantaneous state variable accumulators. If all state variable accumulators are initialized in all systems, the sample counter will also be reset.  <br /></td></tr>
<tr class="separator:a3588a0688ec6cd1ee5f65ea8c850aa96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029bbf6fcd451463bb1e22a4731cc360" id="r_a029bbf6fcd451463bb1e22a4731cc360"><td class="memItemLeft" align="right" valign="top"><a id="a029bbf6fcd451463bb1e22a4731cc360" name="a029bbf6fcd451463bb1e22a4731cc360"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>initialize</b> (const std::vector&lt; StateVariable &gt; &amp;var, int system_index=0, HybridTargetLevel tier=HybridTargetLevel::HOST, const GpuDetails &amp;gpu=null_gpu)</td></tr>
<tr class="separator:a029bbf6fcd451463bb1e22a4731cc360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29631a4983e7829775e7f310f4066d3" id="r_ac29631a4983e7829775e7f310f4066d3"><td class="memItemLeft" align="right" valign="top"><a id="ac29631a4983e7829775e7f310f4066d3" name="ac29631a4983e7829775e7f310f4066d3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>initialize</b> (int system_index, HybridTargetLevel tier=HybridTargetLevel::HOST, const GpuDetails &amp;gpu=null_gpu)</td></tr>
<tr class="separator:ac29631a4983e7829775e7f310f4066d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae114327491574f5b22f9523a73e59f11" id="r_ae114327491574f5b22f9523a73e59f11"><td class="memItemLeft" align="right" valign="top"><a id="ae114327491574f5b22f9523a73e59f11" name="ae114327491574f5b22f9523a73e59f11"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>initialize</b> (HybridTargetLevel tier=HybridTargetLevel::HOST, const GpuDetails &amp;gpu=null_gpu)</td></tr>
<tr class="separator:ae114327491574f5b22f9523a73e59f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3fc912255c2b48d484c15d136c773e2f" id="r_a3fc912255c2b48d484c15d136c773e2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3fc912255c2b48d484c15d136c773e2f">commit</a> (StateVariable var, int system_index, HybridTargetLevel tier=HybridTargetLevel::HOST, const GpuDetails &amp;gpu=null_gpu)</td></tr>
<tr class="memdesc:a3fc912255c2b48d484c15d136c773e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commit the (assumed complete) accumulated results in one or more state variables to the running tallies and time series kept for statistical purposes.  <br /></td></tr>
<tr class="separator:a3fc912255c2b48d484c15d136c773e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c32b09fb46729c002da0bcb6a7111ce" id="r_a8c32b09fb46729c002da0bcb6a7111ce"><td class="memItemLeft" align="right" valign="top"><a id="a8c32b09fb46729c002da0bcb6a7111ce" name="a8c32b09fb46729c002da0bcb6a7111ce"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>commit</b> (const std::vector&lt; StateVariable &gt; &amp;var, int system_index, HybridTargetLevel tier=HybridTargetLevel::HOST, const GpuDetails &amp;gpu=null_gpu)</td></tr>
<tr class="separator:a8c32b09fb46729c002da0bcb6a7111ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7402cfe83e70d73e99d4feb33fb379" id="r_afc7402cfe83e70d73e99d4feb33fb379"><td class="memItemLeft" align="right" valign="top"><a id="afc7402cfe83e70d73e99d4feb33fb379" name="afc7402cfe83e70d73e99d4feb33fb379"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>commit</b> (StateVariable var, HybridTargetLevel tier=HybridTargetLevel::HOST, const GpuDetails &amp;gpu=null_gpu)</td></tr>
<tr class="separator:afc7402cfe83e70d73e99d4feb33fb379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11cf386d57b913fdaf91721d3f894a71" id="r_a11cf386d57b913fdaf91721d3f894a71"><td class="memItemLeft" align="right" valign="top"><a id="a11cf386d57b913fdaf91721d3f894a71" name="a11cf386d57b913fdaf91721d3f894a71"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>commit</b> (const std::vector&lt; StateVariable &gt; &amp;var, HybridTargetLevel tier=HybridTargetLevel::HOST, const GpuDetails &amp;gpu=null_gpu)</td></tr>
<tr class="separator:a11cf386d57b913fdaf91721d3f894a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b6702423a04e13ffc5abec6601649b" id="r_a62b6702423a04e13ffc5abec6601649b"><td class="memItemLeft" align="right" valign="top"><a id="a62b6702423a04e13ffc5abec6601649b" name="a62b6702423a04e13ffc5abec6601649b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>commit</b> (int system_index, HybridTargetLevel tier=HybridTargetLevel::HOST, const GpuDetails &amp;gpu=null_gpu)</td></tr>
<tr class="separator:a62b6702423a04e13ffc5abec6601649b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accae834ad7989abbf0ed3f0ba9e975c8" id="r_accae834ad7989abbf0ed3f0ba9e975c8"><td class="memItemLeft" align="right" valign="top"><a id="accae834ad7989abbf0ed3f0ba9e975c8" name="accae834ad7989abbf0ed3f0ba9e975c8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>commit</b> (HybridTargetLevel tier=HybridTargetLevel::HOST, const GpuDetails &amp;gpu=null_gpu)</td></tr>
<tr class="separator:accae834ad7989abbf0ed3f0ba9e975c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a77a6f0594a3ea02beeae26fc080018d1" id="r_a77a6f0594a3ea02beeae26fc080018d1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77a6f0594a3ea02beeae26fc080018d1">reportPotentialEnergies</a> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:a77a6f0594a3ea02beeae26fc080018d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report the total energy, or total potential energy, for one system or for all systems. Each result will be summed in the internal fixed-point accumulation before conversion to real values in units of kcal/mol.  <br /></td></tr>
<tr class="separator:a77a6f0594a3ea02beeae26fc080018d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addbb1378f2519e131c2c4d4fd33fda84" id="r_addbb1378f2519e131c2c4d4fd33fda84"><td class="memItemLeft" align="right" valign="top"><a id="addbb1378f2519e131c2c4d4fd33fda84" name="addbb1378f2519e131c2c4d4fd33fda84"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>reportPotentialEnergy</b> (int system_index=0, HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="separator:addbb1378f2519e131c2c4d4fd33fda84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd21b7691c682bcead1c41bfe4ce03ab" id="r_abd21b7691c682bcead1c41bfe4ce03ab"><td class="memItemLeft" align="right" valign="top"><a id="abd21b7691c682bcead1c41bfe4ce03ab" name="abd21b7691c682bcead1c41bfe4ce03ab"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>reportTotalEnergies</b> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="separator:abd21b7691c682bcead1c41bfe4ce03ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced1010f68d07241a08a2e130eb21256" id="r_aced1010f68d07241a08a2e130eb21256"><td class="memItemLeft" align="right" valign="top"><a id="aced1010f68d07241a08a2e130eb21256" name="aced1010f68d07241a08a2e130eb21256"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>reportTotalEnergy</b> (int system_index=0, HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="separator:aced1010f68d07241a08a2e130eb21256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a7ac609c67a536a0e46f3fee1545f28ce" id="r_a7ac609c67a536a0e46f3fee1545f28ce"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ac609c67a536a0e46f3fee1545f28ce">reportInstantaneousStates</a> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:a7ac609c67a536a0e46f3fee1545f28ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report instantaneous results in kcal/mol, as a double-precision vector.  <br /></td></tr>
<tr class="separator:a7ac609c67a536a0e46f3fee1545f28ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7b0e953ddfa38389e0e2c410f4b7fd" id="r_a8c7b0e953ddfa38389e0e2c410f4b7fd"><td class="memItemLeft" align="right" valign="top"><a id="a8c7b0e953ddfa38389e0e2c410f4b7fd" name="a8c7b0e953ddfa38389e0e2c410f4b7fd"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>reportInstantaneousStates</b> (int system_index, HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="separator:a8c7b0e953ddfa38389e0e2c410f4b7fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d219f0d0dbba364d122e0b0c388ee57" id="r_a4d219f0d0dbba364d122e0b0c388ee57"><td class="memItemLeft" align="right" valign="top"><a id="a4d219f0d0dbba364d122e0b0c388ee57" name="a4d219f0d0dbba364d122e0b0c388ee57"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>reportInstantaneousStates</b> (StateVariable aspect, HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="separator:a4d219f0d0dbba364d122e0b0c388ee57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f1781d663668733d72bd26856c40e75" id="r_a0f1781d663668733d72bd26856c40e75"><td class="memItemLeft" align="right" valign="top"><a id="a0f1781d663668733d72bd26856c40e75" name="a0f1781d663668733d72bd26856c40e75"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>reportInstantaneousStates</b> (StateVariable aspect, int system_index, HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="separator:a0f1781d663668733d72bd26856c40e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a8897d8f488abaea55080064151c70a0d" id="r_a8897d8f488abaea55080064151c70a0d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8897d8f488abaea55080064151c70a0d">reportAverageStates</a> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:a8897d8f488abaea55080064151c70a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report averaged results in kcal/mol, as a double-precision vector.  <br /></td></tr>
<tr class="separator:a8897d8f488abaea55080064151c70a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6067df4f4554d6c01c584edf27de4c" id="r_a0f6067df4f4554d6c01c584edf27de4c"><td class="memItemLeft" align="right" valign="top"><a id="a0f6067df4f4554d6c01c584edf27de4c" name="a0f6067df4f4554d6c01c584edf27de4c"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>reportAverageStates</b> (int system_index, HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="separator:a0f6067df4f4554d6c01c584edf27de4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f55394e9720b0495b777d9eef4f74b" id="r_a59f55394e9720b0495b777d9eef4f74b"><td class="memItemLeft" align="right" valign="top"><a id="a59f55394e9720b0495b777d9eef4f74b" name="a59f55394e9720b0495b777d9eef4f74b"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>reportAverageStates</b> (StateVariable aspect, HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="separator:a59f55394e9720b0495b777d9eef4f74b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c36d0a68d2d5ae3862175d0092a520d" id="r_a6c36d0a68d2d5ae3862175d0092a520d"><td class="memItemLeft" align="right" valign="top"><a id="a6c36d0a68d2d5ae3862175d0092a520d" name="a6c36d0a68d2d5ae3862175d0092a520d"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>reportAverageStates</b> (StateVariable aspect, int system_index, HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="separator:a6c36d0a68d2d5ae3862175d0092a520d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a041612637854eb8d46f79161dff9e6da" id="r_a041612637854eb8d46f79161dff9e6da"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a041612637854eb8d46f79161dff9e6da">reportVarianceOfStates</a> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:a041612637854eb8d46f79161dff9e6da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report standard deviations in kcal/mol, as a double-precision vector.  <br /></td></tr>
<tr class="separator:a041612637854eb8d46f79161dff9e6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db7e44008a98b843bf0d7c459374502" id="r_a0db7e44008a98b843bf0d7c459374502"><td class="memItemLeft" align="right" valign="top"><a id="a0db7e44008a98b843bf0d7c459374502" name="a0db7e44008a98b843bf0d7c459374502"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>reportVarianceOfStates</b> (int system_index, HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="separator:a0db7e44008a98b843bf0d7c459374502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4202e28c3c3235e79b8964f895175f5" id="r_af4202e28c3c3235e79b8964f895175f5"><td class="memItemLeft" align="right" valign="top"><a id="af4202e28c3c3235e79b8964f895175f5" name="af4202e28c3c3235e79b8964f895175f5"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>reportVarianceOfStates</b> (StateVariable aspect, HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="separator:af4202e28c3c3235e79b8964f895175f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17828dc4dcb34e896f7e46daf32a1e54" id="r_a17828dc4dcb34e896f7e46daf32a1e54"><td class="memItemLeft" align="right" valign="top"><a id="a17828dc4dcb34e896f7e46daf32a1e54" name="a17828dc4dcb34e896f7e46daf32a1e54"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>reportVarianceOfStates</b> (StateVariable aspect, int system_index, HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="separator:a17828dc4dcb34e896f7e46daf32a1e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa1d3a243e459ccc7af728b943ec24d83" id="r_aa1d3a243e459ccc7af728b943ec24d83"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1d3a243e459ccc7af728b943ec24d83">reportHistory</a> (int system_index, HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:aa1d3a243e459ccc7af728b943ec24d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report the energy history for one or more systems.  <br /></td></tr>
<tr class="separator:aa1d3a243e459ccc7af728b943ec24d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1196cffe5cd0ea783a3a08aae362cec" id="r_ae1196cffe5cd0ea783a3a08aae362cec"><td class="memItemLeft" align="right" valign="top"><a id="ae1196cffe5cd0ea783a3a08aae362cec" name="ae1196cffe5cd0ea783a3a08aae362cec"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>reportHistory</b> (StateVariable aspect, int system_index, HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="separator:ae1196cffe5cd0ea783a3a08aae362cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e12561c6d855245966fdf8bbce9dfdd" id="r_a3e12561c6d855245966fdf8bbce9dfdd"><td class="memItemLeft" align="right" valign="top"><a id="a3e12561c6d855245966fdf8bbce9dfdd" name="a3e12561c6d855245966fdf8bbce9dfdd"></a>
std::vector&lt; <a class="el" href="structstormm_1_1data__types_1_1double2.html">double2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>reportHistory</b> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="separator:a3e12561c6d855245966fdf8bbce9dfdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f60bdaab0518ebfc2e1b61ce8e41729" id="r_a0f60bdaab0518ebfc2e1b61ce8e41729"><td class="memItemLeft" align="right" valign="top"><a id="a0f60bdaab0518ebfc2e1b61ce8e41729" name="a0f60bdaab0518ebfc2e1b61ce8e41729"></a>
std::vector&lt; <a class="el" href="structstormm_1_1data__types_1_1double2.html">double2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>reportHistory</b> (StateVariable aspect, HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="separator:a0f60bdaab0518ebfc2e1b61ce8e41729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a318c7dead77e3cfd9cc6defc0de912d1" id="r_a318c7dead77e3cfd9cc6defc0de912d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a318c7dead77e3cfd9cc6defc0de912d1">importCard</a> (const <a class="el" href="classstormm_1_1energy_1_1ScoreCard.html">ScoreCard</a> *other, size_t fill_index, size_t source_index)</td></tr>
<tr class="memdesc:a318c7dead77e3cfd9cc6defc0de912d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import the results of another <a class="el" href="classstormm_1_1review_1_1ScoreCard.html" title="Track the energy components of a collection of systems in an HPC-capable array. This object uses the ...">ScoreCard</a> into this one, including all components and the associated energy history. If the current object does not have sufficient space either in terms of systems or sample capacity (depth of history), it will be re-allocated. This functionality is available on the GPU as a free function energyCopy(), which allows the reader from the source and the writer from the destination to be used rather than a long series of pointers and array size constants.  <br /></td></tr>
<tr class="separator:a318c7dead77e3cfd9cc6defc0de912d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ecf27e0d0612b4162f26ba51bf0227" id="r_ae1ecf27e0d0612b4162f26ba51bf0227"><td class="memItemLeft" align="right" valign="top"><a id="ae1ecf27e0d0612b4162f26ba51bf0227" name="ae1ecf27e0d0612b4162f26ba51bf0227"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>importCard</b> (const <a class="el" href="classstormm_1_1energy_1_1ScoreCard.html">ScoreCard</a> &amp;other, size_t fill_index, size_t source_index)</td></tr>
<tr class="separator:ae1ecf27e0d0612b4162f26ba51bf0227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ca837fb8f7c8a67980775019de13233" id="r_a5ca837fb8f7c8a67980775019de13233"><td class="memItemLeft" align="right" valign="top"><a id="a5ca837fb8f7c8a67980775019de13233" name="a5ca837fb8f7c8a67980775019de13233"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>importCard</b> (const <a class="el" href="classstormm_1_1energy_1_1ScoreCard.html">ScoreCard</a> *other, const std::vector&lt; int &gt; &amp;fill_indices, const std::vector&lt; int &gt; &amp;source_indices)</td></tr>
<tr class="separator:a5ca837fb8f7c8a67980775019de13233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b681945d27e20f013f7e7b0e648f92" id="r_a85b681945d27e20f013f7e7b0e648f92"><td class="memItemLeft" align="right" valign="top"><a id="a85b681945d27e20f013f7e7b0e648f92" name="a85b681945d27e20f013f7e7b0e648f92"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>importCard</b> (const <a class="el" href="classstormm_1_1energy_1_1ScoreCard.html">ScoreCard</a> &amp;other, const std::vector&lt; int &gt; &amp;fill_indices, const std::vector&lt; int &gt; &amp;source_indices)</td></tr>
<tr class="separator:a85b681945d27e20f013f7e7b0e648f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Track the energy components of a collection of systems in an HPC-capable array. This object uses the familiar trick of defining an enumerator (StateVariables) with a final entry to indicate its total length, so that if more energy components need to be tracked in the future the storage and indexing can automatically adjust with new entries. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aae5531c4e2aa693af1507c9d38f0c753" name="aae5531c4e2aa693af1507c9d38f0c753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae5531c4e2aa693af1507c9d38f0c753">&#9670;&#160;</a></span>ScoreCard() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">stormm::energy::ScoreCard::ScoreCard </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>system_count_in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>capacity_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">16</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nrg_scale_bits_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">default_energy_scale_bits</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The constructor requires only the number of systems. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">system_count_in</td><td>The number of systems to track </td></tr>
    <tr><td class="paramname">capacity_in</td><td>The capacity (samples per energy component in each system) to initially allocate for </td></tr>
    <tr><td class="paramname">nrg_scale_bits_in</td><td>Number of bits after the decimal with which to store energy values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef23d2b197bcaea68d8d607def275859" name="aef23d2b197bcaea68d8d607def275859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef23d2b197bcaea68d8d607def275859">&#9670;&#160;</a></span>ScoreCard() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">stormm::energy::ScoreCard::ScoreCard </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstormm_1_1energy_1_1ScoreCard.html">ScoreCard</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>original</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy and move constructors help make the energy tracker a first-class C++ object. The defaults apply as there are no const member variables and no POINTER-kind <a class="el" href="classstormm_1_1review_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">original</td><td>The original energy tracking object to build from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae4fa92298f4f5180712f351a07c2bc62" name="ae4fa92298f4f5180712f351a07c2bc62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4fa92298f4f5180712f351a07c2bc62">&#9670;&#160;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::energy::ScoreCard::add </td>
          <td>(</td>
          <td class="paramtype">StateVariable</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llint</td>          <td class="paramname"><span class="paramname"><em>amount</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>system_index</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a result to a growing total in one of the instantaneous state variable accumulators. This is for CPU activity; on the GPU, the contributions will occur as part of each energy kernel using pointers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>The state variable to which this contribution belongs, i.e. bond energy </td></tr>
    <tr><td class="paramname">amount</td><td>Amount to contribute to said state variable (in fixed precision format) </td></tr>
    <tr><td class="paramname">system_index</td><td>Index of the system (among a list of those being tracked) that the contrbution describes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3fc912255c2b48d484c15d136c773e2f" name="a3fc912255c2b48d484c15d136c773e2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fc912255c2b48d484c15d136c773e2f">&#9670;&#160;</a></span>commit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::energy::ScoreCard::commit </td>
          <td>(</td>
          <td class="paramtype">StateVariable</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>system_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GpuDetails &amp;</td>          <td class="paramname"><span class="paramname"><em>gpu</em></span><span class="paramdefsep"> = </span><span class="paramdefval">null_gpu</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Commit the (assumed complete) accumulated results in one or more state variables to the running tallies and time series kept for statistical purposes. </p>
<p>Overloaded:</p><ul>
<li>Commit results for a single state variable</li>
<li>Commit results for a list of specific state variables</li>
<li>Commit results for all state variables</li>
<li>Commit results for a single system, or for all systems</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>The state variable to which this contribution belongs, i.e. bond energy </td></tr>
    <tr><td class="paramname">system_index</td><td>Index of the system (among a list of those being tracked) that the contrbution describes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03f8b654a44cc77593042a7e8018d121" name="a03f8b654a44cc77593042a7e8018d121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f8b654a44cc77593042a7e8018d121">&#9670;&#160;</a></span>computePotentialEnergy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::energy::ScoreCard::computePotentialEnergy </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GpuDetails &amp;</td>          <td class="paramname"><span class="paramname"><em>gpu</em></span><span class="paramdefsep"> = </span><span class="paramdefval">null_gpu</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute total potential energies for all systems in the instantaneous accumulators as well as all time series accumulators. This total is not automatically computed by various interaction evaluations, which only compute individual "components" of this quantity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tier</td><td>Perform this operation on the CPU host or GPU device </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a015a86d739b43ccd32b8320ad5f71ac0" name="a015a86d739b43ccd32b8320ad5f71ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a015a86d739b43ccd32b8320ad5f71ac0">&#9670;&#160;</a></span>computeTotalEnergy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::energy::ScoreCard::computeTotalEnergy </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GpuDetails &amp;</td>          <td class="paramname"><span class="paramname"><em>gpu</em></span><span class="paramdefsep"> = </span><span class="paramdefval">null_gpu</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute total energies for all systems in the instantaneous accumulators as well as all time series accumulators. This total is not automatically computed by various interaction evaluations, which only compute individual "components" of this quantity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tier</td><td>Perform this operation on the CPU host or GPU device </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa646b2b3319786cc6895be6bd5b3c658" name="aa646b2b3319786cc6895be6bd5b3c658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa646b2b3319786cc6895be6bd5b3c658">&#9670;&#160;</a></span>contribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::energy::ScoreCard::contribute </td>
          <td>(</td>
          <td class="paramtype">StateVariable</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llint</td>          <td class="paramname"><span class="paramname"><em>amount</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>system_index</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Place a result into one of the instantaneous state variable accumulators. This is for CPU activity; on the GPU, the contributions will occur as part of each energy kernel using pointers. This will automatically update running accumulators for statistical tracking. It is add + commit, below. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>The state variable to which this contribution belongs, i.e. bond energy </td></tr>
    <tr><td class="paramname">amount</td><td>Amount to contribute to said state variable (in fixed precision format) </td></tr>
    <tr><td class="paramname">system_index</td><td>Index of the system (among a list of those being tracked) that the contrbution describes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d8f30ae0c156b229a2d046285ac1164" name="a1d8f30ae0c156b229a2d046285ac1164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d8f30ae0c156b229a2d046285ac1164">&#9670;&#160;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const ScoreCardReader stormm::energy::ScoreCard::data </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the appropriate abstract based on the const-ness of the abstract. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tier</td><td>Get pointers to data on the host or on the HPC accelerator device </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89bf8d1a524d5bbb42ea5ff557aac2e9" name="a89bf8d1a524d5bbb42ea5ff557aac2e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89bf8d1a524d5bbb42ea5ff557aac2e9">&#9670;&#160;</a></span>getTimeStep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stormm::energy::ScoreCard::getTimeStep </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>time_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the time step at which a particular energy value was taken. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time_index</td><td>The index of the energies and time step number in question </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a318c7dead77e3cfd9cc6defc0de912d1" name="a318c7dead77e3cfd9cc6defc0de912d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a318c7dead77e3cfd9cc6defc0de912d1">&#9670;&#160;</a></span>importCard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::energy::ScoreCard::importCard </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstormm_1_1energy_1_1ScoreCard.html">ScoreCard</a> *</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>fill_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>source_index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import the results of another <a class="el" href="classstormm_1_1review_1_1ScoreCard.html" title="Track the energy components of a collection of systems in an HPC-capable array. This object uses the ...">ScoreCard</a> into this one, including all components and the associated energy history. If the current object does not have sufficient space either in terms of systems or sample capacity (depth of history), it will be re-allocated. This functionality is available on the GPU as a free function energyCopy(), which allows the reader from the source and the writer from the destination to be used rather than a long series of pointers and array size constants. </p>
<p>Overloaded:</p><ul>
<li>Supply a const pointer or const reference to the other energy tracking object</li>
<li>Import a single system into a specific index.</li>
<li>Import multiple systems into multiple indices.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other energy tracking object </td></tr>
    <tr><td class="paramname">fill_index</td><td>System index of the current object to import results into </td></tr>
    <tr><td class="paramname">fill_indices</td><td>System indices of the current object to import results into </td></tr>
    <tr><td class="paramname">source_index</td><td>System index of the original object to import results from </td></tr>
    <tr><td class="paramname">source_indices</td><td>System indices of the original object to import results from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3588a0688ec6cd1ee5f65ea8c850aa96" name="a3588a0688ec6cd1ee5f65ea8c850aa96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3588a0688ec6cd1ee5f65ea8c850aa96">&#9670;&#160;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::energy::ScoreCard::initialize </td>
          <td>(</td>
          <td class="paramtype">StateVariable</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>system_index</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GpuDetails &amp;</td>          <td class="paramname"><span class="paramname"><em>gpu</em></span><span class="paramdefsep"> = </span><span class="paramdefval">null_gpu</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize some or all instantaneous state variable accumulators. If all state variable accumulators are initialized in all systems, the sample counter will also be reset. </p>
<p>Overloaded:</p><ul>
<li>Initialize a single state variable accumulator</li>
<li>Initialize a list of state variable accumulators</li>
<li>Initialize all state variable accumulators in one or more systems</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>The state variable to initialize </td></tr>
    <tr><td class="paramname">system_index</td><td>Index of the system (among a list of those being tracked) that the contrbution describes </td></tr>
    <tr><td class="paramname">tier</td><td>Indicate whether to initialize accumulators on the host or device </td></tr>
    <tr><td class="paramname">gpu</td><td>Details of the HPC device in use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2fc4e26cfbd3ab01363153e3e1cea6b5" name="a2fc4e26cfbd3ab01363153e3e1cea6b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fc4e26cfbd3ab01363153e3e1cea6b5">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstormm_1_1energy_1_1ScoreCard.html">ScoreCard</a> &amp; stormm::energy::ScoreCard::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstormm_1_1energy_1_1ScoreCard.html">ScoreCard</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy and move assignment operators complete the support for integrating this energy tracker with Standard Template Library mechanics. The defaults apply as there are no const member variables and no POINTER-kind <a class="el" href="classstormm_1_1review_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Object to which the present <a class="el" href="classstormm_1_1review_1_1ScoreCard.html" title="Track the energy components of a collection of systems in an HPC-capable array. This object uses the ...">ScoreCard</a> shall be equated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8897d8f488abaea55080064151c70a0d" name="a8897d8f488abaea55080064151c70a0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8897d8f488abaea55080064151c70a0d">&#9670;&#160;</a></span>reportAverageStates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; stormm::energy::ScoreCard::reportAverageStates </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Report averaged results in kcal/mol, as a double-precision vector. </p>
<p>Overloaded:</p><ul>
<li>Report results for all systems (the vector will be concatenated, with padding removed)</li>
<li>Report results for a single system</li>
<li>Report a specific result for all systems</li>
<li>Report a specific result for a single system</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">system_index</td><td>Index of the system of interest within all of those being tracked </td></tr>
    <tr><td class="paramname">aspect</td><td>The type of energy or virial quantity of interest </td></tr>
    <tr><td class="paramname">tier</td><td>Level from which to extract the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1d3a243e459ccc7af728b943ec24d83" name="aa1d3a243e459ccc7af728b943ec24d83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1d3a243e459ccc7af728b943ec24d83">&#9670;&#160;</a></span>reportHistory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; stormm::energy::ScoreCard::reportHistory </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>system_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Report the energy history for one or more systems. </p>
<p>Overloaded:</p><ul>
<li>Report the total energy history, as recorded on either the host or GPU device</li>
<li>Report the history of a specific energy component</li>
<li>Report results for a specific system or as the mean and standard deviation (in the x and y components of a <a class="el" href="structstormm_1_1double2.html">double2</a> tuple) of all systems</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">system_index</td><td>Index of the system of interest within all of those being tracked </td></tr>
    <tr><td class="paramname">aspect</td><td>The type of energy or virial quantity of interest (if none is specified the history of systems' total energy will be reported, taking elements from all potential and kinetic energy sources) </td></tr>
    <tr><td class="paramname">tier</td><td>Level from which to extract the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ac609c67a536a0e46f3fee1545f28ce" name="a7ac609c67a536a0e46f3fee1545f28ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ac609c67a536a0e46f3fee1545f28ce">&#9670;&#160;</a></span>reportInstantaneousStates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; stormm::energy::ScoreCard::reportInstantaneousStates </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Report instantaneous results in kcal/mol, as a double-precision vector. </p>
<p>Overloaded:</p><ul>
<li>Report results for all systems (the vector will be concatenated, with padding removed)</li>
<li>Report results for a single system</li>
<li>Report a specific result for all systems</li>
<li>Report a specific result for a single system</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">system_index</td><td>Index of the system of interest within all of those being tracked </td></tr>
    <tr><td class="paramname">aspect</td><td>The type of energy or virial quantity of interest </td></tr>
    <tr><td class="paramname">tier</td><td>Level from which to extract the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77a6f0594a3ea02beeae26fc080018d1" name="a77a6f0594a3ea02beeae26fc080018d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a6f0594a3ea02beeae26fc080018d1">&#9670;&#160;</a></span>reportPotentialEnergies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; stormm::energy::ScoreCard::reportPotentialEnergies </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Report the total energy, or total potential energy, for one system or for all systems. Each result will be summed in the internal fixed-point accumulation before conversion to real values in units of kcal/mol. </p>
<p>Overloaded:</p><ul>
<li>Sum the total or potential energies of a selected system</li>
<li>Sum the total or potential energies of all systems</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">system_index</td><td>Index of the system of interest </td></tr>
    <tr><td class="paramname">tier</td><td>Level from which to extract the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a041612637854eb8d46f79161dff9e6da" name="a041612637854eb8d46f79161dff9e6da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a041612637854eb8d46f79161dff9e6da">&#9670;&#160;</a></span>reportVarianceOfStates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; stormm::energy::ScoreCard::reportVarianceOfStates </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Report standard deviations in kcal/mol, as a double-precision vector. </p>
<p>Overloaded:</p><ul>
<li>Report results for all systems (the vector will be concatenated, with padding removed)</li>
<li>Report results for a single system</li>
<li>Report a specific result for all systems</li>
<li>Report a specific result for a single system</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">system_index</td><td>Index of the system of interest within all of those being tracked </td></tr>
    <tr><td class="paramname">aspect</td><td>The type of energy or virial quantity of interest </td></tr>
    <tr><td class="paramname">tier</td><td>Level from which to extract the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae39575d3d5c399d7426e7d61696829b3" name="ae39575d3d5c399d7426e7d61696829b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae39575d3d5c399d7426e7d61696829b3">&#9670;&#160;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::energy::ScoreCard::reserve </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>new_capacity</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reserve space for storing sampled energy component values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_capacity</td><td>The new capacity to allocate for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2cb03021139d2fca395bfbe5507ba6f" name="aa2cb03021139d2fca395bfbe5507ba6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2cb03021139d2fca395bfbe5507ba6f">&#9670;&#160;</a></span>resetSampleCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::energy::ScoreCard::resetSampleCount </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>count_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the sample counter (this is implicitly done by <a class="el" href="classstormm_1_1energy_1_1ScoreCard.html#a3588a0688ec6cd1ee5f65ea8c850aa96" title="Initialize some or all instantaneous state variable accumulators. If all state variable accumulators ...">initialize()</a> if that function is called to operate on all start variables and all systems, on either the host or HPC device). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count_in</td><td>The number of samples to set the object as having (default 0, full reset) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab05860447c4f78902c87aa27cb639d6f" name="ab05860447c4f78902c87aa27cb639d6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab05860447c4f78902c87aa27cb639d6f">&#9670;&#160;</a></span>setLastTimeStep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::energy::ScoreCard::setLastTimeStep </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>time_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the time index for the most recent stored set of energies. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time_index</td><td>Set the time index </td></tr>
    <tr><td class="paramname">tier</td><td>The memory level at which to set the time step </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/Potential/<a class="el" href="scorecard_8h_source.html">scorecard.h</a></li>
<li>src/Potential/<b>scorecard.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2
</small></address>
</div><!-- doc-content -->
</body>
</html>
