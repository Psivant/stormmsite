<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.15" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme='dark'] {
        --vp-c-bg: #22272e;
      }

      html,
      body {
        background-color: var(--vp-c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme')
      const systemDarkMode =
        'matchMedia' in window
          ? window.matchMedia('(prefers-color-scheme: dark)').matches
          : false

      if (userMode === 'light') {
        document.documentElement.dataset.theme = 'light'
      } else if (userMode === 'dark' || systemDarkMode) {
        document.documentElement.dataset.theme = 'dark'
      }
    </script>
    <title>The Molecular Mechanics Workbench: Creating and Unpacking STORMM's Topologies and Coordinates | STORMM</title><meta name="description" content="Structure and TOpology Replica Molecular Mechanics">
    <link rel="preload" href="/assets/style-W5EDh6sg.css" as="style"><link rel="stylesheet" href="/assets/style-W5EDh6sg.css">
    <link rel="modulepreload" href="/assets/app-CrNxYCqk.js"><link rel="modulepreload" href="/assets/tutorial_iv.html-BFpgC_lb.js">
    <link rel="prefetch" href="/assets/index.html-DZ31HPgO.js" as="script"><link rel="prefetch" href="/assets/contents.html-DfsOTOJG.js" as="script"><link rel="prefetch" href="/assets/dev-philosophy.html-CmRbWznu.js" as="script"><link rel="prefetch" href="/assets/dev-tutorials.html-C51BJ_C7.js" as="script"><link rel="prefetch" href="/assets/get-started.html-C4TiqGw8.js" as="script"><link rel="prefetch" href="/assets/stormm-md.html-DeRxRQbm.js" as="script"><link rel="prefetch" href="/assets/user-tutorials.html-DFpNjgtY.js" as="script"><link rel="prefetch" href="/assets/why-stormm.html-DKkd8M0s.js" as="script"><link rel="prefetch" href="/assets/docker.html-Aa_mgiJl.js" as="script"><link rel="prefetch" href="/assets/tutorial_i.html-DDJFjnzt.js" as="script"><link rel="prefetch" href="/assets/tutorial_ii.html-DhD-BYlp.js" as="script"><link rel="prefetch" href="/assets/tutorial_iii.html-BEsHlgag.js" as="script"><link rel="prefetch" href="/assets/404.html-BgpAg0oD.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="vp-theme-container external-link-icon" vp-container><!--[--><header class="vp-navbar" vp-navbar><div class="vp-toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a class="route-link" href="/"><!----><span class="vp-site-name" aria-hidden="true">STORMM</span></a></span><div class="vp-navbar-items-wrapper" style=""><!--[--><!--]--><nav class="vp-navbar-items vp-hide-mobile" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/" aria-label="Home"><!---->Home<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/get-started.html" aria-label="Getting Started with STORMM"><!---->Getting Started with STORMM<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/contents.html" aria-label="Table of Contents"><!---->Table of Contents<!----></a></div><!--]--></nav><!--[--><!--]--><button type="button" class="vp-toggle-color-mode-button" title="toggle color mode"><svg class="light-icon" viewbox="0 0 32 32" style=""><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg class="dark-icon" viewbox="0 0 32 32" style="display:none;"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="vp-sidebar-mask"></div><!--[--><aside class="vp-sidebar" vp-sidebar><nav class="vp-navbar-items" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/" aria-label="Home"><!---->Home<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/get-started.html" aria-label="Getting Started with STORMM"><!---->Getting Started with STORMM<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/contents.html" aria-label="Table of Contents"><!---->Table of Contents<!----></a></div><!--]--></nav><!--[--><!--]--><ul class="vp-sidebar-items"><!--[--><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">The Molecular Mechanics Workbench: Creating and Unpacking STORMM&#39;s Topologies and Coordinates <!----></p><!----></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="vp-page"><!--[--><!--]--><div class="theme-default-content" vp-content><!--[--><!--]--><div><h1 id="the-molecular-mechanics-workbench-creating-and-unpacking-stormm-s-topologies-and-coordinates" tabindex="-1"><a class="header-anchor" href="#the-molecular-mechanics-workbench-creating-and-unpacking-stormm-s-topologies-and-coordinates"><span>The Molecular Mechanics Workbench: Creating and Unpacking STORMM&#39;s Topologies and Coordinates</span></a></h1><p>Memory management, class conventions, and input mechanisms are essential preconditions for a programming environment that supports GPU programming, but the purpose of STORMM is to collect many molecular systems into a single program instance and have them communicate where helpful or subdivide into some common denominator of work units to stack problems together when the goal is to optimize GPU utilization. First, we will need a topology class, which in STORMM is the <code>AtomGraph</code>. Second, we require a means for storing structures, and also perhaps atomic velocities and force accumulators, and for that STORMM has several options. There are five distinct classes for storing structures in STORMM, and in this tutorial we will focus on the <code>PhaseSpace</code>. To collect systems together and make them a super-problem amenable to GPU computing, <a href="../dev-philosophy#syntheses-not-just-arrays-of-topologies-or-coordinate-sets">topologies and coordinates collate into syntheses</a>, as described elsewhere on the site.</p><h2 id="reading-individual-topologies-and-structures-from-files" tabindex="-1"><a class="header-anchor" href="#reading-individual-topologies-and-structures-from-files"><span>Reading Individual Topologies and Structures from Files</span></a></h2><p>We can configure command line arguments to accept the names of topology and input coordinate files for any molecular system, and even multiple systems. Following on <a href="./tutorial_iii">the previous tutorial</a> this is done with a <code>CommandLineParser</code> as shown in the code below:</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">#include &quot;/stormm/home/src/Namelists/command_line_parser.h&quot;</span>
<span class="line">#include &quot;/stormm/home/src/Namelists/namelist_emulator.h&quot;</span>
<span class="line">#include &quot;/stormm/home/src/Namelists/namelist_enumerators.h&quot;</span>
<span class="line"></span>
<span class="line">using stormm::namelist::CommandLineParser;</span>
<span class="line">using stormm::namelist::DefaultIsObligatory;</span>
<span class="line">using stormm::namelist::InputRepeats;</span>
<span class="line">using stormm::namelist::NamelistEmulator;</span>
<span class="line">using stormm::namelist::NamelistType;</span>
<span class="line"></span>
<span class="line">  CommandLineParser clip(&quot;tutorial_iv&quot;, &quot;A demonstration of topology and coordinate manipulation &quot;</span>
<span class="line">                         &quot;in STORMM&quot;);</span>
<span class="line">  NamelistEmulator *t_nml = clip.getNamelistPointer();</span>
<span class="line">  t_nml-&gt;addKeyword(&quot;-topol&quot;, NamelistType::STRING, std::string(&quot;&quot;), DefaultIsObligatory::NO,</span>
<span class="line">                    InputRepeats::YES);</span>
<span class="line">  t_nml-&gt;addHelp(&quot;-topol&quot;, &quot;Select a topology file.  This input may be repeated.\n&quot;);</span>
<span class="line">  t_nml-&gt;addKeyword(&quot;-coord&quot;, NamelistType::STRING, std::string(&quot;&quot;), DefaultIsObligatory::NO,</span>
<span class="line">                    InputRepeats::YES);</span>
<span class="line">  t_nml-&gt;addHelp(&quot;-topol&quot;, &quot;Select an input coordinate file.  This input may be repeated.\n&quot;);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="establishing-a-test-framework" tabindex="-1"><a class="header-anchor" href="#establishing-a-test-framework"><span>Establishing a Test Framework</span></a></h2><p>Anticipating some tests that will be done on each system to showcase how to unpack a topology, we can also boot up a wall time tracker to help convey a sense of how much some basic CPU operations will cost.</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">#include &quot;/stormm/home/src/UnitTesting/stopwatch.h&quot;</span>
<span class="line"></span>
<span class="line">using stormm::testing::StopWatch;</span>
<span class="line"></span>
<span class="line">  StopWatch the_clock(&quot;STORMM Tutorial IV&quot;);</span>
<span class="line">  const int file_read_tm  = the_clock.addCategory(&quot;File Reading&quot;);</span>
<span class="line">  const int chem_work_tm  = the_clock.addCategory(&quot;Chemical Features Detection&quot;);</span>
<span class="line">  const int excl_work_tm  = the_clock.addCategory(&quot;Non-bonded Exclusion Detection&quot;);</span>
<span class="line">  const int basic_nonb_tm = the_clock.addCategory(&quot;Basic Non-bonded Evaluation&quot;);</span>
<span class="line">  const int clean_nonb_tm = the_clock.addCategory(&quot;Non-bonded Evaluation Cleanup&quot;);</span>
<span class="line">  const int excl_nonb_tm  = the_clock.addCategory(&quot;Excluded Non-bonded Evaluation&quot;);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>When we unpack topologies and manipulate data in a coordinate object, it is important to know that the results are correct, and for that we need a unit testing framework. This is an opportunity to showcase STORMM&#39;s native unit testing features. Unit tests are collected and tracked within a global object of the <a class="route-link" href="/doxygen/classstormm_1_1testing_1_1CheckList.html"><code>CheckList</code></a> class while certain tolerances for the tests and their display is tracked using the <a class="route-link" href="/doxygen/classstormm_1_1testing_1_1TestEnvironment.html"><code>TestEnvironment</code></a>, which like the <code>StopWatch</code> permits the developer to categorize tests. We will construct the <code>TestEnvironment</code> object with the already created <code>CommandLineParser</code> object, as the <code>TestEnvironment</code> also scours the command line for specific directives.</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">#include &quot;/stormm/home/src/UnitTesting/test_environment.h&quot;</span>
<span class="line"></span>
<span class="line">using stormm::testing::TestEnvironment;</span>
<span class="line"></span>
<span class="line">  TestEnvironment tenv(argc, argv, &amp;clip);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Furthermore, by importing Unit tests can be categorized by declaring different sections with titles inside of the global <code>CheckList gbl_test_results</code>, using the <code>section</code> function:</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">#include &quot;/stormm/home/src/UnitTesting/unit_test.h&quot;</span>
<span class="line"></span>
<span class="line">using stormm::testing::section;</span>
<span class="line"></span>
<span class="line">section(&quot;Total charge&quot;);</span>
<span class="line">section(&quot;Non-bonded electrostatics&quot;);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Of course, without knowing <em>a priori</em> what systems will come in from the command line, we will need to limit most tests to verifying the equality of quantities that can be evaluated in multiple ways with independent implementations.</p><h2 id="reading-structures-and-topologies" tabindex="-1"><a class="header-anchor" href="#reading-structures-and-topologies"><span>Reading Structures and Topologies</span></a></h2><p>Both topologies and structure class objects can be constructed based on file names in STORMM (each of the constructors have a number of default arguments, which will be ignored for the purposes of this tutorial). The file names are present in the <code>NamelistEmulator</code> member of the <code>CommandLineParser</code>. It is one case in which we will not make the effort to encapsulate the user input in a separate class object, as the command line data will not be needed again (and also because the various <code>const</code>-qualified integers and arrays of strings we are creating in <code>main</code> are what such a class object would contain). To hold atomic positions and also allocate space for force calculations, we will choose an object of the <a class="route-link" href="/doxygen/classstormm_1_1trajectory_1_1PhaseSpace.html"><code>PhaseSpace</code></a> class, and make a <code>std::vector</code> of these objects to hold the initial coordinates of each system.</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line"></span>
<span class="line">using stormm::topology::AtomGraph;</span>
<span class="line">using stormm::trajectory::PhaseSpace;</span>
<span class="line"></span>
<span class="line">  const int ntop = t_nml-&gt;getKeywordEntries(&quot;-topol&quot;);</span>
<span class="line">  const int ncrd = t_nml-&gt;getKeywordEntries(&quot;-coord&quot;);</span>
<span class="line">  std::vector&lt;std::string&gt; user_defined_topologies;</span>
<span class="line">  user_defined_topologies.reserve(ntop);</span>
<span class="line">  std::vector&lt;std::string&gt; user_defined_coordinates;</span>
<span class="line">  user_defined_coordinates.reserve(ncrd);</span>
<span class="line">  for (int i = 0; i &lt; ntop; i++) {</span>
<span class="line">    user_defined_topologies.push_back(t_nml-&gt;getStringValue(&quot;-topol&quot;, i));</span>
<span class="line">  }</span>
<span class="line">  for (int i = 0; i &lt; ncrd; i++) {</span>
<span class="line">    user_defined_coordinates.push_back(t_nml-&gt;getStringValue(&quot;-coord&quot;, i));</span>
<span class="line">  }</span>
<span class="line">  std::vector&lt;AtomGraph&gt; agv;</span>
<span class="line">  if (ntop == 0) {</span>
<span class="line">    rtErr(&quot;At least one topology must be provided.&quot;);</span>
<span class="line">  }</span>
<span class="line">  for (int i = 0; i &lt; ntop; i++) {</span>
<span class="line">    agv.emplace_back(user_defined_topologies[i]);</span>
<span class="line">  }</span>
<span class="line">  std::vector&lt;PhaseSpace&gt; psv;</span>
<span class="line">  for (int i = 0; i &lt; ncrd; i++) {</span>
<span class="line">    psv.emplace_back(user_defined_coordinates[i]);</span>
<span class="line">  }</span>
<span class="line">  the_clock.assignTime(file_read_tm);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Once the above code executes, the files will be read and the information organized. In the topology, there is a lot of O(<em>N</em>) analysis in the numbers of atoms, valence interaction terms, and other properties that will take place in order to construct the <code>AtomGraph</code> (the class and its associated utility functions span more than 5,000 lines of C++). We can now run our first test of the results (perhaps to check that there is one topology for every structure provided, but that is trivial). We will check whether the topologies appear to match the structures, in the order they were provided:</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">using stormm::testing::RelationalOperator;</span>
<span class="line"></span>
<span class="line">  const int failures_pt_a = gbl_test_results.getOverallFailureCount();</span>
<span class="line">  for (int i = 0; i &lt; std::min(ncrd, ntop); i++) {</span>
<span class="line">    check(agv[i].getAtomCount(), RelationalOperator::EQUAL, psv[i].getAtomCount(), &quot;The number of &quot;</span>
<span class="line">          &quot;atoms in supplied topology &quot; + std::to_string(i + 1) + &quot; (&quot; +</span>
<span class="line">          std::to_string(agv[i].getAtomCount()) + &quot;) does not match the number of atoms in the &quot;</span>
<span class="line">          &quot;corresponding coordinate set (&quot; + std::to_string(psv[i].getAtomCount()) + &quot;).&quot;,</span>
<span class="line">          TestPriority::NON_CRITICAL);</span>
<span class="line">  }</span>
<span class="line">  const bool all_match = (failures_pt_a == gbl_test_results.getOverallFailureCount());</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>In the above, we are storing a record of the number of failures before checks on the system sanity, (anticipating that future additions to the program might insert other unit tests), then comparing it to the number of failures after the sanity checks to ensure that all of them have passed. We could also have done this by declaring a new section for these specific tests:</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">using stormm::testing::section;</span>
<span class="line"></span>
<span class="line">  section(&quot;Sanity checks on systems&quot;);</span>
<span class="line">  &lt;... sanity checks here ...&gt;</span>
<span class="line">  const int sanity_chk_id = gbl_test_results.getCurrentSection();</span>
<span class="line">  const bool all_match = (gbl_test_results.getFailureCount(sanity_chk_id) == 0);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Feeding <code>gbl_test_results.getCurrentSection()</code> to the <code>CheckList</code> method for accessing the failure count is not necessary, as by default it returns the result pertaining to the current section, but as with other implementations in this tutorial the goal is explicit pronunciation of inputs to demonstrate how things work.</p><h2 id="a-look-at-the-chemistry-of-each-topology" tabindex="-1"><a class="header-anchor" href="#a-look-at-the-chemistry-of-each-topology"><span>A Look at the Chemistry of Each Topology</span></a></h2><p>With a topology in hand, there are a number of class objects that can be created to facilitate calculations. The first is a <a class="route-link" href="/doxygen/classstormm_1_1chemistry_1_1ChemicalFeatures.html"><code>ChemicalFeatures</code></a> object, which was created to detect, at a basic level, the rotatable bonds in the system. In much the same way that STORMM builds its own unit testing rather than include a dependency, we built a lightweight class to analyze the chemical environments in any system that STORMM reads, without having to install something heavier like <a href="https://github.com/rdkit/rdkit" target="_blank" rel="noopener noreferrer">RDKit</a> and ship information to and from the package. We do intend to have STORMM function in the context of Python and communicate with RDKit in particular, but in the early development we realized that RDKit needs definitions of bond orders <em>as inputs</em>, and for us calculating the bond orders in organic molecules was both relatively simple and integral to deciding which bonds rotate. We also came up with unique solutions to basic problems like assigning formal charges to atoms: STORMM uses an implementation of the <a href="https://jcheminf.biomedcentral.com/articles/10.1186/s13321-019-0340-0" target="_blank" rel="noopener noreferrer">Indigo method</a>, and calculates all structures that participate in resonance to compute average formal charges. STORMM will assign -0.5<em>e</em> charge to each oxygen of a carboxylate rather than placing -1.0<em>e</em> on one and zero on the other. With an array of topologies (<code>std::vector&lt;AtomGraph&gt;</code>), we can create an array of corresponding <code>ChemicalFeatures</code> objects:</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">#include &quot;/stormm/home/src/Chemistry/chemical_features.h&quot;</span>
<span class="line"></span>
<span class="line">using stormm::chemistry::ChemicalFeatures;</span>
<span class="line"></span>
<span class="line">  const int chem_work_tm  = the_clock.addCategory(&quot;Chemical Features Detection&quot;);</span>
<span class="line">  std::vector&lt;ChemicalFeatures&gt; ftv;</span>
<span class="line">  for (int i = 0; i &lt; ntop; i++) {</span>
<span class="line">    if (all_match) {</span>
<span class="line">      ftv.emplace_back(agv[i], psv[i]);</span>
<span class="line">    }</span>
<span class="line">    else {</span>
<span class="line">      ftv.emplace_back(agv[i]);</span>
<span class="line">    }</span>
<span class="line">  }</span>
<span class="line">  the_clock.assignTime(chem_work_tm);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The <code>ChemicalFeatures</code> object works at the level of C++, although a GPU-compatible form of its data that collects properties for many systems together is in development (for making conformer seeding run on the GPU). The objects are quick to construct, and can be queried for various results through C++ accessors. (The <code>ChemicalFeatures</code> class also produce abstracts, but we won&#39;t provide examples using them here.)</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">  printf(&quot;Properties of each system:\n\n&quot;);</span>
<span class="line">  printf(&quot;                               Net      Molecular  Chiral  Aromatic Rotatable\n&quot;);</span>
<span class="line">  printf(&quot;    System       Atoms Bonds  Charge     Weight    Centers  Groups    Bonds  \n&quot;);</span>
<span class="line">  printf(&quot;--------------   ----- ----- -------- ------------ ------- -------- ---------\n&quot;);</span>
<span class="line">  for (int i = 0; i &lt; ntop; i++) {</span>
<span class="line">    printf(&quot;%-14.14s : %5d %5d %7.4lf %12.4lf %7d %8d %9d\n&quot;,</span>
<span class="line">           getBaseName(agv[i].getFileName()).c_str(), agv[i].getAtomCount(),</span>
<span class="line">           agv[i].getBondTermCount(), sum&lt;double&gt;(agv[i].getPartialCharge&lt;double&gt;()),</span>
<span class="line">           agv[i].getTotalMass(), ftv[i].getChiralCenterCount(),</span>
<span class="line">           ftv[i].getAromaticGroupCount(), ftv[i].getRotatableBondCount());</span>
<span class="line">  }</span>
<span class="line">  printf(&quot;\n&quot;);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>As can be seen above, <code>ChemicalFeatures</code> includes information about chiral centers, aromaticity, and bond orders. It is enough information to translate a typical molecular dynamics topology and coordinate set into a Biovia SDF, despite the fact that a typical topology does not include bond orders (atom types and bond equilibria or force constants, but not explicit bond orders). This will provide a stepping stone to the more advanced capabilities in RDKit, and gives developers some fundamental tools for chemical perception without any external dependencies.</p><h2 id="getting-ready-to-simulate-making-an-exclusion-table" tabindex="-1"><a class="header-anchor" href="#getting-ready-to-simulate-making-an-exclusion-table"><span>Getting Ready to Simulate: Making an Exclusion Table</span></a></h2><p>Molecular dynamics would be so simple, but for the fact that particles bonded to one another do not participate in non-bonded interactions (which would be very strained if taking their non-bonded parameters at face value). Some sort of bookkeeping to address this question is a pervasive need in any program that does molecular mechanics, and STORMM provides a simple way to get a sophisticated object for tracking exclusions which evaluates in such a trivial amount of time that it can be incorporated into a molecular dynamics inner loop. This is the <a class="route-link" href="/doxygen/classstormm_1_1energy_1_1LocalExclusionMask.html"><code>LocalExclusionMask</code></a>, and objects of this class can be created for each topology as shown below:</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">#include &quot;/stormm/home/src/Potential/local_exclusionmask.h&quot;</span>
<span class="line"></span>
<span class="line">  using stormm::energy::LocalExclusionMask;</span>
<span class="line"></span>
<span class="line">  const int excl_work_tm  = the_clock.addCategory(&quot;Non-bonded Exclusion Detection&quot;);</span>
<span class="line">  std::vector&lt;LocalExclusionMask&gt; exv;</span>
<span class="line">  for (int i = 0; i &lt; ntop; i++) {</span>
<span class="line">    exv.emplace_back(agv[i]);</span>
<span class="line">  }</span>
<span class="line">  the_clock.assignTime(excl_work_tm);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The <code>LocalExclusionMask</code> does not participate in the current implicit solvent molecular dynamics / energy minimization implementation. (It was created later, after some realizations and further research.) It will be used in the forthcoming implementation for explicit solvent molecular simulations in periodic boundary conditions.</p><h2 id="a-basic-electrostatic-calculation" tabindex="-1"><a class="header-anchor" href="#a-basic-electrostatic-calculation"><span>A Basic Electrostatic Calculation</span></a></h2><p>The electrostatics calculation we will perform is simple in concept: <em>compute the Coulomb interaction of all pairs of particles in the system</em>. The code for something like that could be:</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">#include &quot;/stormm/home/src/Constants/symbol_values.h&quot;</span>
<span class="line"></span>
<span class="line">using stormm::symbols::charmm_gromacs_bioq;</span>
<span class="line">using stormm::topology::NonbondedKit;</span>
<span class="line">using stormm::trajectory::PhaseSpaceReader;</span>
<span class="line"></span>
<span class="line">  for (int top_idx = 0; top_idx &lt; ntop; top_idx++) {</span>
<span class="line">    const NonbondedKit&lt;double&gt; inbk = agv[top_idx].getDoublePrecisionNonbondedKit();</span>
<span class="line">    const PhaseSpaceReader ipsr = psv[top_idx].data();</span>
<span class="line">    double basic_elec_nrg = 0.0;</span>
<span class="line">    for (int i = 1; i &lt; ipsr.natom; i++) {</span>
<span class="line">      for (int j = 0; j &lt; i; j++) {</span>
<span class="line">        const double qij = inbk.charge[j] * inbk.charge[i];</span>
<span class="line">        const double dx = ipsr.xcrd[j] - ipsr.xcrd[i];</span>
<span class="line">        const double dy = ipsr.ycrd[j] - ipsr.ycrd[i];</span>
<span class="line">        const double dz = ipsr.zcrd[j] - ipsr.zcrd[i];</span>
<span class="line">        const double dr = sqrt((dx * dx) + (dy * dy) + (dz * dz));</span>
<span class="line">        basic_elec_nrg += qij / dr;</span>
<span class="line">      }</span>
<span class="line">    }</span>
<span class="line">  }</span>
<span class="line"></span>
<span class="line">  // Multiply the charge-charge interactions (in atomic units) by Coulomb&#39;s constant</span>
<span class="line">  basic_elec_nrg *= charmm_gromacs_bioq;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>We have already covered one qualification to the interactions, that such that the pair is not connected by three bonds or fewer (so as to participate in some valence term).</p><p>The first qualification to the computation involves how to deal with periodicity. The <code>PhaseSpace</code> objects already created in our program have a member variable <code>unit_cell</code> (use the accessor <code>UnitCellType PhaseSpace::getUnitCellType()</code>, or look at the <code>unit_cell</code> member variable in the <code>PhaseSpaceReader</code> or <code>PhaseSpaceWriter</code> class abstracts). We can use that to determine whether to consider periodic images of the system, as long as we have some convention for computing the distance between particles and their interaction in a periodic setting. Let us take the &quot;minimum image convention,&quot; that the distance between two particles is the smallest possible distance among all images. We can use the <code>imageCoordinates</code> function and feed it the <code>unit_cell</code> member variable:</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">#include &quot;/stormm/home/src/structure/local_arrangement.h&quot;</span>
<span class="line">#include &quot;/stormm/home/src/structure/structure_enumerators.h&quot;</span>
<span class="line"></span>
<span class="line">using stormm::structure::imageCoordinates;</span>
<span class="line">using stormm::structure::ImagingMethod;</span>
<span class="line"></span>
<span class="line">  &lt;... outer loops as above ...&gt;</span>
<span class="line">      for (int j = 0; j &lt; i; j++) {</span>
<span class="line">        const double qij = inbk.charge[j] * qi;</span>
<span class="line">        double dx = ipsr.xcrd[j] - posx;</span>
<span class="line">        double dy = ipsr.ycrd[j] - posy;</span>
<span class="line">        double dz = ipsr.zcrd[j] - posz;</span>
<span class="line">        imageCoordinates&lt;double, double&gt;(&amp;dx, &amp;dy, &amp;dz, ipsr.umat, ipsr.invu, ipsr.unit_cell,</span>
<span class="line">                                         ImagingMethod::MINIMUM_IMAGE);</span>
<span class="line">        const double dr = sqrt((dx * dx) + (dy * dy) + (dz * dz));</span>
<span class="line">        basic_elec_nrg += qij / dr;</span>
<span class="line">      }</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>In the tutorial program <strong>/stormm/home/apps/Tutorial/tutorial_iv.cpp</strong>, the evaluation of the unit cell performed inside of is hard-coded to move it out of the inner loop. The <code>imageCoordinates</code> function is templated and overloaded to deal with single values along each Cartesian axis or arrays of values, batching the unit cell evaluation but at the expense of greater complexity to store the displacements of many particles interacting.</p><p>The second qualification, already covered in this tutorial, is the exclusion status of each interacting pair. As with other STORMM classes, there are two ways to use the <code>LocalExclusionMask</code> in CPU-based code to determine whether a pair of particles <em>a</em> and <em>b</em> omit their non-bonded interaction: the C++ way, by using the <code>bool LocalExclusionMask::testExclusion(int a, int b)</code> class method, and the C way, by feeding the class abstract to a free function of the same name and form. (In fact, both work by being wrappers for the same underlying free function <code>evaluateLocalMask</code> in the <strong>/stormm/home/src/Potential/local_exclusionmask.h</strong> library, with ways of grabbing the first atom&#39;s mask and a pointer to a trove of codified data.) Here&#39;s the inner loop from above, with the exclusion test added (note that the function returns TRUE if the two particle&#39;s <em>should not</em> interact:</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">  double masked_elec_nrg = 0.0;</span>
<span class="line"></span>
<span class="line">  &lt;... outer loops as above ...&gt;</span>
<span class="line">      for (int j = 0; j &lt; i; j++) {</span>
<span class="line">        if (! testExclusion(ilmr, j, i)) {</span>
<span class="line">          const double qij = inbk.charge[j] * qi;</span>
<span class="line">          double dx = ipsr.xcrd[j] - posx;</span>
<span class="line">          double dy = ipsr.ycrd[j] - posy;</span>
<span class="line">          double dz = ipsr.zcrd[j] - posz;</span>
<span class="line">          imageCoordinates&lt;double, double&gt;(&amp;dx, &amp;dy, &amp;dz, ipsr.umat, ipsr.invu, ipsr.unit_cell,</span>
<span class="line">                                           ImagingMethod::MINIMUM_IMAGE);</span>
<span class="line">          const double dr = sqrt((dx * dx) + (dy * dy) + (dz * dz));</span>
<span class="line">          masked_elec_nrg += qij / dr;</span>
<span class="line">        }</span>
<span class="line">      }</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The <code>LocalExclusionMask</code> works by keeping, for every atom, a bit mask &quot;profile&quot; with the atom index itself at the center and the <em>N</em> lower or higher bits being set to 1 if the atom excludes interactions with atoms 1, 2, ... <em>N</em> indices lower or higher in the topology&#39;s atom list. Because the profile is a 64-bit number, this could have N be as large as 31, and that would be very much like what <a href="https://www.acellera.com/acemd" target="_blank" rel="noopener noreferrer">ACEMD</a> does. However, this leaves some holes if atoms exclude indices further away in terms of how the topology keeps them, as can happen with disulfide bridges. Therefore, STORMM shortens the maximum <em>N</em> to 30 in the <em>most basic case</em> and invests the remaining three bits (3 | 30 below | the index itself | 30 above) into a special code that tells the program how to handle the other 61 bits. For the basic case, the special code is 000. For trickier cases, other codes will tell the program to use perhaps just 31 of the remaining bits in the basic way, and then use the rest to mask off a patch much further from the original atom, some of those other bits being devoted to inscribing just how far away that other patch is.</p><p>Because of the local, relative nature of the exclusion profiles, most atoms share the same profile with some other atom in the system--all water, for example, needs just three unique profiles (or four, if the water contains a virtual site). All proteins can be handled in 150 to 200 unique profiles, depending on the ordering of atoms in the parameter libraries, plus 10 to 12 for each disulfide bridge. Therefore, the way the <code>LocalExclusionMask</code> really works is by storing, for each atom in the topology, a 32 bit profile index into the list of all unique 64 bit profiles, which saves half the memory traffic and lets the entire list of profiles reside in chip cache whether computing on the CPU or on the GPU.</p><h2 id="electrostatics-with-and-without-masking" tabindex="-1"><a class="header-anchor" href="#electrostatics-with-and-without-masking"><span>Electrostatics with and without Masking</span></a></h2><p>The tutorial contains additional code to establish an independent check on the non-bonded electrostatic energy, based on an abstract of the topology that the <code>LocalExclusionMask</code> is built with in the first place. If the topology and its <code>NonbondedKit</code> abstract is wrong, then we wouldn&#39;t see the effect, but if the <code>LocalExclusionMask</code> had a but this test would be likely to reveal it. The topology class emits a number of different abstracts, with minimal overlap in terms of the pointers and length constants they offer. We can use the abstract (already taken in the code above) for non-bonded interactions and then loop through its contents to accumulate and then subtract the excluded interactions from <code>basic_elec_nrg</code> above. The one abstract of the <code>LocalExclusionMask</code> will help to get the relevant pointers where they are needed, and it is a convention in STORMM CPU code, &quot;access all involved class objects with accessor functions, or take the abstracts in all cases and use those instead.&quot; What is still needed is some built-from-scratch method for keeping track of exclusions which have been removed, and for that we can use an array of arrays written in terms of the Standard Template Library <code>std::vector</code>.</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">  using stormm::energy::LocalExclusionMaskReader;</span>
<span class="line"></span>
<span class="line">  for (int top_idx = 0; top_idx &lt; ntop; top_idx++) {</span>
<span class="line">    const NonbondedKit&lt;double&gt; inbk = agv[top_idx].getDoublePrecisionNonbondedKit();</span>
<span class="line">    const PhaseSpaceReader ipsr = psv[top_idx].data();</span>
<span class="line">    const LocalExclusionMaskReader ilmr = exv[top_idx].data();</span>
<span class="line">    std::vector&lt;std::vector&lt;int&gt;&gt; excl_counted(ipsr.natom);</span>
<span class="line">    for (int i = 0; i &lt; ipsr.natom; i++) {</span>
<span class="line">      excl_counted[i].reserve(16);</span>
<span class="line">    }</span>
<span class="line">    the_clock.assignTime();</span>
<span class="line">    for (int i = 0; i &lt; ipsr.natom; i++) {</span>
<span class="line">      for (int j = inbk.nb12_bounds[i]; j &lt; inbk.nb12_bounds[i + 1]; j++) {</span>
<span class="line">        const size_t jatom = inbk.nb12x[j];</span>
<span class="line">        if (exclusionKnown(&amp;excl_counted, i, jatom) == false) {</span>
<span class="line">          const double dx = ipsr.xcrd[jatom] - ipsr.xcrd[i];</span>
<span class="line">          const double dy = ipsr.ycrd[jatom] - ipsr.ycrd[i];</span>
<span class="line">          const double dz = ipsr.zcrd[jatom] - ipsr.zcrd[i];</span>
<span class="line">          const double dr = sqrt((dx * dx) + (dy * dy) + (dz * dz));</span>
<span class="line">          const double qij = inbk.charge[i] * inbk.charge[jatom];</span>
<span class="line">          basic_elec_nrg -= qij / dr;</span>
<span class="line">        }</span>
<span class="line">      }</span>
<span class="line"></span>
<span class="line">      &lt;... Repeat for 1-3 and 1-4 interactions, also 1-1 for virtual sites ...&gt;</span>
<span class="line">    }</span>
<span class="line">  }</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>In the code above, we loop over all atoms in the topology, then look in the abstract for the bounds of that atoms 1-2 excluded atom list. These lists are reflexive, with the 1-2 excluded interaction between <em>a</em> and <em>b</em> also noted for <em>b</em> and <em>a</em>. Double-counting could be prevented by merely insisting that exclusions only be evaluated if <em>b</em> &gt; <em>a</em> (or vice-versa), but this is not the only way in which multiple exclusions can affect the same atoms. In particular, a five-membered ring A-B-C-D-E will have a 1:3 exclusion between A and C (A-B-C) but also a 1:4 exclusion A-E-D-C. There are some conventions in the construction of the non-bonded kit that mitigate such double-counting, but to be safe we track everything in the tutorial program. The contents of the utility function <code>exclusionKnown</code> in the code above is:</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">bool exclusionKnown(std::vector&lt;std::vector&lt;int&gt;&gt; *excl_counted, const int iatom,</span>
<span class="line">                    const int jatom) {</span>
<span class="line">  const size_t ni = excl_counted-&gt;at(iatom).size();</span>
<span class="line">  if (ni &gt; 0 &amp;&amp; locateValue(excl_counted-&gt;at(iatom), jatom, DataOrder::ASCENDING) &lt; ni) {</span>
<span class="line">    return true;</span>
<span class="line">  }</span>
<span class="line">  else {</span>
<span class="line">    excl_counted-&gt;at(iatom).push_back(jatom);</span>
<span class="line">    if (ni &gt; 0) {</span>
<span class="line">      std::sort(excl_counted-&gt;at(iatom).begin(), excl_counted-&gt;at(iatom).end(),</span>
<span class="line">                [](const int a, const int b) { return a &lt; b; });</span>
<span class="line">    }</span>
<span class="line">    excl_counted-&gt;at(jatom).push_back(iatom);</span>
<span class="line">    if (excl_counted-&gt;at(jatom).size() &gt; 1) {</span>
<span class="line">      std::sort(excl_counted-&gt;at(jatom).begin(), excl_counted-&gt;at(jatom).end(),</span>
<span class="line">                [](const int a, const int b) { return a &lt; b; });</span>
<span class="line">    }</span>
<span class="line">    return false;</span>
<span class="line">  }</span>
<span class="line">  __builtin_unreachable();</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>If we run the calculations and track the time needed to perform the electrostatic calculation either with complete omission of excluded interactions, the time tracking from the pre-built tutorial program helps to show the performance of the exclusion calculation.</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">&gt;&gt; /stormm/build/apps/Tutorial/tutorial_iv.stormm.cuda \</span>
<span class="line">     -topol /stormm/home/test/Topology/dhfr_cmap.top \</span>
<span class="line">     -coord /stormm/home/test/Trajectory/dhfr_cmap.inpcrd \</span>
<span class="line">     energy_loop 100</span>
<span class="line"></span>
<span class="line">&lt;... additional output ...&gt;</span>
<span class="line"> +--------------------------------+--------------------------------------------------------+</span>
<span class="line"> |         Category Name          | Samples   Total    Mean    Standard   Minimum  Maximum |</span>
<span class="line"> |                                |          Time, s  Time, s  Deviation  Time, s  Time, s |</span>
<span class="line"> +--------------------------------+--------------------------------------------------------+</span>
<span class="line"> | Basic Non-bonded Evaluation    |     100   0.7889   0.0079     0.0031   0.0068   0.0229 |</span>
<span class="line"> | Non-bonded Evaluation Cleanup  |     100   0.0338   0.0003     0.0002   0.0003   0.0010 |</span>
<span class="line"> | Excluded Non-bonded Evaluation |     100   1.1838   0.0118     0.0043   0.0102   0.0314 |</span>
<span class="line"> +--------------------------------+--------------------------------------------------------+</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>While it is faster in this case to evaluate all interactions and then trim away the exclusions, even with our rudimentary system for tracking them, this is just the electrostatic energy evaluation. To evaluate forces would be much more laborious, and to add a van-der Waals potential on top of that brings the relative cost of the exclusion calculation down by a great deal, and in our developmental GPU code for periodic boundaries we are finding that the cost of evaluating the exclusion status of each pair is on the order of 5% of the total cost of the nested loop over all neighbor list pairs. While the tutorial program will yield very similar answers for the total electrostatic energy with either method, the divergence of electrostatic energy as particles come within 0.1 nm of one another is not as severe as the divergence of the van-der Waals (Lennard-Jones) potential, and the tutorial is working in <code>double</code> precision. In <code>float</code> arithmetic, the van-der Waals potential would often break the precision format and destroy information in the lower bits as very high values were added to the total and then subtracted away. Tracking and preventing the incorporation of excluded non-bonded interactions is a good practice in molecular simulations.</p><h1 id="creating-a-synthesis-of-all-systems" tabindex="-1"><a class="header-anchor" href="#creating-a-synthesis-of-all-systems"><span>Creating a Synthesis of All Systems</span></a></h1><p>With the systems read in and correspondence established, the masterstroke is create a <em>synthesis</em> of the coordinates and topologies. The coordinate synthesis is the <a class="route-link" href="/doxygen/classstormm_1_1synthesis_1_1PhaseSpaceSynthesis.html"><code>PhaseSpaceSynthesis</code></a>, while the topology synthesis is the <a class="route-link" href="/doxygen/classstormm_1_1synthesis_1_1AtomGraphSynthesis.html"><code>AtomGraphSynthesis</code></a>. The constructor for the <code>PhaseSpaceSynthesis</code> calls for an array of <code>PhaseSpace</code> objects and an array of <em>pointers</em> to their respective topologies. Note: the tutorial program will abort with an error if systems with mismatched boundary conditions are supplied in the same run. All systems must either have no boundary conditions, or they must all have periodic boundary conditions. Barring that mismatch, it&#39;s easy enough to create the synthesis:</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">  std::vector&lt;AtomGraph*&gt; agv_ptr;</span>
<span class="line">  for (int i = 0; i &lt; ntop; i++) {</span>
<span class="line">    agv_ptr.push_back(&amp;agv[i]);</span>
<span class="line">  }</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Various overloads allow a developer to create objects with additional indexing arrays, so that a list of topologies <code>{ tA, tB, tC }</code> could create a synthesis with contents <code>{ tA, tA, tA, tB, tB, tC, tA, tC, tA }</code>. When created, the synthesis allocates new memory for all of its data, although it retains pointers to the original objects which should therefore not be destroyed. Replicating a system many times is a wy to conserve the amount of memory that must be allocated for the underlying coordinate and topology objects. We will create a synthesis with two copies of each each system supplied to the tutorial program:</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">#include &quot;/stormm/home/src/Synthesis/atomgraph_synthesis.h&quot;</span>
<span class="line">#include &quot;/stormm/home/src/Synthesis/phasespace_synthesis.h&quot;</span>
<span class="line"></span>
<span class="line">using stormm::synthesis::AtomGraphSynthesis;</span>
<span class="line">using stormm::synthesis::PhaseSpaceSynthesis;</span>
<span class="line"></span>
<span class="line">  std::vector&lt;int&gt; synth_list;</span>
<span class="line">  for (int i = 0; i &lt; ntop; i++) {</span>
<span class="line">    for (int j = 0; j &lt; 2; j++) {</span>
<span class="line">      synth_list.push_back(i);</span>
<span class="line">    }</span>
<span class="line">  }</span>
<span class="line">  PhaseSpaceSynthesis poly_ps(psv, agv_ptr, synth_list);</span>
<span class="line">  AtomGraphSynthesis poly_ag(agv_ptr, synth_list);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Inspecting the abstract of the <code>PhaseSpaceSynthesis</code> reveals something very important about this class: the coordinates (positions, velocities, and forces) are all stored in fixed precision, <code>long long int</code> (which STORMM will <code>typedef</code> as <code>llint</code>) with an extra <code>int</code> for each coordinate. See the implementation in <strong>/stormm/home/src/Synthesis/phasespace_synthesis.h</strong>. There are also bit counts for each property: <code>gpos_bits</code> for global particle positions, <code>vel_bits</code> for particle velocities, and <code>frc_bits</code> for force accumulators. We left these at their default settings when constructing the object. If we want to extract raw information from the <code>PhaseSpaceSynthesis</code> through the abstract system, the conversion back to floating point numbers is essential.</p><h2 id="computing-electrostatics-with-the-synthesis" tabindex="-1"><a class="header-anchor" href="#computing-electrostatics-with-the-synthesis"><span>Computing Electrostatics with the Synthesis</span></a></h2><p>In order to repeat the electrostatic calculations using the synthesis, rather than the &quot;ordinary&quot; coordinate and topology objects, we will need to understand where each system resides in the synthesis. We will restrict the exposition to the read-only <code>PsSynthesisReader</code> abstract, as it is not necessary to modify forces in the object when summing the total energy. The limits of each system are given in two arrays, <code>atom_starts</code> and <code>atom_counts</code>:</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">#include &quot;/stormm/home/src/Numerics/split_fixed_precision.h&quot;</span>
<span class="line">#include &quot;/stormm/home/src/Synthesis/synthesis_abstracts.h&quot;</span>
<span class="line"></span>
<span class="line">using stormm::synthesis::PsSynthesisReader;</span>
<span class="line">using stormm::synthesis::SyNonbondedKit;</span>
<span class="line">using stormm::numerics::hostInt95Subtract;</span>
<span class="line"></span>
<span class="line">  const LocalExclusionMask poly_lem(poly_ag);</span>
<span class="line">  const LocalExclusionMaskReader poly_lemr = poly_lem.data();</span>
<span class="line">  const SyNonbondedKit&lt;double, double2&gt; poly_nbk = poly_ag.getDoublePrecisionNonbondedKit();</span>
<span class="line">  const PsSynthesisReader poly_psr = pol_psy.data();</span>
<span class="line">  for (int sys_idx = 1; sys_idx &lt; poly_psr.system_count; sys_idx += 2) {</span>
<span class="line">    const int llim = poly_psr.atom_starts[sys_idx];</span>
<span class="line">    const int hlim = llim + poly_psr.atom_counts[sys_idx];</span>
<span class="line">    const double* umat_ptr = &amp;poly_psr.umat[32 * sys_idx];</span>
<span class="line">    const double* invu_ptr = &amp;poly_psr.invu[32 * sys_idx];</span>
<span class="line">    const bool is_periodic = (poly_psr.unit_cell != UnitCellType::NONE);</span>
<span class="line">    for (int i = llim + 1; i &lt; hlim; i++) {</span>
<span class="line">      for (int j = llim; j &lt; i; j++) {</span>
<span class="line">        if (! testExclusion(poly_lemr, i, j)) {</span>
<span class="line">          const int95_t idx = hostInt95Subtract(poly_psr.xcrd[j], poly_psr.xcrd_ovrf[j],</span>
<span class="line">                                                poly_psr.xcrd[i], poly_psr.xcrd_ovrf[i]);</span>
<span class="line">          const int95_t idy = hostInt95Subtract(poly_psr.ycrd[j], poly_psr.ycrd_ovrf[j],</span>
<span class="line">                                                poly_psr.ycrd[i], poly_psr.ycrd_ovrf[i]);</span>
<span class="line">          const int95_t idz = hostInt95Subtract(poly_psr.zcrd[j], poly_psr.zcrd_ovrf[j],</span>
<span class="line">                                                poly_psr.zcrd[i], poly_psr.zcrd_ovrf[i]);</span>
<span class="line">          double dx = hostInt95ToDouble(idx) * poly_psr.inv_gpos_scale;</span>
<span class="line">          double dy = hostInt95ToDouble(idy) * poly_psr.inv_gpos_scale;</span>
<span class="line">          double dz = hostInt95ToDouble(idz) * poly_psr.inv_gpos_scale;</span>
<span class="line">          if (is_periodic) {</span>
<span class="line">            imageCoordinates&lt;double, double&gt;(&amp;dx, &amp;dy, &amp;dz, umat_ptr, invu_ptr, poly_psr.unit_cell,</span>
<span class="line">                                             ImagingMethod::MINIMUM_IMAGE);</span>
<span class="line">          }</span>
<span class="line">          const double qij = poly_nbk.charge[i] * poly_nbk.charge[j];</span>
<span class="line">          const double dr = sqrt((dx * dx) + (dy * dy) + (dz * dz));</span>
<span class="line">          masked_elec_nrg += qij / dr;</span>
<span class="line">        }</span>
<span class="line">      }</span>
<span class="line">    }</span>
<span class="line">  }</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Note that in the above code, we made a new <code>LocalExclusionMask</code> for the topology synthesis. The class constructor is overloaded to accept either input, and the ordering of atoms in the synthesis of topologies, one system after another, is analogous to the ordering of atoms in a single topology. We also calculated electrostatics for every other system, as each of the original topologies and coordinate sets was duplicated in the synthesis. As a final note, we have taken the displacements between coordinates in fixed precision using special functions for handling the data stored by the <code>PhaseSpaceSynthesis</code>. A deep discussion of the &quot;split&quot; fixed precision representation is beyond the scope of this tutorial, but see the <a href="https://pubs.aip.org/aip/jcp/article/161/3/032501/3303330/STORMM-Structure-and-topology-replica-molecular" target="_blank" rel="noopener noreferrer">introductory paper</a> for more information. If the bit counts after the point are low enough (which, in fact, they are in this case with the default values), we can disregard the data in the &quot;overflow&quot; <code>int</code> values for each coordinate and do the subtraction between the <code>llint</code> components only. However, we want developers to understand that STORMM&#39;s <code>numerics</code> namespace has a wide selection of functions to handle the unique format, and even to perform periodic imaging in unit cells defined by cell lengths in fixed precision.</p><h2 id="conclusion" tabindex="-1"><a class="header-anchor" href="#conclusion"><span>Conclusion</span></a></h2><p>We have run through many of the basics, in CPU code, for reading systems into STORMM and unpacking those topology and coordinate objects to perform calculations. The <code>AtomGraph</code> topology emits more than just the non-bonded abstract, and for most abstracts of the <code>AtomGraph</code> there is a cognate in the <code>AtomGraphSynthesis</code>.</p><p>Memory management and avoiding program bloat is an issue of active development in STORMM, in particular because a synthesis of many unique systems would require not just memory for the coordinate and topology syntheses but also memory for the singleton objects of each system. For coordinates, we have created the option to specify the <code>Hybrid</code> memory format, e.g. <code>HybridFormat::HOST_ONLY</code> for the objects that serve only to stage files read from disk, which will help to conserve GPU memory. However, the majority of the memory for any particular system is to be found in the topology, which is not yet format-adaptable. The <code>LocalExclusionMask</code> and the ability to calculate the exclusion status of a given pair on-the-fly goes a long way to conserving memory, and we anticipate that STORMM will be an industry leader in terms of the sheer size of systems that it can simulate.</p><p>For most applications, however, modern GPUs have more than enough memory to handle molecular systems and a number of supporting matrices or dynamic arrays supporting the problem at hand. We hope that this tutorial has demonstrated the ease with which developers can construct molecular systems and delve into their contents.</p></div><!--[--><!--]--></div><footer class="vp-page-meta"><!----><div class="vp-meta-item git-info"><div class="vp-meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><!----></div></footer><!----><!--[--><!--]--></main><!--]--></div><!--[--><!----><!--]--><!--]--></div>
    <script type="module" src="/assets/app-CrNxYCqk.js" defer></script>
  </body>
</html>
