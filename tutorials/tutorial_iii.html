<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.15" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme='dark'] {
        --vp-c-bg: #22272e;
      }

      html,
      body {
        background-color: var(--vp-c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme')
      const systemDarkMode =
        'matchMedia' in window
          ? window.matchMedia('(prefers-color-scheme: dark)').matches
          : false

      if (userMode === 'light') {
        document.documentElement.dataset.theme = 'light'
      } else if (userMode === 'dark' || systemDarkMode) {
        document.documentElement.dataset.theme = 'dark'
      }
    </script>
    <title>Creating Your Own Input Blocks | STORMM</title><meta name="description" content="Structure and TOpology Replica Molecular Mechanics">
    <link rel="preload" href="/assets/style-YX4WIeeL.css" as="style"><link rel="stylesheet" href="/assets/style-YX4WIeeL.css">
    <link rel="modulepreload" href="/assets/app-klz2yyuf.js"><link rel="modulepreload" href="/assets/tutorial_iii.html-BWCfgzWa.js">
    <link rel="prefetch" href="/assets/index.html-DURi2H5N.js" as="script"><link rel="prefetch" href="/assets/contents.html-dUaiPZog.js" as="script"><link rel="prefetch" href="/assets/dev-philosophy.html-CuWuPKNb.js" as="script"><link rel="prefetch" href="/assets/dev-tutorials.html-DRUviWU9.js" as="script"><link rel="prefetch" href="/assets/get-started.html-BgSy-uOr.js" as="script"><link rel="prefetch" href="/assets/stormm-md.html-DKgglhf1.js" as="script"><link rel="prefetch" href="/assets/why-stormm.html-CU-RwDJX.js" as="script"><link rel="prefetch" href="/assets/docker.html-DJIWJw-p.js" as="script"><link rel="prefetch" href="/assets/tutorial_i.html-DPWGrism.js" as="script"><link rel="prefetch" href="/assets/tutorial_ii.html-C2Gsl33e.js" as="script"><link rel="prefetch" href="/assets/tutorial_iv.html-DgypSEQB.js" as="script"><link rel="prefetch" href="/assets/404.html-DJ3_XRGM.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="vp-theme-container external-link-icon" vp-container><!--[--><header class="vp-navbar" vp-navbar><div class="vp-toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a class="route-link" href="/"><!----><span class="vp-site-name" aria-hidden="true">STORMM</span></a></span><div class="vp-navbar-items-wrapper" style=""><!--[--><!--]--><nav class="vp-navbar-items vp-hide-mobile" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/" aria-label="Home"><!---->Home<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/get-started.html" aria-label="Getting Started with STORMM"><!---->Getting Started with STORMM<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/contents.html" aria-label="Table of Contents"><!---->Table of Contents<!----></a></div><!--]--></nav><!--[--><!--]--><button type="button" class="vp-toggle-color-mode-button" title="toggle color mode"><svg class="light-icon" viewbox="0 0 32 32" style=""><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg class="dark-icon" viewbox="0 0 32 32" style="display:none;"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="vp-sidebar-mask"></div><!--[--><aside class="vp-sidebar" vp-sidebar><nav class="vp-navbar-items" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/" aria-label="Home"><!---->Home<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/get-started.html" aria-label="Getting Started with STORMM"><!---->Getting Started with STORMM<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/contents.html" aria-label="Table of Contents"><!---->Table of Contents<!----></a></div><!--]--></nav><!--[--><!--]--><ul class="vp-sidebar-items"><!--[--><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">Creating Your Own Input Blocks <!----></p><!----></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="vp-page"><!--[--><!--]--><div class="theme-default-content" vp-content><!--[--><!--]--><div><h1 id="creating-your-own-input-blocks" tabindex="-1"><a class="header-anchor" href="#creating-your-own-input-blocks"><span>Creating Your Own Input Blocks</span></a></h1><p>With few exceptions, creating custom programs, or modifying existing programs, requires the developer to create input options for the user to control new features. STORMM uses a native C++ emulator for Fortran-like namelists, allowing it to read input files that look much like those of the AMBER molecular dynamics engines <strong>sander</strong> and <strong>pmemd</strong>. The namelist syntax in STORMM is enhanced, allowing users to forego <code>=</code> signs and commas: <code>keyword_a = value_a, keyword_b = value_b</code> is interpreted in the same way as <code>keyword_a value_a keyword_b value_b</code>, although a comma would help for legibility. STORMM also lets the developer specify keywords to take <code>STRUCT</code> inputs, signified by brace characters before and after a list of sub-key entries, e.g. <code>composite_a = { -part_i value_i, -part_ii value_ii, -part_iv value_iv }</code> with sub-keys being optional or required at the developer&#39;s discretion. Furthermore, STORMM lets the developer stipulate whether a keyword will accept multiple entries. In this tutorial, we will explore how to make a custom input block and give the user a pathway to feeding information into programs written with STORMM.</p><h2 id="the-method" tabindex="-1"><a class="header-anchor" href="#the-method"><span>The Method</span></a></h2><p>There are three major steps to passing user input into STORMM, each requiring C++ code of moderate density.</p><ul><li>Establish a new <a class="route-link" href="/doxygen/classstormm_1_1namelist_1_1NamelistEmulator.html"><code>NamelistEmulator</code></a> class object.</li><li>Run a file stream by that <code>NamelistEmulator</code> object to load it up user input directives</li><li>Write an original class to offload information from the <code>NamelistEmulator</code> and digest it for the rest of the program The third step is not essential, but in general it is a good idea to streamline the extraction of information from a general-purpose format (where each access requires interpreting, checking, and comparing a character string) to an application-specific dispenser. STORMM also comes with a number of modular namelists, e.g. <code>&amp;dynamics</code> and <code>&amp;precision</code>, which can be included in programs from the main libraries. Each of these native input blocks comes with its own unique class to filter the user&#39;s input by the strategy above, e.g. <a class="route-link" href="/doxygen/classstormm_1_1namelist_1_1DynamicsControls.html"><code>DynamicsControls</code></a> or <a class="route-link" href="/doxygen/classstormm_1_1namelist_1_1PrecisionControls.html"><code>PrecisionControls</code></a></li></ul><p>The preferred route is to make a function to configure the <code>NamelistEmulator</code> with input elements, then have that function take the user input file or a <a class="route-link" href="/doxygen/classstormm_1_1parse_1_1TextFile.html"><code>TextFile</code></a> class object that has already loaded the input text into memory. The bulk of this function will involve configuring the <code>NamelistEmulator</code> with keywords, defaults and help messages. Before returning the <code>NamelistEmulator</code> object, the function will load it up using the <a class="route-link" href="/doxygen/input_8h_source.html"><code>readNamelist</code></a> function. Again, this will search for keywords in an ascii text file to convert the user input into a general-purpose dispenser which can then dispense the information by issuing queries based on those keywords. The function that manages configuration and loading of the <code>NamelistEmulator</code> object for a given control block will be called by the constructor for the application-specific class that dispense information to the rest of the program. An abbreviated header for the protocol is written below:</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">#include &quot;/stormm/home/src/Namelists/namelist_emulator.h&quot;</span>
<span class="line">#include &quot;/stormm/home/src/Parsing/textfile.h&quot;</span>
<span class="line"></span>
<span class="line">using stormm::namelist::NamelistEmulator;</span>
<span class="line"></span>
<span class="line">NamelistEmulator starInput(const TextFile &amp;input_ascii_text);</span>
<span class="line"></span>
<span class="line">class StarControls() {</span>
<span class="line">public:</span>
<span class="line">  StarControls(const TextFile &amp;input_ascii_text);</span>
<span class="line"></span>
<span class="line">  int getPlanetCount() const;</span>
<span class="line">  double getMass() const;</span>
<span class="line">  double getBrightness() const;</span>
<span class="line">  </span>
<span class="line">private:</span>
<span class="line">  int planet_count;   // Number of planets in orbit</span>
<span class="line">  double mass;        // Mass in units of solar masses</span>
<span class="line">  double brightness;  // Brightness expressed in apparent magnitude</span>
<span class="line">};</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="configuring-the-keywords" tabindex="-1"><a class="header-anchor" href="#configuring-the-keywords"><span>Configuring the Keywords</span></a></h2><p>In the example above, which will be expanded in the Tutorial III program, the namelist <code>&amp;star</code> is configured into a <code>NamelistEmulator</code> by the <code>starInput</code> function. The contents of that function, which again accomplishes the first and second stages of the overall process, could be as follows (a slightly longer version is found in the tutorial &quot;answer&quot; program, <strong>/stormm/home/apps/Tutorial/tutorial_iii.cpp</strong>).</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">#include &quot;/stormm/home/src/Constants/behavior.h&quot;</span>
<span class="line">#include &quot;/stormm/home/src/Namelists/input.h&quot;</span>
<span class="line">#include &quot;/stormm/home/src/Namelists/namelist_enumerators.h&quot;</span>
<span class="line">#include &quot;/stormm/home/src/Parse/parsing_enumerators.h&quot;</span>
<span class="line"></span>
<span class="line">using stormm::constants::ExceptionResponse;</span>
<span class="line">using stormm::constants::CaseSensitivity;</span>
<span class="line">using stormm::namelist::NamelistType;</span>
<span class="line">using stormm::parse::WrapTextSearch;</span>
<span class="line"></span>
<span class="line">NamelistEmulator starInput(const TextFile &amp;input_ascii_text) {</span>
<span class="line">  NamelistEmulator result(&quot;star&quot;, CaseSensitivity::YES, ExceptionResponse::DIE, &quot;Parameters for &quot;</span>
<span class="line">                          &quot;a star in the sky&quot;);</span>
<span class="line">  result.addKeyword(&quot;planets&quot;, NamelistType::INTEGER, std::to_string(8));</span>
<span class="line">  result.addKeyword(&quot;mass&quot;, NamelistType::REAL, std::to_string(1.0));</span>
<span class="line">  result.addKeyword(&quot;brightness&quot;, NamelistType::REAL, std::to_string(-26.74));</span>
<span class="line">  int start_line = 0;</span>
<span class="line">  readNamelist(input_ascii_text, &amp;result, &amp;start_line, WrapTextSearch::YES, tf.getLineCount());</span>
<span class="line">  return result;</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="optimizing-access-with-an-application-specific-class" tabindex="-1"><a class="header-anchor" href="#optimizing-access-with-an-application-specific-class"><span>Optimizing Access with an Application-Specific Class</span></a></h2><p>The <code>starInput</code> function carried out the laborious task of sifting through the entire input file, or a portion of its lines if we had some intelligent way to put limits on the range. This converted the potentially large block of character input into a developer-defined collection of keyword-value pairs. It is incorporated into the <code>StarControls</code> class constructor to carry out, once, the relatively strenuous task of sifting through the keyword-value pairs to find the appropriate values needed by the program based on their keywords. Its abridged contents might be:</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">StarControls::StarControls(const TextFile &amp;input_ascii_text) :</span>
<span class="line">    planet_count{0}, mass{1.0}, brightness{1.0}</span>
<span class="line">{</span>
<span class="line">  NamelistEmulator t_nml = starInput(input_ascii_text);</span>
<span class="line">  t_nml.assignVariable(&amp;planet_count, &quot;planets&quot;);</span>
<span class="line">  t_nml.assignVariable(&amp;mass, &quot;mass&quot;);</span>
<span class="line">  t_nml.assignVariable(&amp;brightness, &quot;brightness&quot;);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Once the <code>StarControls</code> class object is constructed, getting the number of planets around a star no longer requires a series of string comparisons against every keyword in the <code>&amp;star</code> namelist, it can be retrieved by a single call to the <code>StarControls::getPlanetCount()</code> accessor function (the contents of which were not written out above, but should be obvious). The <code>NamelistEmulator</code> methods such as <code>assignVariable</code> and <code>addKeyword</code> come with many overloads to give developers freedom in organizing the keywords and their associated descriptions. In a real application, there might be more than a dozen keywords in the new input block. Configuring the <code>NamelistEmulator</code> and unpacking it in this way will comprise the bulk of the code to write, and is intended to be as script-like as possible.</p><h2 id="the-command-line-is-a-namelist-too" tabindex="-1"><a class="header-anchor" href="#the-command-line-is-a-namelist-too"><span>The Command Line is a Namelist, Too!</span></a></h2><p>The first place STORMM programs take in user information isn&#39;t the input file, though: it&#39;s the command line. Command line arguments need documentation as well, and to address this need, STORMM bundles all of the character strings passed in from the command line and bundles them as if they were the contents of a namelist. This is done using the <a class="route-link" href="/doxygen/classstormm_1_1namelist_1_1CommandLineParser.html"><code>CommandLineParser</code></a> class, which includes among its members a <code>NamelistEmulator</code> and a collection of common keywords (with descriptions) that a developer can add as command line arguments by including them in the constructor call. The developer may add original command line arguments by reaching into the parser to edit the namelist stored inside, and even have the parser coordinate with other classes which look to the command line for information so as not to have keyword collisions or raise exceptions when one parser doesn&#39;t recognize a keyword to be used by another.</p><h2 id="displaying-keyword-documentation" tabindex="-1"><a class="header-anchor" href="#displaying-keyword-documentation"><span>Displaying Keyword Documentation</span></a></h2><p>In addition to the means for developing new namelists, STORMM has a way to give each program a user manual with an interactive display through the command line. With this system, running the program with no arguments or with <code>--help</code> and variations thereof will produce a summary of the program&#39;s declared purpose and a list of namelist conntrol block titles, with their own provided descriptions, in the terminal window. Running the program with the title of one of the applicable namelists as the command line argument will produce a table of keywords in the namelist, complete with data types, default values, and descriptions. All of this is done by accessing the configured <code>NamelistEmulator</code>, and works with many of the same methods used to display namelist contents and input choices when printing a report file at the end of a run.</p><p>In order to add help messages for each keyword, we must go to the function wherein the namelist is being configured. The help messages can , in fact, be included with each keyword&#39;s configuration, although the <code>addKeyword</code> method has many overloads and it can be unwieldy to include so much documentation in the space of a single function call. STORMM also provides the <code>addHelp</code> method within the <code>NamelistEmulator</code> class to set the user documentation (more precisely, <code>addHelp</code> will modify the message after the constructor assigns a blank message). The documentation for each keyword, building on the above code to configure <code>NamelistEmulator result</code>, could be:</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">  result.addHelp(&quot;planets&quot;, &quot;The number of planets known to orbit the star&quot;);</span>
<span class="line">  result.addHelp(&quot;mass&quot;, &quot;Estimated mass of the star, in units of solar masses&quot;);</span>
<span class="line">  result.addHelp(&quot;brightness&quot;, &quot;Apparent magnitude of the star, as observed from Earth&quot;);</span>
<span class="line">  result.addHelp(&quot;name&quot;, &quot;Common name given to the star&quot;);</span>
<span class="line">  result.addHelp(&quot;constellation&quot;, &quot;Name of the constellation in which the star appears, or the &quot;</span>
<span class="line">                 &quot;constellation giving a direction in which to find the star&quot;);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="telling-the-user-what-to-do" tabindex="-1"><a class="header-anchor" href="#telling-the-user-what-to-do"><span>Telling the User What To Do</span></a></h2><p>Once the keyword descriptions are configured in the namelist, the developer needs to ensure that they can be conveyed to the user. In STORMM programs, the convention is that running the program with no arguments (or, <code>--help</code>) will print a list of all relevant namelist control blocks, with general descriptions (for <code>&amp;star</code>, the description was &quot;Parameters for a star in the sky&quot;). Re-running the program with the title of a namelist as the command line argument will, in turn, print documentation on the keywords within. But, how do we tell the system about our new namelist, <code>&amp;star</code>?</p><p>It&#39;s worthwhile to point out here that STORMM has a number of general-purpose control blocks for developers to mix and match the input. To reiterate, a <code>NamelistEmulator</code> class object is not much, until it&#39;s configured. That&#39;s why the convention is to encapsulate the configuration for each namelist control block into a specific function, e.g. <code>starInput</code> shown above, so that the documentation system can call on that function to produce a new <code>NamelistEmulator</code> object configured for the control block of interest. We can then use a simple class to connect each configuring function with a namelist title string, and that is the <code>NamelistToken</code> class in <strong>/stormm/home/src/Namelists/namelist_inventory.h</strong>. The class stores a function pointer and contains a method to execute that function on demand. The documentation system can then read through its lists, match the user&#39;s request to the title of a namelist that it knows, and configure a new <code>NamelistEmulator</code> object with all of the relevant keywords. It can then dive in and grab the documentation with the <code>NamelistEmulator</code> method <code>printHelp</code>.</p><p>All we need to do is make the documentation system aware of our new control block. To do that, we can make a vector of tokens for the custom namelists, which in this case is just <code>&amp;star</code>:</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">#include &quot;/stormm/home/src/Namelists/namelist_inventory.h&quot;</span>
<span class="line"></span>
<span class="line">using stormm::namelist::NamelistToken;</span>
<span class="line"></span>
<span class="line">  const std:vector&lt;NamelistToken&gt; tutorial_specific_namelists = {</span>
<span class="line">    NamelistToken(std::string(&quot;&amp;star&quot;), starInput);</span>
<span class="line">  };</span>
<span class="line">  clip.addCustomNamelists(tutorial_specific_namelists);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Above, we made a minimal example of the configuration function. In order to get it into the reporting system, the function primitive needs to conform to that of other configuration functions in STORMM. We can therefore add a couple of input parameters to make the form of <code>starInput</code> match that of functions like <code>dynamicsInput</code> in <strong>/stormm/home/src/Namelists/nml_dynamics.h</strong>.</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">NamelistEmulator starInput(const TextFile &amp;input_ascii_text, int *start_line, bool *found_nml,</span>
<span class="line">                           ExceptionResponse policy = ExceptionResponse::DIE,</span>
<span class="line">                           WrapTextSearch wrap = WrapTextSearch::NO);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Note that the three of the inputs we added can be passed on to the <code>readInput</code> function rather than being created as local variables in <code>starInput</code> and hidden from the rest of the program. Through the <code>NamelistToken</code> array, the new namelist&#39;s token is added to the <code>CommandLineParser</code>. One task remains, which is to add the name / title of the control block to the parser&#39;s list of known namelists so that it does not confuse the title of an actual namelist for some other argument that it is supposed to interpret from the command line. In fact, requests for namelist documentation will be intercepted before the call to <code>CommandLineParser::parseUserInput(argc, argv)</code>. We use code from STORMM&#39;s <code>display</code> library to produce the documentation in the terminal for a user. The entire code for configuring the command line parsing is given below:</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">#include &quot;/stormm/home/src/Reporting/help_messages.h&quot;</span>
<span class="line"></span>
<span class="line">using stormm::display::displayNamelistHelp;</span>
<span class="line"></span>
<span class="line">  CommandLineParser clip(&quot;Tutorial_III&quot;, &quot;An exercise in creating custom user control blocks with &quot;</span>
<span class="line">                         &quot;the native STORMM documentation system&quot;);</span>
<span class="line">  clip.addStandardApplicationInputs(&quot;-i&quot;);</span>
<span class="line">  NamelistEmulator *cmd_nml = clip.getNamelistPointer();</span>
<span class="line">  cmd_nml-&gt;addKeyword(&quot;-rating&quot;, NamelistType::INTEGER, std::string(&quot;&quot;));</span>
<span class="line">  cmd_nml-&gt;addHelp(&quot;-rating&quot;, &quot;Rate this tutorial on a scale of 1-10.&quot;);</span>
<span class="line">  const std::vector&lt;NamelistToken&gt; tutorial_specific_namelists = {</span>
<span class="line">    NamelistToken(std::string(&quot;&amp;star&quot;), starInput)</span>
<span class="line">  };</span>
<span class="line">  const std::vector&lt;std::string&gt; my_namelist_names = { &quot;star&quot; };</span>
<span class="line">  clip.addControlBlocks(my_namelist_names);</span>
<span class="line">  clip.addCustomNamelists(tutorial_specific_namelists);</span>
<span class="line">  if (displayNamelistHelp(argc, argv, my_namelist_names, tutorial_specific_namelists) &amp;&amp;</span>
<span class="line">      clip.doesProgramExitOnHelp()) {</span>
<span class="line">    return 0;</span>
<span class="line">  }</span>
<span class="line">  clip.parseUserInput(argc, argv);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>All documentation will be printed to the terminal in the <code>displayNamelistHelp</code> function. The <code>CommandLineParser</code> can be set to have the program continue after rendering the messages, but the default behavior is to exit and await the user&#39;s next attempt.</p><h2 id="results" tabindex="-1"><a class="header-anchor" href="#results"><span>Results</span></a></h2><p>When the tutorial&#39;s &quot;answer&quot; program found in <strong>/stormm/home/apps/Tutorial/tutorial_iii.cpp</strong> is run with no command line arguments, or with <code>--help</code>, we get the following:</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">&gt;&gt; /stormm/build/apps/Tutorial/tutorial_iii.stormm.cuda</span>
<span class="line"></span>
<span class="line">+-----------------------------------------------------------------------------+</span>
<span class="line">Tutorial_III: An exercise in creating custom user control blocks with the</span>
<span class="line">              native STORMM documentation system</span>
<span class="line"></span>
<span class="line"> Command line inputs [ type, default value ]:</span>
<span class="line">+-----------------------------------------------------------------------------+</span>
<span class="line"> + --help  : [BOOLEAN, FALSE] List command line arguments with descriptions.</span>
<span class="line"></span>
<span class="line"> + -help   : [BOOLEAN, FALSE] List command line arguments with descriptions.</span>
<span class="line"></span>
<span class="line"> + -i      : [ STRING, &#39;stormm.in&#39;] The primary input file, equivalent to</span>
<span class="line">             Amber&#39;s mdin.</span>
<span class="line"></span>
<span class="line"> + -rating : [INTEGER,  None] Rate this tutorial on a scale of 1-10.</span>
<span class="line"></span>
<span class="line">  Applicable namelist control blocks (re-run with one of these titles as the</span>
<span class="line">  command-line argument, in quotes if the leading &#39;&amp;&#39; is included, for a full</span>
<span class="line">  description of all keywords in the namelist):</span>
<span class="line">  |</span>
<span class="line">  | Namelist            Description</span>
<span class="line">  | --------  --------------------------------</span>
<span class="line">  | &amp;star     Parameters for a star in the sky</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The command line arguments are listed, followed by a brief description of the control block that we can put in the input file. If we run the program and request more information on the control block <code>&amp;star</code>, we get:</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">&gt;&gt; /stormm/build/apps/Tutorial/tutorial_iii.stormm.cuda star</span>
<span class="line"></span>
<span class="line">+-----------------------------------------------------------------------------+</span>
<span class="line">&amp;star: Parameters for a star in the sky</span>
<span class="line"></span>
<span class="line"> Keywords [ type, default value ]:</span>
<span class="line">+-----------------------------------------------------------------------------+</span>
<span class="line"> + planets       : [INTEGER,      8] The number of planets known to orbit the</span>
<span class="line">                   star</span>
<span class="line"></span>
<span class="line"> + mass          : [   REAL,    1.0] Estimated mass of the star, in units of</span>
<span class="line">                   solar masses</span>
<span class="line"></span>
<span class="line"> + brightness    : [   REAL, -26.74] Apparent magnitude of the star, as</span>
<span class="line">                   observed from Earth</span>
<span class="line"></span>
<span class="line"> + name          : [ STRING,   None] Common name given to the star</span>
<span class="line"></span>
<span class="line"> + constellation : [ STRING,   None] Name of the constellation in which the</span>
<span class="line">                   star appears, or the constellation giving a direction in</span>
<span class="line">                   which to find the star</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The types and default values of each keyword are displayed for the user, while the developer is only required to write the documentation in one place. If we now run the program with an input file such as <a href="../assets/t3.in" download>this example</a>, the user input will be parsed and rendered in a convenient format for the rest of the C++ program. Note that the tutorial program makes use of the <code>start_line</code> variable and the return value of <code>readInput</code> to step through the input file and record multiple <code>&amp;star</code> namelist control blocks. This is the more complete behavior available when using the standard form of a STORMM namelist configuration function. The result is:</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">&gt;&gt; /stormm/build/apps/Tutorial/tutorial_iii.stormm.cuda -i t3.in</span>
<span class="line"></span>
<span class="line">There are 3 stellar entries in t3.in.</span>
<span class="line"></span>
<span class="line">    Star Name      Mass  Brightness Planets   Constellation</span>
<span class="line">----------------- ------ ---------- ------- -----------------</span>
<span class="line"> Alpha Centauri A   1.07     0.0100       0         Centaurus</span>
<span class="line"> Alpha Centauri B   0.91     1.3300       0         Centaurus</span>
<span class="line"> Proxima Centauri   0.12    10.4300       3         Centaurus</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="closing-remarks" tabindex="-1"><a class="header-anchor" href="#closing-remarks"><span>Closing Remarks</span></a></h2><p>Customized user input is not something that a programming environment can ignore, and the diversity of methodologies in computational chemistry demands a robust and efficient conduit for new input directives in any program. We hope that STORMM&#39;s methods, which require about 50 lines of conformal &quot;overhead&quot; to support any number of new keywords and convey their meaning to the user, will streamline the process of making new methods of professional quality using STORMM&#39;s advanced GPU kernels.</p></div><!--[--><!--]--></div><footer class="vp-page-meta"><!----><div class="vp-meta-item git-info"><div class="vp-meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><!----></div></footer><!----><!--[--><!--]--></main><!--]--></div><!--[--><!----><!--]--><!--]--></div>
    <script type="module" src="/assets/app-klz2yyuf.js" defer></script>
  </body>
</html>
