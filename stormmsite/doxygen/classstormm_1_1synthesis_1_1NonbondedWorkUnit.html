<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>STORMM Source Documentation: stormm::synthesis::NonbondedWorkUnit Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">STORMM Source Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>stormm</b></li><li class="navelem"><b>synthesis</b></li><li class="navelem"><a class="el" href="classstormm_1_1synthesis_1_1NonbondedWorkUnit.html">NonbondedWorkUnit</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classstormm_1_1synthesis_1_1NonbondedWorkUnit-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">stormm::synthesis::NonbondedWorkUnit Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Collect a series of tiles for non-bonded computations as well as the required atom imports to carry them out. This will accomplish the task of planning the non-bonded computation, given a single topology or a synthesis of topologies, to optimize the thread utilization on a GPU.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="nonbonded__workunit_8h_source.html">nonbonded_workunit.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aaef46586bbf17efac469d9d19fea3f1c" id="r_aaef46586bbf17efac469d9d19fea3f1c"><td class="memItemLeft" align="right" valign="top"><a id="aaef46586bbf17efac469d9d19fea3f1c" name="aaef46586bbf17efac469d9d19fea3f1c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getTileCount</b> () const</td></tr>
<tr class="memdesc:aaef46586bbf17efac469d9d19fea3f1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the tile count of this work units. <br /></td></tr>
<tr class="separator:aaef46586bbf17efac469d9d19fea3f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ceea18b1935b498afe454d1d52d3c6e" id="r_a1ceea18b1935b498afe454d1d52d3c6e"><td class="memItemLeft" align="right" valign="top"><a id="a1ceea18b1935b498afe454d1d52d3c6e" name="a1ceea18b1935b498afe454d1d52d3c6e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getImportCount</b> () const</td></tr>
<tr class="memdesc:a1ceea18b1935b498afe454d1d52d3c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of tile_length atom imports needed for this work units. <br /></td></tr>
<tr class="separator:a1ceea18b1935b498afe454d1d52d3c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a577b821f2e19ce90606ca51a72c4d74f" id="r_a577b821f2e19ce90606ca51a72c4d74f"><td class="memItemLeft" align="right" valign="top"><a id="a577b821f2e19ce90606ca51a72c4d74f" name="a577b821f2e19ce90606ca51a72c4d74f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getInitializationMask</b> () const</td></tr>
<tr class="memdesc:a577b821f2e19ce90606ca51a72c4d74f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the mask for initializing per-atom properties on any of the imported atom groups. <br /></td></tr>
<tr class="separator:a577b821f2e19ce90606ca51a72c4d74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b58988b24dc9257b9a15872f6110ddb" id="r_a9b58988b24dc9257b9a15872f6110ddb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstormm_1_1data__types_1_1int4.html">int4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b58988b24dc9257b9a15872f6110ddb">getTileLimits</a> (int index) const</td></tr>
<tr class="memdesc:a9b58988b24dc9257b9a15872f6110ddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the abscissa and ordinate atom limits for a tile from within this work unit. The abscissa limits are returned in the x and y members, the ordinate limits in the z and w members.  <br /></td></tr>
<tr class="separator:a9b58988b24dc9257b9a15872f6110ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cefca66eafb3d3e2f501475bff4990a" id="r_a4cefca66eafb3d3e2f501475bff4990a"><td class="memItemLeft" align="right" valign="top"><a id="a4cefca66eafb3d3e2f501475bff4990a" name="a4cefca66eafb3d3e2f501475bff4990a"></a>
const std::vector&lt; <a class="el" href="structstormm_1_1data__types_1_1uint2.html">uint2</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getTileInstructions</b> () const</td></tr>
<tr class="memdesc:a4cefca66eafb3d3e2f501475bff4990a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of tile instructions for this work unit. <br /></td></tr>
<tr class="separator:a4cefca66eafb3d3e2f501475bff4990a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7212b5b8fbe32aa53891af65be68f23" id="r_af7212b5b8fbe32aa53891af65be68f23"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7212b5b8fbe32aa53891af65be68f23">getAbstract</a> (int instruction_start=0) const</td></tr>
<tr class="memdesc:af7212b5b8fbe32aa53891af65be68f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an abstract for this work unit, layed out to work within an <a class="el" href="classstormm_1_1synthesis_1_1AtomGraphSynthesis.html" title="A collection of one or more AtomGraph objects, with similar components arranged in contiguous arrays ...">AtomGraphSynthesis</a>. For TILE_GROUPS-type work units serving systems in isolated boundary conditions, the non-bonded abstract has the following format:  <br /></td></tr>
<tr class="separator:af7212b5b8fbe32aa53891af65be68f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a934e9b48ebe377c1e524633bca267445" id="r_a934e9b48ebe377c1e524633bca267445"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a934e9b48ebe377c1e524633bca267445">setInitializationMask</a> (int mask_in)</td></tr>
<tr class="memdesc:a934e9b48ebe377c1e524633bca267445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the initialization mask for atomic properties that contribute once to an accumulated sum, i.e. contributions of baseline atomic radii to the Generalized Born effective radii.  <br /></td></tr>
<tr class="separator:a934e9b48ebe377c1e524633bca267445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9186c9074fec4cdc0a2f017e22f7ef6d" id="r_a9186c9074fec4cdc0a2f017e22f7ef6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9186c9074fec4cdc0a2f017e22f7ef6d">setRefreshAtomIndex</a> (int index_in)</td></tr>
<tr class="memdesc:a9186c9074fec4cdc0a2f017e22f7ef6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the atom index at which to begin accumulator refreshing. The actual work done depends on the accumulator refresh code set by the next member function.  <br /></td></tr>
<tr class="separator:a9186c9074fec4cdc0a2f017e22f7ef6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b1c72f14d870074bde99e7a859655f" id="r_a79b1c72f14d870074bde99e7a859655f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79b1c72f14d870074bde99e7a859655f">setRefreshWorkCode</a> (int code_in)</td></tr>
<tr class="memdesc:a79b1c72f14d870074bde99e7a859655f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the accumulator refreshing instructions for this work unit, i.e. "set X force
       accumulators to zero for this many atoms." The refreshing starts at the atom index set by the preceding member function.  <br /></td></tr>
<tr class="separator:a79b1c72f14d870074bde99e7a859655f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6a01ba67ec5ab427365627316d74a899" id="r_a6a01ba67ec5ab427365627316d74a899"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a01ba67ec5ab427365627316d74a899">NonbondedWorkUnit</a> (const <a class="el" href="classstormm_1_1energy_1_1StaticExclusionMask.html">StaticExclusionMask</a> &amp;se, const std::vector&lt; <a class="el" href="structstormm_1_1data__types_1_1int3.html">int3</a> &gt; &amp;tile_list)</td></tr>
<tr class="memdesc:a6a01ba67ec5ab427365627316d74a899"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructor accepts an exclusion mask and a list of nonbonded interaction tiles to compute. Non-bonded interaction tiles go according to "abscissa atoms" and "ordinate atoms," although both abscissa and ordinate indices refer to the same list of imported atoms. There are three cases to consider:  <br /></td></tr>
<tr class="separator:a6a01ba67ec5ab427365627316d74a899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a3aad39f823bb1b20c9b11e447cb7d0" id="r_a0a3aad39f823bb1b20c9b11e447cb7d0"><td class="memItemLeft" align="right" valign="top"><a id="a0a3aad39f823bb1b20c9b11e447cb7d0" name="a0a3aad39f823bb1b20c9b11e447cb7d0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NonbondedWorkUnit</b> (const <a class="el" href="classstormm_1_1energy_1_1StaticExclusionMask.html">StaticExclusionMask</a> &amp;se, int abscissa_start, int ordinate_start)</td></tr>
<tr class="separator:a0a3aad39f823bb1b20c9b11e447cb7d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa67cff18d1cee5f10832ed2fb466d1" id="r_aaaa67cff18d1cee5f10832ed2fb466d1"><td class="memItemLeft" align="right" valign="top"><a id="aaaa67cff18d1cee5f10832ed2fb466d1" name="aaaa67cff18d1cee5f10832ed2fb466d1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NonbondedWorkUnit</b> (const <a class="el" href="classstormm_1_1synthesis_1_1StaticExclusionMaskSynthesis.html">StaticExclusionMaskSynthesis</a> &amp;se, const std::vector&lt; <a class="el" href="structstormm_1_1data__types_1_1int3.html">int3</a> &gt; &amp;tile_list)</td></tr>
<tr class="separator:aaaa67cff18d1cee5f10832ed2fb466d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62458a9ccb4d4193e51b4a0a006bb9be" id="r_a62458a9ccb4d4193e51b4a0a006bb9be"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62458a9ccb4d4193e51b4a0a006bb9be">NonbondedWorkUnit</a> (const <a class="el" href="classstormm_1_1synthesis_1_1StaticExclusionMaskSynthesis.html">StaticExclusionMaskSynthesis</a> &amp;se, int abscissa_start, int ordinate_start, int system_index)</td></tr>
<tr class="separator:a62458a9ccb4d4193e51b4a0a006bb9be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a691cb5b34e2ccbe54d780a026f6c6b48" id="r_a691cb5b34e2ccbe54d780a026f6c6b48"><td class="memItemLeft" align="right" valign="top"><a id="a691cb5b34e2ccbe54d780a026f6c6b48" name="a691cb5b34e2ccbe54d780a026f6c6b48"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NonbondedWorkUnit</b> (const <a class="el" href="classstormm_1_1synthesis_1_1NonbondedWorkUnit.html">NonbondedWorkUnit</a> &amp;original)=default</td></tr>
<tr class="memdesc:a691cb5b34e2ccbe54d780a026f6c6b48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the default copy and move constructors as well as assignment operators for this object, which uses only Standard Template Library member variable types. <br /></td></tr>
<tr class="separator:a691cb5b34e2ccbe54d780a026f6c6b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a602f565d951dd978ee24dad2db551002" id="r_a602f565d951dd978ee24dad2db551002"><td class="memItemLeft" align="right" valign="top"><a id="a602f565d951dd978ee24dad2db551002" name="a602f565d951dd978ee24dad2db551002"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NonbondedWorkUnit</b> (<a class="el" href="classstormm_1_1synthesis_1_1NonbondedWorkUnit.html">NonbondedWorkUnit</a> &amp;&amp;original)=default</td></tr>
<tr class="separator:a602f565d951dd978ee24dad2db551002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a804cb3a7ce3d0c223971bd9111d50108" id="r_a804cb3a7ce3d0c223971bd9111d50108"><td class="memItemLeft" align="right" valign="top"><a id="a804cb3a7ce3d0c223971bd9111d50108" name="a804cb3a7ce3d0c223971bd9111d50108"></a>
<a class="el" href="classstormm_1_1synthesis_1_1NonbondedWorkUnit.html">NonbondedWorkUnit</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classstormm_1_1synthesis_1_1NonbondedWorkUnit.html">NonbondedWorkUnit</a> &amp;other)=default</td></tr>
<tr class="separator:a804cb3a7ce3d0c223971bd9111d50108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f2a0543547588be29e8ffc475e6da8" id="r_a95f2a0543547588be29e8ffc475e6da8"><td class="memItemLeft" align="right" valign="top"><a id="a95f2a0543547588be29e8ffc475e6da8" name="a95f2a0543547588be29e8ffc475e6da8"></a>
<a class="el" href="classstormm_1_1synthesis_1_1NonbondedWorkUnit.html">NonbondedWorkUnit</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classstormm_1_1synthesis_1_1NonbondedWorkUnit.html">NonbondedWorkUnit</a> &amp;&amp;other)=default</td></tr>
<tr class="separator:a95f2a0543547588be29e8ffc475e6da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Collect a series of tiles for non-bonded computations as well as the required atom imports to carry them out. This will accomplish the task of planning the non-bonded computation, given a single topology or a synthesis of topologies, to optimize the thread utilization on a GPU. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6a01ba67ec5ab427365627316d74a899" name="a6a01ba67ec5ab427365627316d74a899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a01ba67ec5ab427365627316d74a899">&#9670;&#160;</a></span>NonbondedWorkUnit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">stormm::synthesis::NonbondedWorkUnit::NonbondedWorkUnit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstormm_1_1energy_1_1StaticExclusionMask.html">StaticExclusionMask</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>se</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structstormm_1_1data__types_1_1int3.html">int3</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>tile_list</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The constructor accepts an exclusion mask and a list of nonbonded interaction tiles to compute. Non-bonded interaction tiles go according to "abscissa atoms" and "ordinate atoms," although both abscissa and ordinate indices refer to the same list of imported atoms. There are three cases to consider: </p>
<p>Static exclusion mask, tiny up to large work units: This will be the majority of the cases with implicit-solvent systems. In practice, the non-bonded work unit becomes a list of 50 integers. A complete description is available in the documentation for the <a class="el" href="#af7212b5b8fbe32aa53891af65be68f23" title="Get an abstract for this work unit, layed out to work within an AtomGraphSynthesis....">getAbstract()</a> member function of this object. These cases will run with a 256-thread block size.</p>
<p>Static exclusion mask, huge work units: This will handle cases of implicit-solvent systems with sizes so large that millions of smaller work units would be required to cover everything. In practice, the non-bonded work unit is reduced to a list of 8 integers, now representing the lower limits of the abscissa and ordinate atoms to import, and the numbers of atoms to import along each axis, in a supertile for which the work unit is to compute all interactions. There is no meaningful list of all interactions in this case, as it might be prohibitive even to store such a thing. Instead, the work unit will proceed over all tiles in the supertile after computing whether it lies along the diagonal. This will require a larger block size (512 threads minimum, up to 768 depending on the architecture).</p>
<p>Forward exclusion mask: This will handle cases of neighbor list-based non-bonded work units. The work unit assumes a honeycomb-packed image of all atoms in or about the primary unit cell (some honeycomb pencils will straddle the unit cell boundary but their positions will be known as part of the decomposition). The work unit will consist of thirty integers: seven starting locations of atom imports, seven bit-packed integers detailing the lengths of each stretch of atoms (first 20 bits) and the obligatory y- and z- imaging moves to make with such atoms (last 12 bits), seven integers detailing segments of each stretch of imported atoms to replicate in +x (and where in the list of imported atoms to put them), and finally seven integers detailing segments of each stretch of imported atoms to replicate in -x (and where to put the replicas). The final two integers state the starting and ending indices of a list of tile instructions to process. The tile instructions for the neighbor list-based non-bonded work units are much more complex than those for non-bonded work based on a static exclusion mask.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">se</td><td>Static exclusion mask, or synthesis thereof, for one or more systems in isolated boundary conditions </td></tr>
    <tr><td class="paramname">tile_list</td><td>Paired with a static exclusion mask and non-huge tiles, the specific list of tiles to include for this work unit in the x- and y-members, plus the system index number in the z member (if more than one system is present in a synthesis). Among them, the tiles must not call for importing more than small_block_max_atoms atoms. </td></tr>
    <tr><td class="paramname">abscissa_start</td><td>The abscissa axis start of the supertile to process. Paired with a static exclusion mask in extreme circumstances of very large implicit solvent systems. This will call for importing 512 atoms (2 x supertile_length) in the most general case and will require larger thread blocks. If computing for a synthesis of static exclusion masks, the abscissa starting point is given as a relative index within the local system to which the supertile belongs. </td></tr>
    <tr><td class="paramname">ordinate_start</td><td>The ordinate axis start of the supertile to process. If computing for a synthesis of static exclusion masks, the ordinate starting point is given as a relative index within the local system to which the supertile belongs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62458a9ccb4d4193e51b4a0a006bb9be" name="a62458a9ccb4d4193e51b4a0a006bb9be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62458a9ccb4d4193e51b4a0a006bb9be">&#9670;&#160;</a></span>NonbondedWorkUnit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">stormm::synthesis::NonbondedWorkUnit::NonbondedWorkUnit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstormm_1_1synthesis_1_1StaticExclusionMaskSynthesis.html">StaticExclusionMaskSynthesis</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>se</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>abscissa_start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ordinate_start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>system_index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Obtain the system index</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af7212b5b8fbe32aa53891af65be68f23" name="af7212b5b8fbe32aa53891af65be68f23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7212b5b8fbe32aa53891af65be68f23">&#9670;&#160;</a></span>getAbstract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; stormm::synthesis::NonbondedWorkUnit::getAbstract </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>instruction_start</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an abstract for this work unit, layed out to work within an <a class="el" href="classstormm_1_1synthesis_1_1AtomGraphSynthesis.html" title="A collection of one or more AtomGraph objects, with similar components arranged in contiguous arrays ...">AtomGraphSynthesis</a>. For TILE_GROUPS-type work units serving systems in isolated boundary conditions, the non-bonded abstract has the following format: </p>
<p>Slot Description </p><hr  />
<p> 0 The total number of atom group imports for various tiles. Each group is up to 16 atoms, and all atoms pertain to a single system in the synthesis. 1-20 Starting atom indices of each tile group in the topology / coordinate synthesis (the extent of this segment is set by small_block_max_imports) 21-25 Counts of the numbers of atoms in each tile group, with four groups' counts packed into each int. In this scheme, the tile length may be extended up to 128 atoms (256 if these values are read as unsigned ints), but a tile length of 16 appears to be optimal for NVIDIA and probably other architectures as well. 26-27 Starting and ending locations of the tile instruction list. After reading up to 20 tile atom groups, each work unit tries to combine the groups into different combinations of actual tiles. The two interacting groups are given in the x-member of a <a class="el" href="structstormm_1_1uint2.html">uint2</a> tuple, while the starting location of exclusion bit masks for the tile is given in the y-member. The difference between values in slots 26 and 27 indicates the number of tiles to perform, and is designed to be a multiple of eight if possible (anticipating blocks of four or eight warps, with one warp handling each tile). 28-47 System indices within the synthesis to which the atoms in each tile group pertain 48 Bitmask indicating whether the current work unit is the first to import a particular group of atoms and therefore can be tasked with contributing certain per-atom effects when accumulating forces or radii due to those atoms 49-50 Lower and upper limits of atoms for which the work unit is tasked with initializing force or other property accumulators to have them ready for use in future iterations of the molecular mechanics force / energy evaluation cycle. The integer in slot 49 indicates the first atom of a contiguous list, and need to be an atom that the work unit imported for one of its tile computations. The integer in slot 50 is a bit-packed value, with the low 16 bits indicating up to 65,504 (not 65,536) atoms following the first index. The high 16 bits of the integer in slot 50 indicate whether to initialize force X, Y, or Z as well as psi or sum_deijda accumulators for the next iteration of the cycle (one bit per accumulator), as well as whether to perform random number caching for up to 15 cycles. These two slots of the work unit can be altered after the non-bonded work unit list is constructed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instruction_start</td><td>The starting point of instructions for this group of tiles, if the work unit will fit on a small thread block, having less than huge_nbwu_tiles tiles. Otherwise no instruction start is needed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b58988b24dc9257b9a15872f6110ddb" name="a9b58988b24dc9257b9a15872f6110ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b58988b24dc9257b9a15872f6110ddb">&#9670;&#160;</a></span>getTileLimits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstormm_1_1data__types_1_1int4.html">int4</a> stormm::synthesis::NonbondedWorkUnit::getTileLimits </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the abscissa and ordinate atom limits for a tile from within this work unit. The abscissa limits are returned in the x and y members, the ordinate limits in the z and w members. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the tile from within the work unit </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a934e9b48ebe377c1e524633bca267445" name="a934e9b48ebe377c1e524633bca267445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a934e9b48ebe377c1e524633bca267445">&#9670;&#160;</a></span>setInitializationMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::synthesis::NonbondedWorkUnit::setInitializationMask </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>mask_in</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the initialization mask for atomic properties that contribute once to an accumulated sum, i.e. contributions of baseline atomic radii to the Generalized Born effective radii. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask_in</td><td>The new mask to use. If the jth bit of this mask is set to 1, the work unit will perform initialization protocols on its jth set of atom imports, i.e. the Born radii derivatives for those atoms will be contributed to the force accumulators. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9186c9074fec4cdc0a2f017e22f7ef6d" name="a9186c9074fec4cdc0a2f017e22f7ef6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9186c9074fec4cdc0a2f017e22f7ef6d">&#9670;&#160;</a></span>setRefreshAtomIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::synthesis::NonbondedWorkUnit::setRefreshAtomIndex </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index_in</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the atom index at which to begin accumulator refreshing. The actual work done depends on the accumulator refresh code set by the next member function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index_in</td><td>The starting atom index relevant to this work unit </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a79b1c72f14d870074bde99e7a859655f" name="a79b1c72f14d870074bde99e7a859655f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79b1c72f14d870074bde99e7a859655f">&#9670;&#160;</a></span>setRefreshWorkCode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::synthesis::NonbondedWorkUnit::setRefreshWorkCode </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>code_in</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the accumulator refreshing instructions for this work unit, i.e. "set X force
       accumulators to zero for this many atoms." The refreshing starts at the atom index set by the preceding member function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code_in</td><td>The refesh code to execute </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/Synthesis/<a class="el" href="nonbonded__workunit_8h_source.html">nonbonded_workunit.h</a></li>
<li>src/Synthesis/<b>nonbonded_workunit.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2
</small></address>
</div><!-- doc-content -->
</body>
</html>
