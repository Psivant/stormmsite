<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>STORMM Source Documentation: stormm::structure::MeshForceField&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">STORMM Source Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>stormm</b></li><li class="navelem"><b>structure</b></li><li class="navelem"><a class="el" href="classstormm_1_1structure_1_1MeshForceField.html">MeshForceField</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classstormm_1_1structure_1_1MeshForceField-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">stormm::structure::MeshForceField&lt; T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A class to hold the rules by which the system underlying a mesh object interacts with its surroundings. The mesh object itself may have one probe or an array of them (for an array of potential surfaces), but the constants, rules, and modifying potentials in this object will determine how those probes interact with the underlying system.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="mesh__forcefield_8h_source.html">mesh_forcefield.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae9fe96c93cc43ec1d5920c52d62923df" id="r_ae9fe96c93cc43ec1d5920c52d62923df"><td class="memItemLeft" align="right" valign="top"><a id="ae9fe96c93cc43ec1d5920c52d62923df" name="ae9fe96c93cc43ec1d5920c52d62923df"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MeshForceField</b> (VdwCombiningRule mixing_protocol_in=VdwCombiningRule::LORENTZ_BERTHELOT, double coulomb_constant_in=amber_ancient_bioq, double clash_ratio_in=0.0, double clash_distance_in=0.0, int lj_type_count_in=0)</td></tr>
<tr class="memdesc:ae9fe96c93cc43ec1d5920c52d62923df"><td class="mdescLeft">&#160;</td><td class="mdescRight">The object is a convenient place to store constants and arrays of coefficients, nothing more. The constructor accepts these constants as well as sizing information for its arrays and allocates the appropriate amount of memory. Filling the arrays is a matter for the particular mesh object "creating" (perhaps more precise to say "populating") the force field. <br /></td></tr>
<tr class="separator:ae9fe96c93cc43ec1d5920c52d62923df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f7e0945b75d4b348e5560f3411d1f6c" id="r_a6f7e0945b75d4b348e5560f3411d1f6c"><td class="memItemLeft" align="right" valign="top"><a id="a6f7e0945b75d4b348e5560f3411d1f6c" name="a6f7e0945b75d4b348e5560f3411d1f6c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MeshForceField</b> (VdwCombiningRule mixing_protocol_in, double clash_ratio_in, double clash_distance_in, const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> *ag)</td></tr>
<tr class="separator:a6f7e0945b75d4b348e5560f3411d1f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17844d69a7041070afe389d4931c7bdc" id="r_a17844d69a7041070afe389d4931c7bdc"><td class="memItemLeft" align="right" valign="top"><a id="a17844d69a7041070afe389d4931c7bdc" name="a17844d69a7041070afe389d4931c7bdc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MeshForceField</b> (VdwCombiningRule mixing_protocol_in, double clash_ratio_in, double clash_distance_in, const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;ag)</td></tr>
<tr class="separator:a17844d69a7041070afe389d4931c7bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff7f595a55c1cbad932a16f3a2c7eb14" id="r_aff7f595a55c1cbad932a16f3a2c7eb14"><td class="memItemLeft" align="right" valign="top"><a id="aff7f595a55c1cbad932a16f3a2c7eb14" name="aff7f595a55c1cbad932a16f3a2c7eb14"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MeshForceField</b> (VdwCombiningRule mixing_protocol_in, double coulomb_constant_in, double clash_ratio_in, double clash_distance_in, const std::vector&lt; double &gt; &amp;probe_sigma, const std::vector&lt; double &gt; &amp;probe_epsilon)</td></tr>
<tr class="separator:aff7f595a55c1cbad932a16f3a2c7eb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9494b75999350ba2f8e616914f0a10d" id="r_ac9494b75999350ba2f8e616914f0a10d"><td class="memItemLeft" align="right" valign="top"><a id="ac9494b75999350ba2f8e616914f0a10d" name="ac9494b75999350ba2f8e616914f0a10d"></a>
VdwCombiningRule&#160;</td><td class="memItemRight" valign="bottom"><b>getCombiningRule</b> () const</td></tr>
<tr class="memdesc:ac9494b75999350ba2f8e616914f0a10d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Lennard-Jones mixing rule. <br /></td></tr>
<tr class="separator:ac9494b75999350ba2f8e616914f0a10d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c010648f4dac5ab9e4135c2b1d2f3a" id="r_aa0c010648f4dac5ab9e4135c2b1d2f3a"><td class="memItemLeft" align="right" valign="top"><a id="aa0c010648f4dac5ab9e4135c2b1d2f3a" name="aa0c010648f4dac5ab9e4135c2b1d2f3a"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getClashRatio</b> () const</td></tr>
<tr class="memdesc:aa0c010648f4dac5ab9e4135c2b1d2f3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ratio of the van-der Waals (Lennard-Jones) sigma parameter for interacting pairs of particles at which softcore van-der Waals interactions take over. <br /></td></tr>
<tr class="separator:aa0c010648f4dac5ab9e4135c2b1d2f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a651c32a263f5c734d0a93f72c6c93928" id="r_a651c32a263f5c734d0a93f72c6c93928"><td class="memItemLeft" align="right" valign="top"><a id="a651c32a263f5c734d0a93f72c6c93928" name="a651c32a263f5c734d0a93f72c6c93928"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getClashDistance</b> () const</td></tr>
<tr class="memdesc:a651c32a263f5c734d0a93f72c6c93928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the absolute distance at which softcore electrostatic interactions take over. <br /></td></tr>
<tr class="separator:a651c32a263f5c734d0a93f72c6c93928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15265ccef99bd393f7da583a7a2b124" id="r_ac15265ccef99bd393f7da583a7a2b124"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structstormm_1_1structure_1_1MeshFFKit.html">MeshFFKit</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac15265ccef99bd393f7da583a7a2b124">data</a> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:ac15265ccef99bd393f7da583a7a2b124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the abstract in whatever templated type (float or double) the object is cast in.  <br /></td></tr>
<tr class="separator:ac15265ccef99bd393f7da583a7a2b124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a374f58881698c9e3092ab9710147eb41" id="r_a374f58881698c9e3092ab9710147eb41"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structstormm_1_1structure_1_1MeshFFKit.html">MeshFFKit</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a374f58881698c9e3092ab9710147eb41">referenceData</a> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:a374f58881698c9e3092ab9710147eb41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the refernce data in double precision, regardless of how the object is cast.  <br /></td></tr>
<tr class="separator:a374f58881698c9e3092ab9710147eb41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfbefcbe70298d10bd32afd1e32f05ad" id="r_acfbefcbe70298d10bd32afd1e32f05ad"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structstormm_1_1structure_1_1MeshFFKit.html">MeshFFKit</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acfbefcbe70298d10bd32afd1e32f05ad">templateFreeData</a> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:acfbefcbe70298d10bd32afd1e32f05ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a template-free form of the object's abstract in its native type.  <br /></td></tr>
<tr class="separator:acfbefcbe70298d10bd32afd1e32f05ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640f537e1d602d258842111965cbba57" id="r_a640f537e1d602d258842111965cbba57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a640f537e1d602d258842111965cbba57">setCombiningRule</a> (VdwCombiningRule mixing_protocol_in)</td></tr>
<tr class="memdesc:a640f537e1d602d258842111965cbba57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the combining rule that will be used to make the probe interact with the receptor on any mesh (with the exception of an electrostatic field). Checks on the validity of this setting must be made by the mesh that assembles the <a class="el" href="classstormm_1_1structure_1_1MeshForceField.html" title="A class to hold the rules by which the system underlying a mesh object interacts with its surrounding...">MeshForceField</a> object.  <br /></td></tr>
<tr class="separator:a640f537e1d602d258842111965cbba57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a661ff7897882f0956c97749e0d993db4" id="r_a661ff7897882f0956c97749e0d993db4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a661ff7897882f0956c97749e0d993db4">setClashDistance</a> (double clash_distance_in)</td></tr>
<tr class="memdesc:a661ff7897882f0956c97749e0d993db4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the absolute distance at which electrostatic charges will begin to be damped according to the softcore scheme (a harmonic potential with a relative maximum at r = -1.0 takes over).  <br /></td></tr>
<tr class="separator:a661ff7897882f0956c97749e0d993db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b0616c1150580dbd18af0d1f7cf03ee" id="r_a6b0616c1150580dbd18af0d1f7cf03ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b0616c1150580dbd18af0d1f7cf03ee">setClashRatio</a> (double clash_ratio_in)</td></tr>
<tr class="memdesc:a6b0616c1150580dbd18af0d1f7cf03ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the ratio of the van-der Waals (Lennard-Jones) sigma parameters at which softcore interactions take over (the interaction switches to a quartic potential with a relative maximum at r = -1.0).  <br /></td></tr>
<tr class="separator:a6b0616c1150580dbd18af0d1f7cf03ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2abcd95985f1425d09c18dae4d009e89" id="r_a2abcd95985f1425d09c18dae4d009e89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2abcd95985f1425d09c18dae4d009e89">setElecSoftcoreParameter</a> (double coef, int pos)</td></tr>
<tr class="memdesc:a2abcd95985f1425d09c18dae4d009e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a specific coefficient in the softcore electrostatic polynomial.  <br /></td></tr>
<tr class="separator:a2abcd95985f1425d09c18dae4d009e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a3c7736ae4bbaaab66bb5fec6339d8" id="r_a74a3c7736ae4bbaaab66bb5fec6339d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74a3c7736ae4bbaaab66bb5fec6339d8">setElecSoftcoreParameters</a> (Interpolant stencil_kind)</td></tr>
<tr class="memdesc:a74a3c7736ae4bbaaab66bb5fec6339d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the polynomial for an electrostatic softcore potential suitable for a certain interpolation strategy.  <br /></td></tr>
<tr class="separator:a74a3c7736ae4bbaaab66bb5fec6339d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc4c09d722eff813b5be6e56873ef69" id="r_a7dc4c09d722eff813b5be6e56873ef69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7dc4c09d722eff813b5be6e56873ef69">setLJCoefficients</a> (int index, double lja_in, double ljb_in)</td></tr>
<tr class="memdesc:a7dc4c09d722eff813b5be6e56873ef69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Lennard-Jones pairwise coefficients to describe the interaction of one atom type in the mesh's underlying topology with its probe.  <br /></td></tr>
<tr class="separator:a7dc4c09d722eff813b5be6e56873ef69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8ba714fdf2b700a09ca0ee76dfd316" id="r_a5e8ba714fdf2b700a09ca0ee76dfd316"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e8ba714fdf2b700a09ca0ee76dfd316">setLJSoftcoreParameter</a> (int index, double coef, int pos)</td></tr>
<tr class="memdesc:a5e8ba714fdf2b700a09ca0ee76dfd316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a specific softcore polynomial coefficient.  <br /></td></tr>
<tr class="separator:a5e8ba714fdf2b700a09ca0ee76dfd316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6c853bd2f91cdfe25a539c646cd9807" id="r_ac6c853bd2f91cdfe25a539c646cd9807"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6c853bd2f91cdfe25a539c646cd9807">setLJSoftcoreParameters</a> (Interpolant stencil_kind)</td></tr>
<tr class="memdesc:ac6c853bd2f91cdfe25a539c646cd9807"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute softcore polynomials for the loaded Lennard-Jones parameters, ratio of the sigma parameter at which the handoff is to occur, and a given interpolation strategy.  <br /></td></tr>
<tr class="separator:ac6c853bd2f91cdfe25a539c646cd9807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c26f02d087fc7c98107f1d38c9cafb" id="r_a00c26f02d087fc7c98107f1d38c9cafb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00c26f02d087fc7c98107f1d38c9cafb">reallocate</a> (const int lj_type_count_in)</td></tr>
<tr class="memdesc:a00c26f02d087fc7c98107f1d38c9cafb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocate the object to hold a different number of Lennard-Jones types. The electrostatic softcore potential coefficients will be held in a temporary array during this process so that they may be preserved.  <br /></td></tr>
<tr class="separator:a00c26f02d087fc7c98107f1d38c9cafb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a988ab1d56bb139f2931aa397e5fad2df" id="r_a988ab1d56bb139f2931aa397e5fad2df"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a988ab1d56bb139f2931aa397e5fad2df">MeshForceField</a> (const <a class="el" href="classstormm_1_1structure_1_1MeshForceField.html">MeshForceField</a>&lt; T &gt; &amp;original)</td></tr>
<tr class="memdesc:a988ab1d56bb139f2931aa397e5fad2df"><td class="mdescLeft">&#160;</td><td class="mdescRight">The copy and move constructors as well as assignment operators must be written out to repair various pointers.  <br /></td></tr>
<tr class="separator:a988ab1d56bb139f2931aa397e5fad2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a25047c6fe927f9291048d3c8680b7a" id="r_a0a25047c6fe927f9291048d3c8680b7a"><td class="memItemLeft" align="right" valign="top"><a id="a0a25047c6fe927f9291048d3c8680b7a" name="a0a25047c6fe927f9291048d3c8680b7a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MeshForceField</b> (<a class="el" href="classstormm_1_1structure_1_1MeshForceField.html">MeshForceField</a>&lt; T &gt; &amp;&amp;original)</td></tr>
<tr class="separator:a0a25047c6fe927f9291048d3c8680b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a390c9f288aa304642c0af1c2c8694a02" id="r_a390c9f288aa304642c0af1c2c8694a02"><td class="memItemLeft" align="right" valign="top"><a id="a390c9f288aa304642c0af1c2c8694a02" name="a390c9f288aa304642c0af1c2c8694a02"></a>
<a class="el" href="classstormm_1_1structure_1_1MeshForceField.html">MeshForceField</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classstormm_1_1structure_1_1MeshForceField.html">MeshForceField</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="separator:a390c9f288aa304642c0af1c2c8694a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abee590507aaa18fd77b123a634c0a803" id="r_abee590507aaa18fd77b123a634c0a803"><td class="memItemLeft" align="right" valign="top"><a id="abee590507aaa18fd77b123a634c0a803" name="abee590507aaa18fd77b123a634c0a803"></a>
<a class="el" href="classstormm_1_1structure_1_1MeshForceField.html">MeshForceField</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classstormm_1_1structure_1_1MeshForceField.html">MeshForceField</a>&lt; T &gt; &amp;&amp;other)</td></tr>
<tr class="separator:abee590507aaa18fd77b123a634c0a803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af151fe232763efc065f4b2a95dbf1f31" id="r_af151fe232763efc065f4b2a95dbf1f31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af151fe232763efc065f4b2a95dbf1f31">setLJCoefficients</a> (const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> *ag, const std::vector&lt; double &gt; &amp;probe_radius, const std::vector&lt; double &gt; &amp;probe_well_depth)</td></tr>
<tr class="memdesc:af151fe232763efc065f4b2a95dbf1f31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Lennard-Jones pairwise coefficients based on the mesh's underlying topology.  <br /></td></tr>
<tr class="separator:af151fe232763efc065f4b2a95dbf1f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf6a7124527809197eb8778cbcc2af1" id="r_aebf6a7124527809197eb8778cbcc2af1"><td class="memItemLeft" align="right" valign="top"><a id="aebf6a7124527809197eb8778cbcc2af1" name="aebf6a7124527809197eb8778cbcc2af1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setLJCoefficients</b> (const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;ag, const std::vector&lt; double &gt; &amp;probe_radius, const std::vector&lt; double &gt; &amp;probe_well_depth)</td></tr>
<tr class="separator:aebf6a7124527809197eb8778cbcc2af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a7981d896e9c43ea0cad025829d7f6" id="r_aa3a7981d896e9c43ea0cad025829d7f6"><td class="memItemLeft" align="right" valign="top"><a id="aa3a7981d896e9c43ea0cad025829d7f6" name="aa3a7981d896e9c43ea0cad025829d7f6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setLJCoefficients</b> (const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> *ag, double probe_radius, double probe_well_depth)</td></tr>
<tr class="separator:aa3a7981d896e9c43ea0cad025829d7f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a700e44abbedb28e2119f710e11f2891b" id="r_a700e44abbedb28e2119f710e11f2891b"><td class="memItemLeft" align="right" valign="top"><a id="a700e44abbedb28e2119f710e11f2891b" name="a700e44abbedb28e2119f710e11f2891b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setLJCoefficients</b> (const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;ag, double probe_radius, double probe_well_depth)</td></tr>
<tr class="separator:a700e44abbedb28e2119f710e11f2891b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T&gt;<br />
class stormm::structure::MeshForceField&lt; T &gt;</div><p>A class to hold the rules by which the system underlying a mesh object interacts with its surroundings. The mesh object itself may have one probe or an array of them (for an array of potential surfaces), but the constants, rules, and modifying potentials in this object will determine how those probes interact with the underlying system. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a988ab1d56bb139f2931aa397e5fad2df" name="a988ab1d56bb139f2931aa397e5fad2df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a988ab1d56bb139f2931aa397e5fad2df">&#9670;&#160;</a></span>MeshForceField()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstormm_1_1structure_1_1MeshForceField.html">stormm::structure::MeshForceField</a>&lt; T &gt;::MeshForceField </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstormm_1_1structure_1_1MeshForceField.html">MeshForceField</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>original</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The copy and move constructors as well as assignment operators must be written out to repair various pointers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">original</td><td>The original object to copy or move </td></tr>
    <tr><td class="paramname">other</td><td>An existing object fulfilling the right hand side of an assignment statement </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac15265ccef99bd393f7da583a7a2b124" name="ac15265ccef99bd393f7da583a7a2b124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac15265ccef99bd393f7da583a7a2b124">&#9670;&#160;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structstormm_1_1structure_1_1MeshFFKit.html">MeshFFKit</a>&lt; T &gt; <a class="el" href="classstormm_1_1structure_1_1MeshForceField.html">stormm::structure::MeshForceField</a>&lt; T &gt;::data </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the abstract in whatever templated type (float or double) the object is cast in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tier</td><td>Obtain the data at the level of the CPU host or GPU device </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00c26f02d087fc7c98107f1d38c9cafb" name="a00c26f02d087fc7c98107f1d38c9cafb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00c26f02d087fc7c98107f1d38c9cafb">&#9670;&#160;</a></span>reallocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstormm_1_1structure_1_1MeshForceField.html">stormm::structure::MeshForceField</a>&lt; T &gt;::reallocate </td>
          <td>(</td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>lj_type_count_in</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reallocate the object to hold a different number of Lennard-Jones types. The electrostatic softcore potential coefficients will be held in a temporary array during this process so that they may be preserved. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lj_type_count_in</td><td>The new number of Lennard-Jones types to prepare for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a374f58881698c9e3092ab9710147eb41" name="a374f58881698c9e3092ab9710147eb41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a374f58881698c9e3092ab9710147eb41">&#9670;&#160;</a></span>referenceData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structstormm_1_1structure_1_1MeshFFKit.html">MeshFFKit</a>&lt; double &gt; <a class="el" href="classstormm_1_1structure_1_1MeshForceField.html">stormm::structure::MeshForceField</a>&lt; T &gt;::referenceData </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the refernce data in double precision, regardless of how the object is cast. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tier</td><td>Obtain the data at the level of the CPU host or GPU device </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a661ff7897882f0956c97749e0d993db4" name="a661ff7897882f0956c97749e0d993db4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a661ff7897882f0956c97749e0d993db4">&#9670;&#160;</a></span>setClashDistance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstormm_1_1structure_1_1MeshForceField.html">stormm::structure::MeshForceField</a>&lt; T &gt;::setClashDistance </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>clash_distance_in</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the absolute distance at which electrostatic charges will begin to be damped according to the softcore scheme (a harmonic potential with a relative maximum at r = -1.0 takes over). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clash_distance_in</td><td>The handoff range to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b0616c1150580dbd18af0d1f7cf03ee" name="a6b0616c1150580dbd18af0d1f7cf03ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b0616c1150580dbd18af0d1f7cf03ee">&#9670;&#160;</a></span>setClashRatio()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstormm_1_1structure_1_1MeshForceField.html">stormm::structure::MeshForceField</a>&lt; T &gt;::setClashRatio </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>clash_ratio_in</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the ratio of the van-der Waals (Lennard-Jones) sigma parameters at which softcore interactions take over (the interaction switches to a quartic potential with a relative maximum at r = -1.0). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clash_ratio_in</td><td>The handoff sigma ratio to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a640f537e1d602d258842111965cbba57" name="a640f537e1d602d258842111965cbba57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a640f537e1d602d258842111965cbba57">&#9670;&#160;</a></span>setCombiningRule()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstormm_1_1structure_1_1MeshForceField.html">stormm::structure::MeshForceField</a>&lt; T &gt;::setCombiningRule </td>
          <td>(</td>
          <td class="paramtype">VdwCombiningRule</td>          <td class="paramname"><span class="paramname"><em>mixing_protocol_in</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the combining rule that will be used to make the probe interact with the receptor on any mesh (with the exception of an electrostatic field). Checks on the validity of this setting must be made by the mesh that assembles the <a class="el" href="classstormm_1_1structure_1_1MeshForceField.html" title="A class to hold the rules by which the system underlying a mesh object interacts with its surrounding...">MeshForceField</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mixing_protocol_in</td><td>The method to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2abcd95985f1425d09c18dae4d009e89" name="a2abcd95985f1425d09c18dae4d009e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2abcd95985f1425d09c18dae4d009e89">&#9670;&#160;</a></span>setElecSoftcoreParameter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstormm_1_1structure_1_1MeshForceField.html">stormm::structure::MeshForceField</a>&lt; T &gt;::setElecSoftcoreParameter </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>coef</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a specific coefficient in the softcore electrostatic polynomial. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coef</td><td>The coefficient value to apply </td></tr>
    <tr><td class="paramname">pos</td><td>Order of the coefficient, e.g. in Ax^3 + Bx^2 + Cx + D, D has order zero and C has order 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74a3c7736ae4bbaaab66bb5fec6339d8" name="a74a3c7736ae4bbaaab66bb5fec6339d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74a3c7736ae4bbaaab66bb5fec6339d8">&#9670;&#160;</a></span>setElecSoftcoreParameters()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstormm_1_1structure_1_1MeshForceField.html">stormm::structure::MeshForceField</a>&lt; T &gt;::setElecSoftcoreParameters </td>
          <td>(</td>
          <td class="paramtype">Interpolant</td>          <td class="paramname"><span class="paramname"><em>stencil_kind</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the polynomial for an electrostatic softcore potential suitable for a certain interpolation strategy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stencil_kind</td><td>Prepare for computing energies that will feed into this type of interpolation stencil. SMOOTHNESS interpolants require a fifth-order softcore function providing for three layers of continuous derivatives at the handoff, FUNCTION_VALUE interpolants, while more expensive to compute, require only third-order softcore polynomials with a single continuous derivative at the handoff. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af151fe232763efc065f4b2a95dbf1f31" name="af151fe232763efc065f4b2a95dbf1f31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af151fe232763efc065f4b2a95dbf1f31">&#9670;&#160;</a></span>setLJCoefficients() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstormm_1_1structure_1_1MeshForceField.html">stormm::structure::MeshForceField</a>&lt; T &gt;::setLJCoefficients </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> *</td>          <td class="paramname"><span class="paramname"><em>ag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>probe_radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>probe_well_depth</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the Lennard-Jones pairwise coefficients based on the mesh's underlying topology. </p>
<p>Overloaded:</p><ul>
<li>Provide the topology as a const pointer or const reference</li>
<li>Provide the a single value for the probe radius (sigma) and well depth (epsilon) to be combined with the topology's parameters according to the <a class="el" href="classstormm_1_1structure_1_1MeshForceField.html" title="A class to hold the rules by which the system underlying a mesh object interacts with its surrounding...">MeshForceField</a> object's rule</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ag</td><td>The mesh's underlying topology </td></tr>
    <tr><td class="paramname">probe_radius</td><td>The spherical probe's radius (its sigma parameter if computing a Lennard-Jones non-bonded potential </td></tr>
    <tr><td class="paramname">probe_well_depth</td><td>The probe epsilon parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7dc4c09d722eff813b5be6e56873ef69" name="a7dc4c09d722eff813b5be6e56873ef69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc4c09d722eff813b5be6e56873ef69">&#9670;&#160;</a></span>setLJCoefficients() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstormm_1_1structure_1_1MeshForceField.html">stormm::structure::MeshForceField</a>&lt; T &gt;::setLJCoefficients </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>lja_in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>ljb_in</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the Lennard-Jones pairwise coefficients to describe the interaction of one atom type in the mesh's underlying topology with its probe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the atom type in the underlying topology </td></tr>
    <tr><td class="paramname">lja_in</td><td>The Lennard-Jones A coefficient, as in U(LJ) = A/r^12 - B/r^6 </td></tr>
    <tr><td class="paramname">ljb_in</td><td>The Lennard-Jones B coefficient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e8ba714fdf2b700a09ca0ee76dfd316" name="a5e8ba714fdf2b700a09ca0ee76dfd316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e8ba714fdf2b700a09ca0ee76dfd316">&#9670;&#160;</a></span>setLJSoftcoreParameter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstormm_1_1structure_1_1MeshForceField.html">stormm::structure::MeshForceField</a>&lt; T &gt;::setLJSoftcoreParameter </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>coef</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a specific softcore polynomial coefficient. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Lennard-Jones type index of a mesh atom type for which to apply the coefficient </td></tr>
    <tr><td class="paramname">coef</td><td>The coefficient value to apply </td></tr>
    <tr><td class="paramname">pos</td><td>Order of the coefficient, e.g. in Ax^3 + Bx^2 + Cx + D, D has order zero and C has order 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6c853bd2f91cdfe25a539c646cd9807" name="ac6c853bd2f91cdfe25a539c646cd9807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6c853bd2f91cdfe25a539c646cd9807">&#9670;&#160;</a></span>setLJSoftcoreParameters()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstormm_1_1structure_1_1MeshForceField.html">stormm::structure::MeshForceField</a>&lt; T &gt;::setLJSoftcoreParameters </td>
          <td>(</td>
          <td class="paramtype">Interpolant</td>          <td class="paramname"><span class="paramname"><em>stencil_kind</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute softcore polynomials for the loaded Lennard-Jones parameters, ratio of the sigma parameter at which the handoff is to occur, and a given interpolation strategy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stencil_kind</td><td>Prepare for computing energies that will feed into this type of interpolation stencil. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acfbefcbe70298d10bd32afd1e32f05ad" name="acfbefcbe70298d10bd32afd1e32f05ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfbefcbe70298d10bd32afd1e32f05ad">&#9670;&#160;</a></span>templateFreeData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structstormm_1_1structure_1_1MeshFFKit.html">MeshFFKit</a>&lt; void &gt; <a class="el" href="classstormm_1_1structure_1_1MeshForceField.html">stormm::structure::MeshForceField</a>&lt; T &gt;::templateFreeData </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a template-free form of the object's abstract in its native type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tier</td><td>Obtain the data at the level of the CPU host or GPU device </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/Structure/<a class="el" href="mesh__forcefield_8h_source.html">mesh_forcefield.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2
</small></address>
</div><!-- doc-content -->
</body>
</html>
