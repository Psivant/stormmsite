<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>STORMM Source Documentation: stormm::synthesis::ValenceDelegator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">STORMM Source Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>stormm</b></li><li class="navelem"><b>synthesis</b></li><li class="navelem"><a class="el" href="classstormm_1_1synthesis_1_1ValenceDelegator.html">ValenceDelegator</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classstormm_1_1synthesis_1_1ValenceDelegator-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">stormm::synthesis::ValenceDelegator Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Object to track how different valence terms in a topology are delegated. Valence work units may evaluate a valence term without being responsible for moving both atoms, or even for moving any of the atoms at all. Each valence term is only fully delegated once valence work units that evaluate it are responsible for moving all atoms that the valence term contains. In order for a work unit to move any atom, it must evaluate all valence terms that include that atom.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="valence__workunit_8h_source.html">valence_workunit.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7f5d755b8c2e289f85beaeea8c213a33" id="r_a7f5d755b8c2e289f85beaeea8c213a33"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f5d755b8c2e289f85beaeea8c213a33">ValenceDelegator</a> (const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> *ag_in, const <a class="el" href="classstormm_1_1restraints_1_1RestraintApparatus.html">RestraintApparatus</a> *ra_in=nullptr)</td></tr>
<tr class="memdesc:a7f5d755b8c2e289f85beaeea8c213a33"><td class="mdescLeft">&#160;</td><td class="mdescRight">The object is constructed based on a single topology and oversees the construction of an array of valence work units.  <br /></td></tr>
<tr class="separator:a7f5d755b8c2e289f85beaeea8c213a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec404c878a8e1f426bfcdd89d4a83660" id="r_aec404c878a8e1f426bfcdd89d4a83660"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec404c878a8e1f426bfcdd89d4a83660">getAtomAssignmentCount</a> (int atom_index) const</td></tr>
<tr class="memdesc:aec404c878a8e1f426bfcdd89d4a83660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of work units to which a particular atom is (currently) assigned.  <br /></td></tr>
<tr class="separator:aec404c878a8e1f426bfcdd89d4a83660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29f2e5d829afc060bb969d1e133a0db" id="r_ac29f2e5d829afc060bb969d1e133a0db"><td class="memItemLeft" align="right" valign="top"><a id="ac29f2e5d829afc060bb969d1e133a0db" name="ac29f2e5d829afc060bb969d1e133a0db"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getFirstUnassignedAtom</b> () const</td></tr>
<tr class="memdesc:ac29f2e5d829afc060bb969d1e133a0db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of the first unassigned atom in the topology. <br /></td></tr>
<tr class="separator:ac29f2e5d829afc060bb969d1e133a0db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c43fd9887ee57209ebe797ef32acb1" id="r_aa9c43fd9887ee57209ebe797ef32acb1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9c43fd9887ee57209ebe797ef32acb1">getBondAffectors</a> (const std::vector&lt; int &gt; &amp;atom_indices) const</td></tr>
<tr class="memdesc:aa9c43fd9887ee57209ebe797ef32acb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of bonds affecting a given list of atoms. The result is returned (pruned for unique items) as a series of term indices referencing the original topology.  <br /></td></tr>
<tr class="separator:aa9c43fd9887ee57209ebe797ef32acb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ab2a8624298f6a102713256b48557c" id="r_a30ab2a8624298f6a102713256b48557c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30ab2a8624298f6a102713256b48557c">getAngleAffectors</a> (const std::vector&lt; int &gt; &amp;atom_indices) const</td></tr>
<tr class="memdesc:a30ab2a8624298f6a102713256b48557c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of harmonic angle terms affecting a given list of atoms. The result is returned (pruned for unique items) as a series of term indices referencing the original topology.  <br /></td></tr>
<tr class="separator:a30ab2a8624298f6a102713256b48557c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc014a10e5efaa3e18af11576c58d0e7" id="r_afc014a10e5efaa3e18af11576c58d0e7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc014a10e5efaa3e18af11576c58d0e7">getDihedralAffectors</a> (const std::vector&lt; int &gt; &amp;atom_indices) const</td></tr>
<tr class="memdesc:afc014a10e5efaa3e18af11576c58d0e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of cosine-based dihedrals affecting a given list of atoms. The result is returned (pruned for unique items) as a series of term indices referencing the original topology.  <br /></td></tr>
<tr class="separator:afc014a10e5efaa3e18af11576c58d0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a8c0cedfd3aa17afe09117dcf064aea" id="r_a8a8c0cedfd3aa17afe09117dcf064aea"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a8c0cedfd3aa17afe09117dcf064aea">getUreyBradleyAffectors</a> (const std::vector&lt; int &gt; &amp;atom_indices) const</td></tr>
<tr class="memdesc:a8a8c0cedfd3aa17afe09117dcf064aea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of Urey-Bradley harmonic angles affecting a given list of atoms. The result is returned (pruned for unique items) as a series of term indices referencing the original topology.  <br /></td></tr>
<tr class="separator:a8a8c0cedfd3aa17afe09117dcf064aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac129e2b33b20d9ccc7a32b40469d9cf6" id="r_ac129e2b33b20d9ccc7a32b40469d9cf6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac129e2b33b20d9ccc7a32b40469d9cf6">getCharmmImproperAffectors</a> (const std::vector&lt; int &gt; &amp;atom_indices) const</td></tr>
<tr class="memdesc:ac129e2b33b20d9ccc7a32b40469d9cf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of CHARMM improper dihedral terms affecting a given list of atoms. The result is returned (pruned for unique items) as a series of term indices referencing the original topology.  <br /></td></tr>
<tr class="separator:ac129e2b33b20d9ccc7a32b40469d9cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd8b1795f73e191aebb733e481c2f64" id="r_a6dd8b1795f73e191aebb733e481c2f64"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6dd8b1795f73e191aebb733e481c2f64">getCmapAffectors</a> (const std::vector&lt; int &gt; &amp;atom_indices) const</td></tr>
<tr class="memdesc:a6dd8b1795f73e191aebb733e481c2f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of CMAP terms affecting a given list of atoms. The result is returned (pruned for unique items) as a series of term indices referencing the original topology.  <br /></td></tr>
<tr class="separator:a6dd8b1795f73e191aebb733e481c2f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a310446e207e31011ea662b970e08702b" id="r_a310446e207e31011ea662b970e08702b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a310446e207e31011ea662b970e08702b">getInferred14Affectors</a> (const std::vector&lt; int &gt; &amp;atom_indices) const</td></tr>
<tr class="memdesc:a310446e207e31011ea662b970e08702b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of inferred 1:4 attenuated non-bonded interactions affecting a given list of atoms. The result is returned (pruned for unique items) as a series of term indices referencing the original topology.  <br /></td></tr>
<tr class="separator:a310446e207e31011ea662b970e08702b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116faed2aaeebb74fc9667f941139934" id="r_a116faed2aaeebb74fc9667f941139934"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a116faed2aaeebb74fc9667f941139934">getPositionalRestraintAffectors</a> (const std::vector&lt; int &gt; &amp;atom_indices) const</td></tr>
<tr class="memdesc:a116faed2aaeebb74fc9667f941139934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of positional restraints affecting a given list of atoms. The result is returned (pruned for unique items) as a series of term indices referencing the original topology.  <br /></td></tr>
<tr class="separator:a116faed2aaeebb74fc9667f941139934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63cd20a852640dcffdfcc3c0d098343c" id="r_a63cd20a852640dcffdfcc3c0d098343c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63cd20a852640dcffdfcc3c0d098343c">getDistanceRestraintAffectors</a> (const std::vector&lt; int &gt; &amp;atom_indices) const</td></tr>
<tr class="memdesc:a63cd20a852640dcffdfcc3c0d098343c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of distance restraints affecting a given list of atoms. The result is returned (pruned for unique items) as a series of term indices referencing the original topology.  <br /></td></tr>
<tr class="separator:a63cd20a852640dcffdfcc3c0d098343c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb97e5cc7af7eeabdbf8dd2927097a81" id="r_acb97e5cc7af7eeabdbf8dd2927097a81"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb97e5cc7af7eeabdbf8dd2927097a81">getAngleRestraintAffectors</a> (const std::vector&lt; int &gt; &amp;atom_indices) const</td></tr>
<tr class="memdesc:acb97e5cc7af7eeabdbf8dd2927097a81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of three-point angle restraints affecting a given list of atoms. The result is returned (pruned for unique items) as a series of term indices referencing the original topology.  <br /></td></tr>
<tr class="separator:acb97e5cc7af7eeabdbf8dd2927097a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b5359077fc99a0091212bd2fbecc49a" id="r_a0b5359077fc99a0091212bd2fbecc49a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b5359077fc99a0091212bd2fbecc49a">getDihedralRestraintAffectors</a> (const std::vector&lt; int &gt; &amp;atom_indices) const</td></tr>
<tr class="memdesc:a0b5359077fc99a0091212bd2fbecc49a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of four-point dihedral angle restraints affecting a given list of atoms. The result is returned (pruned for unique items) as a series of term indices referencing the original topology.  <br /></td></tr>
<tr class="separator:a0b5359077fc99a0091212bd2fbecc49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bcc0a67d2524ffecab7584c57595d57" id="r_a8bcc0a67d2524ffecab7584c57595d57"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8bcc0a67d2524ffecab7584c57595d57">getVirtualSiteAffectors</a> (const std::vector&lt; int &gt; &amp;atom_indices) const</td></tr>
<tr class="memdesc:a8bcc0a67d2524ffecab7584c57595d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of virtual site frames affecting a given list of atoms. The result is returned (pruned for unique items) as a series of term indices referencing the original topology.  <br /></td></tr>
<tr class="separator:a8bcc0a67d2524ffecab7584c57595d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf55a94d7cd6319d2b761de3ce7692ff" id="r_acf55a94d7cd6319d2b761de3ce7692ff"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf55a94d7cd6319d2b761de3ce7692ff">getSettleGroupAffectors</a> (const std::vector&lt; int &gt; &amp;atom_indices) const</td></tr>
<tr class="memdesc:acf55a94d7cd6319d2b761de3ce7692ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of SETTLE (fast, rigid water) constraint groups affecting a given list of atoms. The result is returned (pruned for unique items) as a series of term indices referencing the original topology.  <br /></td></tr>
<tr class="separator:acf55a94d7cd6319d2b761de3ce7692ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae741fc489879da798af22b2783923dde" id="r_ae741fc489879da798af22b2783923dde"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae741fc489879da798af22b2783923dde">getConstraintGroupAffectors</a> (const std::vector&lt; int &gt; &amp;atom_indices) const</td></tr>
<tr class="memdesc:ae741fc489879da798af22b2783923dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of hub-and-spoke constraint groups affecting a given list of atoms. The result is returned (pruned for unique items) as a series of term indices referencing the original topology.  <br /></td></tr>
<tr class="separator:ae741fc489879da798af22b2783923dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fab60d02a9a645520dc5137f724ae98" id="r_a7fab60d02a9a645520dc5137f724ae98"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7fab60d02a9a645520dc5137f724ae98">findMovementPartners</a> (int atom_idx, const std::vector&lt; int &gt; &amp;caller_stack={}) const</td></tr>
<tr class="memdesc:a7fab60d02a9a645520dc5137f724ae98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all partners of a given atom such that the work unit will be able to correctly move the atom. This implies all other participants in any constraint group that includes the atom, or (if the atom is a virtual site) all frame atoms and any constraint groups which they participate in. The returned list provides indices of atoms as they are found in the original topology. It is pruned to remove duplicates.  <br /></td></tr>
<tr class="separator:a7fab60d02a9a645520dc5137f724ae98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a0b3116d67405ab61cbbefde882252" id="r_af3a0b3116d67405ab61cbbefde882252"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3a0b3116d67405ab61cbbefde882252">findForcePartners</a> (int atom_idx, const std::vector&lt; int &gt; &amp;caller_stack={}) const</td></tr>
<tr class="memdesc:af3a0b3116d67405ab61cbbefde882252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all partners of a given atom such that the work unit will be able to correctly evaluate the force need to move the atom. This implies other atoms that participate in any valence terms, inferred 1:4 interactions, or restraints involving the atom, as well as other atoms which participate in a virtual site frame with which the atom of interest is involved. If the atom of interest is one of the frame atoms to a virtual site, the relevant atoms also include any atoms involved in valence interactions (i.e. inferred non-bonded 1:4 interactions) with the virtual site itself.  <br /></td></tr>
<tr class="separator:af3a0b3116d67405ab61cbbefde882252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc2bb87b5cc028a0e7317fb0423624b" id="r_a0fc2bb87b5cc028a0e7317fb0423624b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0fc2bb87b5cc028a0e7317fb0423624b">getUpdateDependencies</a> (const int atom_index) const</td></tr>
<tr class="memdesc:a0fc2bb87b5cc028a0e7317fb0423624b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulate a list of all atoms which have bearing on the way that a particular atom shall move. This routine will loop over the ValenceDelgator's bounded arrays for valence terms, restraints, virtual sites, and various constraint groups to determine any other atoms that must move, and any atoms which can contribute forces.  <br /></td></tr>
<tr class="separator:a0fc2bb87b5cc028a0e7317fb0423624b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd456e8e3c6d993ac3635bf32f0da47" id="r_a5fd456e8e3c6d993ac3635bf32f0da47"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5fd456e8e3c6d993ac3635bf32f0da47">getUpdateWorkUnit</a> (int atom_index) const</td></tr>
<tr class="memdesc:a5fd456e8e3c6d993ac3635bf32f0da47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the work unit currently assigned to update an atom's position and velocity. The value of -1 signifies that no work unit has yet been assigned to handle the atom.  <br /></td></tr>
<tr class="separator:a5fd456e8e3c6d993ac3635bf32f0da47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a603d366d6ecdd9e659f70cc60af5b905" id="r_a603d366d6ecdd9e659f70cc60af5b905"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a603d366d6ecdd9e659f70cc60af5b905">getBondAccumulatorWorkUnit</a> (const int bond_index) const</td></tr>
<tr class="memdesc:a603d366d6ecdd9e659f70cc60af5b905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the work unit currently assigned to contribute a particular bond term's energy into the global accumulator.  <br /></td></tr>
<tr class="separator:a603d366d6ecdd9e659f70cc60af5b905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24453450ca91c5b8a5681325cbd4a7b" id="r_ab24453450ca91c5b8a5681325cbd4a7b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab24453450ca91c5b8a5681325cbd4a7b">getAngleAccumulatorWorkUnit</a> (const int angl_index) const</td></tr>
<tr class="memdesc:ab24453450ca91c5b8a5681325cbd4a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the work unit currently assigned to contribute a particular harmonic angle term's energy into the global accumulator.  <br /></td></tr>
<tr class="separator:ab24453450ca91c5b8a5681325cbd4a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92b810643ebb10081dba687cbac3c2e" id="r_ac92b810643ebb10081dba687cbac3c2e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac92b810643ebb10081dba687cbac3c2e">getDihedralAccumulatorWorkUnit</a> (const int dihe_index) const</td></tr>
<tr class="memdesc:ac92b810643ebb10081dba687cbac3c2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the work unit currently assigned to contribute a particular cosine-based dihedral term's energy into the global accumulator.  <br /></td></tr>
<tr class="separator:ac92b810643ebb10081dba687cbac3c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c277b9396de6c782a5ce837ba43b839" id="r_a4c277b9396de6c782a5ce837ba43b839"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c277b9396de6c782a5ce837ba43b839">getUreyBradleyAccumulatorWorkUnit</a> (const int ubrd_index) const</td></tr>
<tr class="memdesc:a4c277b9396de6c782a5ce837ba43b839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the work unit currently assigned to contribute a particular Urey-Bradley term's energy into the global accumulator.  <br /></td></tr>
<tr class="separator:a4c277b9396de6c782a5ce837ba43b839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52056d315ce869cb24459799444fbd12" id="r_a52056d315ce869cb24459799444fbd12"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52056d315ce869cb24459799444fbd12">getCharmmImproperAccumulatorWorkUnit</a> (const int cimp_index) const</td></tr>
<tr class="memdesc:a52056d315ce869cb24459799444fbd12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the work unit currently assigned to contribute a particular CHARMM improper dihedral term's energy into the global accumulator.  <br /></td></tr>
<tr class="separator:a52056d315ce869cb24459799444fbd12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7e0e5d24c8a1e395f2bd012983b967" id="r_a8c7e0e5d24c8a1e395f2bd012983b967"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c7e0e5d24c8a1e395f2bd012983b967">getCmapAccumulatorWorkUnit</a> (const int cmap_index) const</td></tr>
<tr class="memdesc:a8c7e0e5d24c8a1e395f2bd012983b967"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the work unit currently assigned to contribute a particular CMAP term's energy into the global accumulator.  <br /></td></tr>
<tr class="separator:a8c7e0e5d24c8a1e395f2bd012983b967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227d5303c0ce2fb4b9b2f0ea43573634" id="r_a227d5303c0ce2fb4b9b2f0ea43573634"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a227d5303c0ce2fb4b9b2f0ea43573634">getInferred14AccumulatorWorkUnit</a> (const int infr14_index) const</td></tr>
<tr class="memdesc:a227d5303c0ce2fb4b9b2f0ea43573634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the work unit currently assigned to contribute a particular inferred 1:4 attenuated pair interaction energy into the global accumulator.  <br /></td></tr>
<tr class="separator:a227d5303c0ce2fb4b9b2f0ea43573634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5141aa1603805492e32bc82b5692fbb" id="r_ab5141aa1603805492e32bc82b5692fbb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5141aa1603805492e32bc82b5692fbb">getPositionalRestraintAccumulatorWorkUnit</a> (const int rposn_index) const</td></tr>
<tr class="memdesc:ab5141aa1603805492e32bc82b5692fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the work unit currently assigned to contribute a particular positional restraint penalty energy into the global accumulator.  <br /></td></tr>
<tr class="separator:ab5141aa1603805492e32bc82b5692fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a267ce6eea0bac4fc87fad52a35e1c" id="r_ac7a267ce6eea0bac4fc87fad52a35e1c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7a267ce6eea0bac4fc87fad52a35e1c">getDistanceRestraintAccumulatorWorkUnit</a> (const int rbond_index) const</td></tr>
<tr class="memdesc:ac7a267ce6eea0bac4fc87fad52a35e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the work unit currently assigned to contribute a particular distance restraint penalty energy into the global accumulator.  <br /></td></tr>
<tr class="separator:ac7a267ce6eea0bac4fc87fad52a35e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af625a2be4bfe3c4d0698520a4102e651" id="r_af625a2be4bfe3c4d0698520a4102e651"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af625a2be4bfe3c4d0698520a4102e651">getAngleRestraintAccumulatorWorkUnit</a> (const int rangl_index) const</td></tr>
<tr class="memdesc:af625a2be4bfe3c4d0698520a4102e651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the work unit currently assigned to contribute a particular three-point angle restraint penalty energy into the global accumulator.  <br /></td></tr>
<tr class="separator:af625a2be4bfe3c4d0698520a4102e651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3433f7635132ae59b1f510094729f63d" id="r_a3433f7635132ae59b1f510094729f63d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3433f7635132ae59b1f510094729f63d">getDihedralRestraintAccumulatorWorkUnit</a> (const int rdihe_index) const</td></tr>
<tr class="memdesc:a3433f7635132ae59b1f510094729f63d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the work unit currently assigned to contribute a particular four-point dihedral restraint penalty energy into the global accumulator.  <br /></td></tr>
<tr class="separator:a3433f7635132ae59b1f510094729f63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11fca3976169d9b8cb85a221c6de129e" id="r_a11fca3976169d9b8cb85a221c6de129e"><td class="memItemLeft" align="right" valign="top"><a id="a11fca3976169d9b8cb85a221c6de129e" name="a11fca3976169d9b8cb85a221c6de129e"></a>
const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getTopologyPointer</b> () const</td></tr>
<tr class="memdesc:a11fca3976169d9b8cb85a221c6de129e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the topology that this delegator was built for. <br /></td></tr>
<tr class="separator:a11fca3976169d9b8cb85a221c6de129e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a039f7ad7562232339d935442fbce41b7" id="r_a039f7ad7562232339d935442fbce41b7"><td class="memItemLeft" align="right" valign="top"><a id="a039f7ad7562232339d935442fbce41b7" name="a039f7ad7562232339d935442fbce41b7"></a>
const <a class="el" href="classstormm_1_1restraints_1_1RestraintApparatus.html">RestraintApparatus</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getRestraintApparatusPointer</b> () const</td></tr>
<tr class="memdesc:a039f7ad7562232339d935442fbce41b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the topology that this delegator was built for. <br /></td></tr>
<tr class="separator:a039f7ad7562232339d935442fbce41b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938b02dbf832c0e513124d111c2fe5df" id="r_a938b02dbf832c0e513124d111c2fe5df"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a938b02dbf832c0e513124d111c2fe5df">checkPresence</a> (int atom_index, int vwu_index) const</td></tr>
<tr class="memdesc:a938b02dbf832c0e513124d111c2fe5df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that an atom is present in a particular work unit.  <br /></td></tr>
<tr class="separator:a938b02dbf832c0e513124d111c2fe5df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4d0cbd9ba7b0dd8e8744eb774c0f97" id="r_a3f4d0cbd9ba7b0dd8e8744eb774c0f97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f4d0cbd9ba7b0dd8e8744eb774c0f97">markAtomAddition</a> (int vwu_index, int atom_index)</td></tr>
<tr class="memdesc:a3f4d0cbd9ba7b0dd8e8744eb774c0f97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the addition of an atom to a specific <a class="el" href="classstormm_1_1synthesis_1_1ValenceWorkUnit.html" title="An object to collect the components of a valence work unit (which will also track frozen atoms to imp...">ValenceWorkUnit</a>.  <br /></td></tr>
<tr class="separator:a3f4d0cbd9ba7b0dd8e8744eb774c0f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88da529952b4f04afcad928851838c0d" id="r_a88da529952b4f04afcad928851838c0d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88da529952b4f04afcad928851838c0d">setUpdateWorkUnit</a> (int atom_index, int vwu_index)</td></tr>
<tr class="memdesc:a88da529952b4f04afcad928851838c0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the updates (position, velocity) of a particular atom in the topology as the responsibility of a particular work unit in the list. Returns TRUE if the assignment is successful, or FALSE if the assignment has already been made to some work unit.  <br /></td></tr>
<tr class="separator:a88da529952b4f04afcad928851838c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c6d54d32a2aa228f51fdf42d28fc65" id="r_ab0c6d54d32a2aa228f51fdf42d28fc65"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0c6d54d32a2aa228f51fdf42d28fc65">setBondAccumulatorWorkUnit</a> (int bond_index, int vwu_index)</td></tr>
<tr class="memdesc:ab0c6d54d32a2aa228f51fdf42d28fc65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the work unit that will accumulate the potential due to a specific bond interaction. Returns TRUE if the assignment is successful, FALSE if the assignment has already been made to some other work unit.  <br /></td></tr>
<tr class="separator:ab0c6d54d32a2aa228f51fdf42d28fc65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d91fd42daddc70041c2f95acf760ec" id="r_a54d91fd42daddc70041c2f95acf760ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54d91fd42daddc70041c2f95acf760ec">setAngleAccumulatorWorkUnit</a> (int angl_index, int vwu_index)</td></tr>
<tr class="memdesc:a54d91fd42daddc70041c2f95acf760ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the work unit that will accumulate the potential due to a specific harmonic angle interaction. Returns TRUE if the assignment is successful, FALSE if the assignment has already been made to some other work unit.  <br /></td></tr>
<tr class="separator:a54d91fd42daddc70041c2f95acf760ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6483a840da7b3225908b2b902c2edf83" id="r_a6483a840da7b3225908b2b902c2edf83"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6483a840da7b3225908b2b902c2edf83">setDihedralAccumulatorWorkUnit</a> (int dihe_index, int vwu_index)</td></tr>
<tr class="memdesc:a6483a840da7b3225908b2b902c2edf83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the work unit that will accumulate the potential due to a specific cosine-based dihedral interaction. Returns TRUE if the assignment is successful, FALSE if the assignment has already been made to some other work unit.  <br /></td></tr>
<tr class="separator:a6483a840da7b3225908b2b902c2edf83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aac39d9b47b4533789cdbfabedf8f22" id="r_a7aac39d9b47b4533789cdbfabedf8f22"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7aac39d9b47b4533789cdbfabedf8f22">setUreyBradleyAccumulatorWorkUnit</a> (int ubrd_index, int vwu_index)</td></tr>
<tr class="memdesc:a7aac39d9b47b4533789cdbfabedf8f22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the work unit that will accumulate the potential due to a specific Urey-Bradley interaction. Returns TRUE if the assignment is successful, FALSE if the assignment has already been made to some other work unit.  <br /></td></tr>
<tr class="separator:a7aac39d9b47b4533789cdbfabedf8f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e84ef586e8db6f2b691064d1ce31cb3" id="r_a7e84ef586e8db6f2b691064d1ce31cb3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e84ef586e8db6f2b691064d1ce31cb3">setCharmmImproperAccumulatorWorkUnit</a> (int cimp_index, int vwu_index)</td></tr>
<tr class="memdesc:a7e84ef586e8db6f2b691064d1ce31cb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the work unit that will accumulate the potential due to a specific CHARMM improper dihedral interaction. Returns TRUE if the assignment is successful, FALSE if the assignment has already been made to some other work unit.  <br /></td></tr>
<tr class="separator:a7e84ef586e8db6f2b691064d1ce31cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dcb19c17f8fb2d82346c2c284000845" id="r_a6dcb19c17f8fb2d82346c2c284000845"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6dcb19c17f8fb2d82346c2c284000845">setCmapAccumulatorWorkUnit</a> (int cmap_index, int vwu_index)</td></tr>
<tr class="memdesc:a6dcb19c17f8fb2d82346c2c284000845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the work unit that will accumulate the potential due to a specific CMAP splined surface interaction. Returns TRUE if the assignment is successful, FALSE if the assignment has already been made to some other work unit.  <br /></td></tr>
<tr class="separator:a6dcb19c17f8fb2d82346c2c284000845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab84b8090c7fd526d18a5760cd7ad94" id="r_a6ab84b8090c7fd526d18a5760cd7ad94"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ab84b8090c7fd526d18a5760cd7ad94">setInferred14AccumulatorWorkUnit</a> (int infr14_index, int vwu_index)</td></tr>
<tr class="memdesc:a6ab84b8090c7fd526d18a5760cd7ad94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the work unit that will accumulate the potential due to a specific inferred 1:4 non-bonded, attenuated interaction. Returns TRUE if the assignment is successful, FALSE if the assignment has already been made to some other work unit.  <br /></td></tr>
<tr class="separator:a6ab84b8090c7fd526d18a5760cd7ad94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2deeec38aa704edd3ea29ae7e304016b" id="r_a2deeec38aa704edd3ea29ae7e304016b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2deeec38aa704edd3ea29ae7e304016b">setPositionalRestraintAccumulatorWorkUnit</a> (int rposn_index, int vwu_index)</td></tr>
<tr class="memdesc:a2deeec38aa704edd3ea29ae7e304016b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the work unit that will accumulate the potential due to a positional restraint. Returns TRUE if the assignment is successful, FALSE if the assignment has already been made to some other work unit.  <br /></td></tr>
<tr class="separator:a2deeec38aa704edd3ea29ae7e304016b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade0cd3e24df66757b5d3d13a664cbe6e" id="r_ade0cd3e24df66757b5d3d13a664cbe6e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade0cd3e24df66757b5d3d13a664cbe6e">setDistanceRestraintAccumulatorWorkUnit</a> (int rbond_index, int vwu_index)</td></tr>
<tr class="memdesc:ade0cd3e24df66757b5d3d13a664cbe6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the work unit that will accumulate the potential due to a distance restraint. Returns TRUE if the assignment is successful, FALSE if the assignment has already been made to some other work unit.  <br /></td></tr>
<tr class="separator:ade0cd3e24df66757b5d3d13a664cbe6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08395e2a8331330c61b432ecd482e3d5" id="r_a08395e2a8331330c61b432ecd482e3d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08395e2a8331330c61b432ecd482e3d5">setAngleRestraintAccumulatorWorkUnit</a> (int rangl_index, int vwu_index)</td></tr>
<tr class="memdesc:a08395e2a8331330c61b432ecd482e3d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the work unit that will accumulate the potential due to a three-point angle restraint. Returns TRUE if the assignment is successful, FALSE if the assignment has already been made to some other work unit.  <br /></td></tr>
<tr class="separator:a08395e2a8331330c61b432ecd482e3d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a405e1e15813b4dfb4ba474f474dd9966" id="r_a405e1e15813b4dfb4ba474f474dd9966"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a405e1e15813b4dfb4ba474f474dd9966">setDihedralRestraintAccumulatorWorkUnit</a> (int rdihe_index, int vwu_index)</td></tr>
<tr class="memdesc:a405e1e15813b4dfb4ba474f474dd9966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the work unit that will accumulate the potential due to a four-point dihedral restraint. Returns TRUE if the assignment is successful, FALSE if the assignment has already been made to some other work unit.  <br /></td></tr>
<tr class="separator:a405e1e15813b4dfb4ba474f474dd9966"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Object to track how different valence terms in a topology are delegated. Valence work units may evaluate a valence term without being responsible for moving both atoms, or even for moving any of the atoms at all. Each valence term is only fully delegated once valence work units that evaluate it are responsible for moving all atoms that the valence term contains. In order for a work unit to move any atom, it must evaluate all valence terms that include that atom. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7f5d755b8c2e289f85beaeea8c213a33" name="a7f5d755b8c2e289f85beaeea8c213a33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f5d755b8c2e289f85beaeea8c213a33">&#9670;&#160;</a></span>ValenceDelegator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">stormm::synthesis::ValenceDelegator::ValenceDelegator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> *</td>          <td class="paramname"><span class="paramname"><em>ag_in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstormm_1_1restraints_1_1RestraintApparatus.html">RestraintApparatus</a> *</td>          <td class="paramname"><span class="paramname"><em>ra_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The object is constructed based on a single topology and oversees the construction of an array of valence work units. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ag_in</td><td>Pointer to the topology containing valence terms to delegate among work units </td></tr>
    <tr><td class="paramname">ra_in</td><td>Pointer to the complete collection of restraints applicable to the system </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a938b02dbf832c0e513124d111c2fe5df" name="a938b02dbf832c0e513124d111c2fe5df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a938b02dbf832c0e513124d111c2fe5df">&#9670;&#160;</a></span>checkPresence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stormm::synthesis::ValenceDelegator::checkPresence </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>atom_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>vwu_index</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check that an atom is present in a particular work unit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">atom_index</td><td>The topological index of the atom of interest </td></tr>
    <tr><td class="paramname">vwu_index</td><td>Index of the <a class="el" href="classstormm_1_1synthesis_1_1ValenceWorkUnit.html" title="An object to collect the components of a valence work unit (which will also track frozen atoms to imp...">ValenceWorkUnit</a> in a list that this delegator is managing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af3a0b3116d67405ab61cbbefde882252" name="af3a0b3116d67405ab61cbbefde882252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3a0b3116d67405ab61cbbefde882252">&#9670;&#160;</a></span>findForcePartners()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; stormm::synthesis::ValenceDelegator::findForcePartners </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>atom_idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>caller_stack</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find all partners of a given atom such that the work unit will be able to correctly evaluate the force need to move the atom. This implies other atoms that participate in any valence terms, inferred 1:4 interactions, or restraints involving the atom, as well as other atoms which participate in a virtual site frame with which the atom of interest is involved. If the atom of interest is one of the frame atoms to a virtual site, the relevant atoms also include any atoms involved in valence interactions (i.e. inferred non-bonded 1:4 interactions) with the virtual site itself. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">atom_idx</td><td>Topological index of the atom of interest </td></tr>
    <tr><td class="paramname">caller_stack</td><td>Cumulative stack indicaing previous recursive calls. If this gets too long, it will trigger a runtime error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7fab60d02a9a645520dc5137f724ae98" name="a7fab60d02a9a645520dc5137f724ae98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fab60d02a9a645520dc5137f724ae98">&#9670;&#160;</a></span>findMovementPartners()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; stormm::synthesis::ValenceDelegator::findMovementPartners </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>atom_idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>caller_stack</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find all partners of a given atom such that the work unit will be able to correctly move the atom. This implies all other participants in any constraint group that includes the atom, or (if the atom is a virtual site) all frame atoms and any constraint groups which they participate in. The returned list provides indices of atoms as they are found in the original topology. It is pruned to remove duplicates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">atom_idx</td><td>Topological index of the atom of interest </td></tr>
    <tr><td class="paramname">caller_stack</td><td>Cumulative stack indicaing previous recursive calls. If this gets too long, it will trigger a runtime error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab24453450ca91c5b8a5681325cbd4a7b" name="ab24453450ca91c5b8a5681325cbd4a7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab24453450ca91c5b8a5681325cbd4a7b">&#9670;&#160;</a></span>getAngleAccumulatorWorkUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stormm::synthesis::ValenceDelegator::getAngleAccumulatorWorkUnit </td>
          <td>(</td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>angl_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the work unit currently assigned to contribute a particular harmonic angle term's energy into the global accumulator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angl_index</td><td>Topological index of the angle term of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30ab2a8624298f6a102713256b48557c" name="a30ab2a8624298f6a102713256b48557c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30ab2a8624298f6a102713256b48557c">&#9670;&#160;</a></span>getAngleAffectors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; stormm::synthesis::ValenceDelegator::getAngleAffectors </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>atom_indices</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of harmonic angle terms affecting a given list of atoms. The result is returned (pruned for unique items) as a series of term indices referencing the original topology. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">atom_indices</td><td>Topological indices of the atoms of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af625a2be4bfe3c4d0698520a4102e651" name="af625a2be4bfe3c4d0698520a4102e651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af625a2be4bfe3c4d0698520a4102e651">&#9670;&#160;</a></span>getAngleRestraintAccumulatorWorkUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stormm::synthesis::ValenceDelegator::getAngleRestraintAccumulatorWorkUnit </td>
          <td>(</td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>rangl_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the work unit currently assigned to contribute a particular three-point angle restraint penalty energy into the global accumulator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rangl_index</td><td>Index of the three-point angle restraint in the restraint apparatus </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb97e5cc7af7eeabdbf8dd2927097a81" name="acb97e5cc7af7eeabdbf8dd2927097a81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb97e5cc7af7eeabdbf8dd2927097a81">&#9670;&#160;</a></span>getAngleRestraintAffectors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; stormm::synthesis::ValenceDelegator::getAngleRestraintAffectors </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>atom_indices</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of three-point angle restraints affecting a given list of atoms. The result is returned (pruned for unique items) as a series of term indices referencing the original topology. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">atom_indices</td><td>Topological indices of the atoms of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec404c878a8e1f426bfcdd89d4a83660" name="aec404c878a8e1f426bfcdd89d4a83660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec404c878a8e1f426bfcdd89d4a83660">&#9670;&#160;</a></span>getAtomAssignmentCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stormm::synthesis::ValenceDelegator::getAtomAssignmentCount </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>atom_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of work units to which a particular atom is (currently) assigned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">atom_index</td><td>The atom of interest, as indexed in the original topology </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a603d366d6ecdd9e659f70cc60af5b905" name="a603d366d6ecdd9e659f70cc60af5b905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a603d366d6ecdd9e659f70cc60af5b905">&#9670;&#160;</a></span>getBondAccumulatorWorkUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stormm::synthesis::ValenceDelegator::getBondAccumulatorWorkUnit </td>
          <td>(</td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>bond_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the work unit currently assigned to contribute a particular bond term's energy into the global accumulator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bond_index</td><td>Topological index of the bond term of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9c43fd9887ee57209ebe797ef32acb1" name="aa9c43fd9887ee57209ebe797ef32acb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9c43fd9887ee57209ebe797ef32acb1">&#9670;&#160;</a></span>getBondAffectors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; stormm::synthesis::ValenceDelegator::getBondAffectors </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>atom_indices</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of bonds affecting a given list of atoms. The result is returned (pruned for unique items) as a series of term indices referencing the original topology. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">atom_indices</td><td>Topological indices of the atoms of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a52056d315ce869cb24459799444fbd12" name="a52056d315ce869cb24459799444fbd12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52056d315ce869cb24459799444fbd12">&#9670;&#160;</a></span>getCharmmImproperAccumulatorWorkUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stormm::synthesis::ValenceDelegator::getCharmmImproperAccumulatorWorkUnit </td>
          <td>(</td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>cimp_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the work unit currently assigned to contribute a particular CHARMM improper dihedral term's energy into the global accumulator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cimp_index</td><td>Topological index of the CHARMM improper term of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac129e2b33b20d9ccc7a32b40469d9cf6" name="ac129e2b33b20d9ccc7a32b40469d9cf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac129e2b33b20d9ccc7a32b40469d9cf6">&#9670;&#160;</a></span>getCharmmImproperAffectors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; stormm::synthesis::ValenceDelegator::getCharmmImproperAffectors </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>atom_indices</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of CHARMM improper dihedral terms affecting a given list of atoms. The result is returned (pruned for unique items) as a series of term indices referencing the original topology. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">atom_indices</td><td>Topological indices of the atoms of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c7e0e5d24c8a1e395f2bd012983b967" name="a8c7e0e5d24c8a1e395f2bd012983b967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c7e0e5d24c8a1e395f2bd012983b967">&#9670;&#160;</a></span>getCmapAccumulatorWorkUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stormm::synthesis::ValenceDelegator::getCmapAccumulatorWorkUnit </td>
          <td>(</td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>cmap_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the work unit currently assigned to contribute a particular CMAP term's energy into the global accumulator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmap_index</td><td>Topological index of the CMAP surface term of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6dd8b1795f73e191aebb733e481c2f64" name="a6dd8b1795f73e191aebb733e481c2f64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dd8b1795f73e191aebb733e481c2f64">&#9670;&#160;</a></span>getCmapAffectors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; stormm::synthesis::ValenceDelegator::getCmapAffectors </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>atom_indices</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of CMAP terms affecting a given list of atoms. The result is returned (pruned for unique items) as a series of term indices referencing the original topology. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">atom_indices</td><td>Topological indices of the atoms of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae741fc489879da798af22b2783923dde" name="ae741fc489879da798af22b2783923dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae741fc489879da798af22b2783923dde">&#9670;&#160;</a></span>getConstraintGroupAffectors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; stormm::synthesis::ValenceDelegator::getConstraintGroupAffectors </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>atom_indices</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of hub-and-spoke constraint groups affecting a given list of atoms. The result is returned (pruned for unique items) as a series of term indices referencing the original topology. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">atom_indices</td><td>Topological indices of the atoms of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac92b810643ebb10081dba687cbac3c2e" name="ac92b810643ebb10081dba687cbac3c2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac92b810643ebb10081dba687cbac3c2e">&#9670;&#160;</a></span>getDihedralAccumulatorWorkUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stormm::synthesis::ValenceDelegator::getDihedralAccumulatorWorkUnit </td>
          <td>(</td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>dihe_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the work unit currently assigned to contribute a particular cosine-based dihedral term's energy into the global accumulator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dihe_index</td><td>Topological index of the cosine-based dihedral term of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc014a10e5efaa3e18af11576c58d0e7" name="afc014a10e5efaa3e18af11576c58d0e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc014a10e5efaa3e18af11576c58d0e7">&#9670;&#160;</a></span>getDihedralAffectors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; stormm::synthesis::ValenceDelegator::getDihedralAffectors </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>atom_indices</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of cosine-based dihedrals affecting a given list of atoms. The result is returned (pruned for unique items) as a series of term indices referencing the original topology. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">atom_indices</td><td>Topological indices of the atoms of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3433f7635132ae59b1f510094729f63d" name="a3433f7635132ae59b1f510094729f63d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3433f7635132ae59b1f510094729f63d">&#9670;&#160;</a></span>getDihedralRestraintAccumulatorWorkUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stormm::synthesis::ValenceDelegator::getDihedralRestraintAccumulatorWorkUnit </td>
          <td>(</td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>rdihe_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the work unit currently assigned to contribute a particular four-point dihedral restraint penalty energy into the global accumulator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rdihe_index</td><td>Index of the four-point dihedral restraint in the restraint apparatus </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b5359077fc99a0091212bd2fbecc49a" name="a0b5359077fc99a0091212bd2fbecc49a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b5359077fc99a0091212bd2fbecc49a">&#9670;&#160;</a></span>getDihedralRestraintAffectors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; stormm::synthesis::ValenceDelegator::getDihedralRestraintAffectors </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>atom_indices</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of four-point dihedral angle restraints affecting a given list of atoms. The result is returned (pruned for unique items) as a series of term indices referencing the original topology. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">atom_indices</td><td>Topological indices of the atoms of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7a267ce6eea0bac4fc87fad52a35e1c" name="ac7a267ce6eea0bac4fc87fad52a35e1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a267ce6eea0bac4fc87fad52a35e1c">&#9670;&#160;</a></span>getDistanceRestraintAccumulatorWorkUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stormm::synthesis::ValenceDelegator::getDistanceRestraintAccumulatorWorkUnit </td>
          <td>(</td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>rbond_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the work unit currently assigned to contribute a particular distance restraint penalty energy into the global accumulator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rbond_index</td><td>Index of the distance restraint in the restraint apparatus </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63cd20a852640dcffdfcc3c0d098343c" name="a63cd20a852640dcffdfcc3c0d098343c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63cd20a852640dcffdfcc3c0d098343c">&#9670;&#160;</a></span>getDistanceRestraintAffectors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; stormm::synthesis::ValenceDelegator::getDistanceRestraintAffectors </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>atom_indices</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of distance restraints affecting a given list of atoms. The result is returned (pruned for unique items) as a series of term indices referencing the original topology. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">atom_indices</td><td>Topological indices of the atoms of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a227d5303c0ce2fb4b9b2f0ea43573634" name="a227d5303c0ce2fb4b9b2f0ea43573634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a227d5303c0ce2fb4b9b2f0ea43573634">&#9670;&#160;</a></span>getInferred14AccumulatorWorkUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stormm::synthesis::ValenceDelegator::getInferred14AccumulatorWorkUnit </td>
          <td>(</td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>infr14_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the work unit currently assigned to contribute a particular inferred 1:4 attenuated pair interaction energy into the global accumulator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">infr14_index</td><td>Topological index of the inferred 1:4 interaction of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a310446e207e31011ea662b970e08702b" name="a310446e207e31011ea662b970e08702b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a310446e207e31011ea662b970e08702b">&#9670;&#160;</a></span>getInferred14Affectors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; stormm::synthesis::ValenceDelegator::getInferred14Affectors </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>atom_indices</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of inferred 1:4 attenuated non-bonded interactions affecting a given list of atoms. The result is returned (pruned for unique items) as a series of term indices referencing the original topology. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">atom_indices</td><td>Topological indices of the atoms of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5141aa1603805492e32bc82b5692fbb" name="ab5141aa1603805492e32bc82b5692fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5141aa1603805492e32bc82b5692fbb">&#9670;&#160;</a></span>getPositionalRestraintAccumulatorWorkUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stormm::synthesis::ValenceDelegator::getPositionalRestraintAccumulatorWorkUnit </td>
          <td>(</td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>rposn_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the work unit currently assigned to contribute a particular positional restraint penalty energy into the global accumulator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rposn_index</td><td>Index of the positional restraint in the restraint apparatus </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a116faed2aaeebb74fc9667f941139934" name="a116faed2aaeebb74fc9667f941139934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a116faed2aaeebb74fc9667f941139934">&#9670;&#160;</a></span>getPositionalRestraintAffectors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; stormm::synthesis::ValenceDelegator::getPositionalRestraintAffectors </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>atom_indices</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of positional restraints affecting a given list of atoms. The result is returned (pruned for unique items) as a series of term indices referencing the original topology. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">atom_indices</td><td>Topological indices of the atoms of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf55a94d7cd6319d2b761de3ce7692ff" name="acf55a94d7cd6319d2b761de3ce7692ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf55a94d7cd6319d2b761de3ce7692ff">&#9670;&#160;</a></span>getSettleGroupAffectors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; stormm::synthesis::ValenceDelegator::getSettleGroupAffectors </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>atom_indices</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of SETTLE (fast, rigid water) constraint groups affecting a given list of atoms. The result is returned (pruned for unique items) as a series of term indices referencing the original topology. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">atom_indices</td><td>Topological indices of the atoms of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0fc2bb87b5cc028a0e7317fb0423624b" name="a0fc2bb87b5cc028a0e7317fb0423624b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fc2bb87b5cc028a0e7317fb0423624b">&#9670;&#160;</a></span>getUpdateDependencies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; stormm::synthesis::ValenceDelegator::getUpdateDependencies </td>
          <td>(</td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>atom_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accumulate a list of all atoms which have bearing on the way that a particular atom shall move. This routine will loop over the ValenceDelgator's bounded arrays for valence terms, restraints, virtual sites, and various constraint groups to determine any other atoms that must move, and any atoms which can contribute forces. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">atom_index</td><td>Topological index of the atom in question </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5fd456e8e3c6d993ac3635bf32f0da47" name="a5fd456e8e3c6d993ac3635bf32f0da47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fd456e8e3c6d993ac3635bf32f0da47">&#9670;&#160;</a></span>getUpdateWorkUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stormm::synthesis::ValenceDelegator::getUpdateWorkUnit </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>atom_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the work unit currently assigned to update an atom's position and velocity. The value of -1 signifies that no work unit has yet been assigned to handle the atom. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">atom_index</td><td>Topological index of the atom of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c277b9396de6c782a5ce837ba43b839" name="a4c277b9396de6c782a5ce837ba43b839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c277b9396de6c782a5ce837ba43b839">&#9670;&#160;</a></span>getUreyBradleyAccumulatorWorkUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stormm::synthesis::ValenceDelegator::getUreyBradleyAccumulatorWorkUnit </td>
          <td>(</td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>ubrd_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the work unit currently assigned to contribute a particular Urey-Bradley term's energy into the global accumulator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ubrd_index</td><td>Topological index of the Urey-Bradley term of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a8c0cedfd3aa17afe09117dcf064aea" name="a8a8c0cedfd3aa17afe09117dcf064aea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a8c0cedfd3aa17afe09117dcf064aea">&#9670;&#160;</a></span>getUreyBradleyAffectors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; stormm::synthesis::ValenceDelegator::getUreyBradleyAffectors </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>atom_indices</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of Urey-Bradley harmonic angles affecting a given list of atoms. The result is returned (pruned for unique items) as a series of term indices referencing the original topology. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">atom_indices</td><td>Topological indices of the atoms of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8bcc0a67d2524ffecab7584c57595d57" name="a8bcc0a67d2524ffecab7584c57595d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bcc0a67d2524ffecab7584c57595d57">&#9670;&#160;</a></span>getVirtualSiteAffectors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; stormm::synthesis::ValenceDelegator::getVirtualSiteAffectors </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>atom_indices</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of virtual site frames affecting a given list of atoms. The result is returned (pruned for unique items) as a series of term indices referencing the original topology. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">atom_indices</td><td>Topological indices of the atoms of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f4d0cbd9ba7b0dd8e8744eb774c0f97" name="a3f4d0cbd9ba7b0dd8e8744eb774c0f97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f4d0cbd9ba7b0dd8e8744eb774c0f97">&#9670;&#160;</a></span>markAtomAddition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::synthesis::ValenceDelegator::markAtomAddition </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>vwu_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>atom_index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the addition of an atom to a specific <a class="el" href="classstormm_1_1synthesis_1_1ValenceWorkUnit.html" title="An object to collect the components of a valence work unit (which will also track frozen atoms to imp...">ValenceWorkUnit</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vwu_index</td><td>Index of the <a class="el" href="classstormm_1_1synthesis_1_1ValenceWorkUnit.html" title="An object to collect the components of a valence work unit (which will also track frozen atoms to imp...">ValenceWorkUnit</a> receiving the new atom </td></tr>
    <tr><td class="paramname">atom_index</td><td>Index of the atom to add, referencing the original topology </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a54d91fd42daddc70041c2f95acf760ec" name="a54d91fd42daddc70041c2f95acf760ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54d91fd42daddc70041c2f95acf760ec">&#9670;&#160;</a></span>setAngleAccumulatorWorkUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stormm::synthesis::ValenceDelegator::setAngleAccumulatorWorkUnit </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>angl_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>vwu_index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the work unit that will accumulate the potential due to a specific harmonic angle interaction. Returns TRUE if the assignment is successful, FALSE if the assignment has already been made to some other work unit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angl_index</td><td>The topological index of the harmonic angle term of interest </td></tr>
    <tr><td class="paramname">vwu_index</td><td>Index of the <a class="el" href="classstormm_1_1synthesis_1_1ValenceWorkUnit.html" title="An object to collect the components of a valence work unit (which will also track frozen atoms to imp...">ValenceWorkUnit</a> in a list that this delegator is managing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a08395e2a8331330c61b432ecd482e3d5" name="a08395e2a8331330c61b432ecd482e3d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08395e2a8331330c61b432ecd482e3d5">&#9670;&#160;</a></span>setAngleRestraintAccumulatorWorkUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stormm::synthesis::ValenceDelegator::setAngleRestraintAccumulatorWorkUnit </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rangl_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>vwu_index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the work unit that will accumulate the potential due to a three-point angle restraint. Returns TRUE if the assignment is successful, FALSE if the assignment has already been made to some other work unit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rangl_index</td><td>The restraint apparatus index of the restraint of interest </td></tr>
    <tr><td class="paramname">vwu_index</td><td>Index of the <a class="el" href="classstormm_1_1synthesis_1_1ValenceWorkUnit.html" title="An object to collect the components of a valence work unit (which will also track frozen atoms to imp...">ValenceWorkUnit</a> in a list that this delegator is managing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab0c6d54d32a2aa228f51fdf42d28fc65" name="ab0c6d54d32a2aa228f51fdf42d28fc65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0c6d54d32a2aa228f51fdf42d28fc65">&#9670;&#160;</a></span>setBondAccumulatorWorkUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stormm::synthesis::ValenceDelegator::setBondAccumulatorWorkUnit </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>bond_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>vwu_index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the work unit that will accumulate the potential due to a specific bond interaction. Returns TRUE if the assignment is successful, FALSE if the assignment has already been made to some other work unit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bond_index</td><td>The topological index of the bond term of interest </td></tr>
    <tr><td class="paramname">vwu_index</td><td>Index of the <a class="el" href="classstormm_1_1synthesis_1_1ValenceWorkUnit.html" title="An object to collect the components of a valence work unit (which will also track frozen atoms to imp...">ValenceWorkUnit</a> in a list that this delegator is managing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e84ef586e8db6f2b691064d1ce31cb3" name="a7e84ef586e8db6f2b691064d1ce31cb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e84ef586e8db6f2b691064d1ce31cb3">&#9670;&#160;</a></span>setCharmmImproperAccumulatorWorkUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stormm::synthesis::ValenceDelegator::setCharmmImproperAccumulatorWorkUnit </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>cimp_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>vwu_index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the work unit that will accumulate the potential due to a specific CHARMM improper dihedral interaction. Returns TRUE if the assignment is successful, FALSE if the assignment has already been made to some other work unit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cimp_index</td><td>The topological index of the CHARMM improper dihedral term of interest </td></tr>
    <tr><td class="paramname">vwu_index</td><td>Index of the <a class="el" href="classstormm_1_1synthesis_1_1ValenceWorkUnit.html" title="An object to collect the components of a valence work unit (which will also track frozen atoms to imp...">ValenceWorkUnit</a> in a list that this delegator is managing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6dcb19c17f8fb2d82346c2c284000845" name="a6dcb19c17f8fb2d82346c2c284000845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dcb19c17f8fb2d82346c2c284000845">&#9670;&#160;</a></span>setCmapAccumulatorWorkUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stormm::synthesis::ValenceDelegator::setCmapAccumulatorWorkUnit </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>cmap_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>vwu_index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the work unit that will accumulate the potential due to a specific CMAP splined surface interaction. Returns TRUE if the assignment is successful, FALSE if the assignment has already been made to some other work unit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmap_index</td><td>The topological index of the CMAP term of interest </td></tr>
    <tr><td class="paramname">vwu_index</td><td>Index of the <a class="el" href="classstormm_1_1synthesis_1_1ValenceWorkUnit.html" title="An object to collect the components of a valence work unit (which will also track frozen atoms to imp...">ValenceWorkUnit</a> in a list that this delegator is managing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6483a840da7b3225908b2b902c2edf83" name="a6483a840da7b3225908b2b902c2edf83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6483a840da7b3225908b2b902c2edf83">&#9670;&#160;</a></span>setDihedralAccumulatorWorkUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stormm::synthesis::ValenceDelegator::setDihedralAccumulatorWorkUnit </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dihe_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>vwu_index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the work unit that will accumulate the potential due to a specific cosine-based dihedral interaction. Returns TRUE if the assignment is successful, FALSE if the assignment has already been made to some other work unit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dihe_index</td><td>The topological index of the dihedral term of interest </td></tr>
    <tr><td class="paramname">vwu_index</td><td>Index of the <a class="el" href="classstormm_1_1synthesis_1_1ValenceWorkUnit.html" title="An object to collect the components of a valence work unit (which will also track frozen atoms to imp...">ValenceWorkUnit</a> in a list that this delegator is managing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a405e1e15813b4dfb4ba474f474dd9966" name="a405e1e15813b4dfb4ba474f474dd9966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a405e1e15813b4dfb4ba474f474dd9966">&#9670;&#160;</a></span>setDihedralRestraintAccumulatorWorkUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stormm::synthesis::ValenceDelegator::setDihedralRestraintAccumulatorWorkUnit </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rdihe_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>vwu_index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the work unit that will accumulate the potential due to a four-point dihedral restraint. Returns TRUE if the assignment is successful, FALSE if the assignment has already been made to some other work unit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rdihe_index</td><td>The restraint apparatus index of the restraint of interest </td></tr>
    <tr><td class="paramname">vwu_index</td><td>Index of the <a class="el" href="classstormm_1_1synthesis_1_1ValenceWorkUnit.html" title="An object to collect the components of a valence work unit (which will also track frozen atoms to imp...">ValenceWorkUnit</a> in a list that this delegator is managing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade0cd3e24df66757b5d3d13a664cbe6e" name="ade0cd3e24df66757b5d3d13a664cbe6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade0cd3e24df66757b5d3d13a664cbe6e">&#9670;&#160;</a></span>setDistanceRestraintAccumulatorWorkUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stormm::synthesis::ValenceDelegator::setDistanceRestraintAccumulatorWorkUnit </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rbond_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>vwu_index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the work unit that will accumulate the potential due to a distance restraint. Returns TRUE if the assignment is successful, FALSE if the assignment has already been made to some other work unit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rbond_index</td><td>The restraint apparatus index of the restraint of interest </td></tr>
    <tr><td class="paramname">vwu_index</td><td>Index of the <a class="el" href="classstormm_1_1synthesis_1_1ValenceWorkUnit.html" title="An object to collect the components of a valence work unit (which will also track frozen atoms to imp...">ValenceWorkUnit</a> in a list that this delegator is managing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ab84b8090c7fd526d18a5760cd7ad94" name="a6ab84b8090c7fd526d18a5760cd7ad94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ab84b8090c7fd526d18a5760cd7ad94">&#9670;&#160;</a></span>setInferred14AccumulatorWorkUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stormm::synthesis::ValenceDelegator::setInferred14AccumulatorWorkUnit </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>infr14_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>vwu_index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the work unit that will accumulate the potential due to a specific inferred 1:4 non-bonded, attenuated interaction. Returns TRUE if the assignment is successful, FALSE if the assignment has already been made to some other work unit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">infr14_index</td><td>The topological index of the CMAP term of interest </td></tr>
    <tr><td class="paramname">vwu_index</td><td>Index of the <a class="el" href="classstormm_1_1synthesis_1_1ValenceWorkUnit.html" title="An object to collect the components of a valence work unit (which will also track frozen atoms to imp...">ValenceWorkUnit</a> in a list that this delegator is managing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2deeec38aa704edd3ea29ae7e304016b" name="a2deeec38aa704edd3ea29ae7e304016b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2deeec38aa704edd3ea29ae7e304016b">&#9670;&#160;</a></span>setPositionalRestraintAccumulatorWorkUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stormm::synthesis::ValenceDelegator::setPositionalRestraintAccumulatorWorkUnit </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rposn_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>vwu_index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the work unit that will accumulate the potential due to a positional restraint. Returns TRUE if the assignment is successful, FALSE if the assignment has already been made to some other work unit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rposn_index</td><td>The restraint apparatus index of the restraint of interest </td></tr>
    <tr><td class="paramname">vwu_index</td><td>Index of the <a class="el" href="classstormm_1_1synthesis_1_1ValenceWorkUnit.html" title="An object to collect the components of a valence work unit (which will also track frozen atoms to imp...">ValenceWorkUnit</a> in a list that this delegator is managing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88da529952b4f04afcad928851838c0d" name="a88da529952b4f04afcad928851838c0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88da529952b4f04afcad928851838c0d">&#9670;&#160;</a></span>setUpdateWorkUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stormm::synthesis::ValenceDelegator::setUpdateWorkUnit </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>atom_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>vwu_index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the updates (position, velocity) of a particular atom in the topology as the responsibility of a particular work unit in the list. Returns TRUE if the assignment is successful, or FALSE if the assignment has already been made to some work unit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">atom_index</td><td>The topological index of the atom of interest </td></tr>
    <tr><td class="paramname">vwu_index</td><td>Index of the <a class="el" href="classstormm_1_1synthesis_1_1ValenceWorkUnit.html" title="An object to collect the components of a valence work unit (which will also track frozen atoms to imp...">ValenceWorkUnit</a> in a list that this delegator is managing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7aac39d9b47b4533789cdbfabedf8f22" name="a7aac39d9b47b4533789cdbfabedf8f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aac39d9b47b4533789cdbfabedf8f22">&#9670;&#160;</a></span>setUreyBradleyAccumulatorWorkUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stormm::synthesis::ValenceDelegator::setUreyBradleyAccumulatorWorkUnit </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ubrd_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>vwu_index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the work unit that will accumulate the potential due to a specific Urey-Bradley interaction. Returns TRUE if the assignment is successful, FALSE if the assignment has already been made to some other work unit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ubrd_index</td><td>The topological index of the Urey-Bradley term of interest </td></tr>
    <tr><td class="paramname">vwu_index</td><td>Index of the <a class="el" href="classstormm_1_1synthesis_1_1ValenceWorkUnit.html" title="An object to collect the components of a valence work unit (which will also track frozen atoms to imp...">ValenceWorkUnit</a> in a list that this delegator is managing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/Synthesis/<a class="el" href="valence__workunit_8h_source.html">valence_workunit.h</a></li>
<li>src/Synthesis/<b>valence_workunit.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2
</small></address>
</div><!-- doc-content -->
</body>
</html>
