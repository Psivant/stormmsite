<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>STORMM Source Documentation: stormm::diskutil::TextFile Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">STORMM Source Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>stormm</b></li><li class="navelem"><b>diskutil</b></li><li class="navelem"><a class="el" href="classstormm_1_1diskutil_1_1TextFile.html">TextFile</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classstormm_1_1diskutil_1_1TextFile-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">stormm::diskutil::TextFile Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Structure for translating a text file into a compact, rapidly parsable vector of characters in CPU RAM. The struct contains two nested struct definitions, for a Reader and a Writer. Private objects of these structs can then be accessed with eponymous <a class="el" href="classstormm_1_1parse_1_1TextFile.html#aaa6a09d9b14ad8c2d19b1102e8e1ecfd" title="Get an abstract of a text file&#39;s CPU-RAM representation, for ease of use.">data()</a> getter functions, returning the appropriate kind of access depending on the const-ness of the <a class="el" href="classstormm_1_1diskutil_1_1TextFile.html" title="Structure for translating a text file into a compact, rapidly parsable vector of characters in CPU RA...">TextFile</a> object itself.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="textfile_8h_source.html">textfile.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a807c601eca0598997fc814c39ed6acc2" id="r_a807c601eca0598997fc814c39ed6acc2"><td class="memItemLeft" align="right" valign="top"><a id="a807c601eca0598997fc814c39ed6acc2" name="a807c601eca0598997fc814c39ed6acc2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~TextFile</b> ()=default</td></tr>
<tr class="memdesc:a807c601eca0598997fc814c39ed6acc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor. <br /></td></tr>
<tr class="separator:a807c601eca0598997fc814c39ed6acc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221aaa09496c7e149044105a8e2ddea7" id="r_a221aaa09496c7e149044105a8e2ddea7"><td class="memItemLeft" align="right" valign="top"><a id="a221aaa09496c7e149044105a8e2ddea7" name="a221aaa09496c7e149044105a8e2ddea7"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getFileName</b> () const</td></tr>
<tr class="memdesc:a221aaa09496c7e149044105a8e2ddea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the original file. <br /></td></tr>
<tr class="separator:a221aaa09496c7e149044105a8e2ddea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42460bad76c40601663bfb15bf66e423" id="r_a42460bad76c40601663bfb15bf66e423"><td class="memItemLeft" align="right" valign="top"><a id="a42460bad76c40601663bfb15bf66e423" name="a42460bad76c40601663bfb15bf66e423"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getLineCount</b> () const</td></tr>
<tr class="memdesc:a42460bad76c40601663bfb15bf66e423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the line count of a text file after converting it to a character vector in memory. <br /></td></tr>
<tr class="separator:a42460bad76c40601663bfb15bf66e423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb2a68212ed2c0ee272c0e30ff36dbf" id="r_a8eb2a68212ed2c0ee272c0e30ff36dbf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8eb2a68212ed2c0ee272c0e30ff36dbf">getLineLimits</a> (int index) const</td></tr>
<tr class="memdesc:a8eb2a68212ed2c0ee272c0e30ff36dbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get one of the line limits of a text file converted to a character vector in memory.  <br /></td></tr>
<tr class="separator:a8eb2a68212ed2c0ee272c0e30ff36dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83ee3bc89ee0fff9973da8cae97d96fe" id="r_a83ee3bc89ee0fff9973da8cae97d96fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83ee3bc89ee0fff9973da8cae97d96fe">getLineLength</a> (int index) const</td></tr>
<tr class="memdesc:a83ee3bc89ee0fff9973da8cae97d96fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of a line. A bounds check will be applied to the line index number.  <br /></td></tr>
<tr class="separator:a83ee3bc89ee0fff9973da8cae97d96fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1640655d7f2baaa62a4c0e34f484d08" id="r_ae1640655d7f2baaa62a4c0e34f484d08"><td class="memItemLeft" align="right" valign="top"><a id="ae1640655d7f2baaa62a4c0e34f484d08" name="ae1640655d7f2baaa62a4c0e34f484d08"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getLongestLineLength</b> () const</td></tr>
<tr class="memdesc:ae1640655d7f2baaa62a4c0e34f484d08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of the longest line in the file. <br /></td></tr>
<tr class="separator:ae1640655d7f2baaa62a4c0e34f484d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead49e277cf6920f944b3015b666da54" id="r_aead49e277cf6920f944b3015b666da54"><td class="memItemLeft" align="right" valign="top"><a id="aead49e277cf6920f944b3015b666da54" name="aead49e277cf6920f944b3015b666da54"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>getTextSize</b> () const</td></tr>
<tr class="memdesc:aead49e277cf6920f944b3015b666da54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of text characters in the object's buffer (this will not count implicit carriage returns between lines). <br /></td></tr>
<tr class="separator:aead49e277cf6920f944b3015b666da54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187ab3370c0a4d698364038b94c86a8b" id="r_a187ab3370c0a4d698364038b94c86a8b"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a187ab3370c0a4d698364038b94c86a8b">getChar</a> (int index) const</td></tr>
<tr class="memdesc:a187ab3370c0a4d698364038b94c86a8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get one character of a text file after converting it to a character vector in memory.  <br /></td></tr>
<tr class="separator:a187ab3370c0a4d698364038b94c86a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16459f198d56de3c23240f5a54ac98f7" id="r_a16459f198d56de3c23240f5a54ac98f7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16459f198d56de3c23240f5a54ac98f7">getLineAsString</a> (int line_index) const</td></tr>
<tr class="memdesc:a16459f198d56de3c23240f5a54ac98f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a line from the file as a string.  <br /></td></tr>
<tr class="separator:a16459f198d56de3c23240f5a54ac98f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa351eb0a36cfb3ac14f862b1c78194e0" id="r_aa351eb0a36cfb3ac14f862b1c78194e0"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa351eb0a36cfb3ac14f862b1c78194e0">getTextPointer</a> (int index) const</td></tr>
<tr class="memdesc:aa351eb0a36cfb3ac14f862b1c78194e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a char pointer to a specific index in the object.  <br /></td></tr>
<tr class="separator:aa351eb0a36cfb3ac14f862b1c78194e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb60a24d63d128036623a9842399857" id="r_a6eb60a24d63d128036623a9842399857"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6eb60a24d63d128036623a9842399857">getLinePointer</a> (int line_index) const</td></tr>
<tr class="memdesc:a6eb60a24d63d128036623a9842399857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a char pointer to a specific line in the object.  <br /></td></tr>
<tr class="separator:a6eb60a24d63d128036623a9842399857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa6a09d9b14ad8c2d19b1102e8e1ecfd" id="r_aaa6a09d9b14ad8c2d19b1102e8e1ecfd"><td class="memItemLeft" align="right" valign="top"><a id="aaa6a09d9b14ad8c2d19b1102e8e1ecfd" name="aaa6a09d9b14ad8c2d19b1102e8e1ecfd"></a>
const <a class="el" href="structstormm_1_1parse_1_1TextFileReader.html">TextFileReader</a>&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> () const</td></tr>
<tr class="memdesc:aaa6a09d9b14ad8c2d19b1102e8e1ecfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an abstract of a text file's CPU-RAM representation, for ease of use. <br /></td></tr>
<tr class="separator:aaa6a09d9b14ad8c2d19b1102e8e1ecfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4654bf08837d4f80b26c4777d80f3158" id="r_a4654bf08837d4f80b26c4777d80f3158"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4654bf08837d4f80b26c4777d80f3158">extractString</a> (int line_number, int start_pos=0, int string_length=-1) const</td></tr>
<tr class="memdesc:a4654bf08837d4f80b26c4777d80f3158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a string based on a line number, starting position, and length.  <br /></td></tr>
<tr class="separator:a4654bf08837d4f80b26c4777d80f3158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a758d971db3c9db42ebb87fd7a44b4d6f" id="r_a758d971db3c9db42ebb87fd7a44b4d6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstormm_1_1data__types_1_1char4.html">char4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a758d971db3c9db42ebb87fd7a44b4d6f">extractChar4</a> (int line_number, int start_pos, int string_length) const</td></tr>
<tr class="memdesc:a758d971db3c9db42ebb87fd7a44b4d6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a <a class="el" href="structstormm_1_1char4.html">char4</a> tuple based on a line number, starting position, and length.  <br /></td></tr>
<tr class="separator:a758d971db3c9db42ebb87fd7a44b4d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac46abea5053d9bdbfaddf92eedc1c54" id="r_aac46abea5053d9bdbfaddf92eedc1c54"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac46abea5053d9bdbfaddf92eedc1c54">toString</a> (TextEnds line_endings=TextEnds::NEWLINE) const</td></tr>
<tr class="memdesc:aac46abea5053d9bdbfaddf92eedc1c54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert all content to a string, with the option of making line endings carriage returns or simple spaces (fused line endings, which could create combined words out of the last word on one line and the first word on another, are not accepted).  <br /></td></tr>
<tr class="separator:aac46abea5053d9bdbfaddf92eedc1c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af8023463abc19ba5c0e75f4b4216423f" id="r_af8023463abc19ba5c0e75f4b4216423f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af8023463abc19ba5c0e75f4b4216423f">TextFile</a> ()</td></tr>
<tr class="memdesc:af8023463abc19ba5c0e75f4b4216423f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for taking an ascii file or a very long, formatted string and transforming it into a std::vector of characters with line limits recorded.  <br /></td></tr>
<tr class="separator:af8023463abc19ba5c0e75f4b4216423f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9889855145a94be7f6327b94d11ac90" id="r_aa9889855145a94be7f6327b94d11ac90"><td class="memItemLeft" align="right" valign="top"><a id="aa9889855145a94be7f6327b94d11ac90" name="aa9889855145a94be7f6327b94d11ac90"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TextFile</b> (const std::string &amp;file_name, TextOrigin source=TextOrigin::DISK, const std::string &amp;content=std::string(&quot;&quot;), const std::string &amp;caller=std::string(&quot;&quot;))</td></tr>
<tr class="separator:aa9889855145a94be7f6327b94d11ac90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe2814ed66982836872dc2ed9eb5925" id="r_a4fe2814ed66982836872dc2ed9eb5925"><td class="memItemLeft" align="right" valign="top"><a id="a4fe2814ed66982836872dc2ed9eb5925" name="a4fe2814ed66982836872dc2ed9eb5925"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TextFile</b> (const char *content, const size_t length, const std::string &amp;caller=std::string(&quot;&quot;))</td></tr>
<tr class="separator:a4fe2814ed66982836872dc2ed9eb5925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa812e7e2af7c05ebed235a3714cb8c29" id="r_aa812e7e2af7c05ebed235a3714cb8c29"><td class="memItemLeft" align="right" valign="top"><a id="aa812e7e2af7c05ebed235a3714cb8c29" name="aa812e7e2af7c05ebed235a3714cb8c29"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TextFile</b> (const <a class="el" href="classstormm_1_1parse_1_1TextFile.html">TextFile</a> &amp;original)=default</td></tr>
<tr class="memdesc:aa812e7e2af7c05ebed235a3714cb8c29"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default copy and move constructors as well as assignment operators are acceptable. <br /></td></tr>
<tr class="separator:aa812e7e2af7c05ebed235a3714cb8c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac83ea1d454c1ab3b25842242c10146b2" id="r_ac83ea1d454c1ab3b25842242c10146b2"><td class="memItemLeft" align="right" valign="top"><a id="ac83ea1d454c1ab3b25842242c10146b2" name="ac83ea1d454c1ab3b25842242c10146b2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TextFile</b> (<a class="el" href="classstormm_1_1parse_1_1TextFile.html">TextFile</a> &amp;&amp;original)=default</td></tr>
<tr class="separator:ac83ea1d454c1ab3b25842242c10146b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2322c1a25c5a56f0b9108c8729a9c0" id="r_aab2322c1a25c5a56f0b9108c8729a9c0"><td class="memItemLeft" align="right" valign="top"><a id="aab2322c1a25c5a56f0b9108c8729a9c0" name="aab2322c1a25c5a56f0b9108c8729a9c0"></a>
<a class="el" href="classstormm_1_1parse_1_1TextFile.html">TextFile</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classstormm_1_1parse_1_1TextFile.html">TextFile</a> &amp;other)=default</td></tr>
<tr class="separator:aab2322c1a25c5a56f0b9108c8729a9c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0b23b1f0457dd62c07f99d3aa9e7f5" id="r_a9f0b23b1f0457dd62c07f99d3aa9e7f5"><td class="memItemLeft" align="right" valign="top"><a id="a9f0b23b1f0457dd62c07f99d3aa9e7f5" name="a9f0b23b1f0457dd62c07f99d3aa9e7f5"></a>
<a class="el" href="classstormm_1_1parse_1_1TextFile.html">TextFile</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classstormm_1_1parse_1_1TextFile.html">TextFile</a> &amp;&amp;other)=default</td></tr>
<tr class="separator:a9f0b23b1f0457dd62c07f99d3aa9e7f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a8c80f18ddb3364aeaa4de15ae373c61c" id="r_a8c80f18ddb3364aeaa4de15ae373c61c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c80f18ddb3364aeaa4de15ae373c61c">write</a> (std::ofstream *foutp) const</td></tr>
<tr class="memdesc:a8c80f18ddb3364aeaa4de15ae373c61c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the contents of the object to disk.  <br /></td></tr>
<tr class="separator:a8c80f18ddb3364aeaa4de15ae373c61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ed2c11b274f3742ce0e1fb6bec13cd" id="r_a22ed2c11b274f3742ce0e1fb6bec13cd"><td class="memItemLeft" align="right" valign="top"><a id="a22ed2c11b274f3742ce0e1fb6bec13cd" name="a22ed2c11b274f3742ce0e1fb6bec13cd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>write</b> (const std::string &amp;new_filename, PrintSituation expectation=PrintSituation::OPEN_NEW) const</td></tr>
<tr class="separator:a22ed2c11b274f3742ce0e1fb6bec13cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab926364045ba9ef058915ba70e0227ea" id="r_ab926364045ba9ef058915ba70e0227ea"><td class="memItemLeft" align="right" valign="top"><a id="ab926364045ba9ef058915ba70e0227ea" name="ab926364045ba9ef058915ba70e0227ea"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>write</b> (PrintSituation expectation=PrintSituation::OPEN_NEW) const</td></tr>
<tr class="separator:ab926364045ba9ef058915ba70e0227ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Structure for translating a text file into a compact, rapidly parsable vector of characters in CPU RAM. The struct contains two nested struct definitions, for a Reader and a Writer. Private objects of these structs can then be accessed with eponymous <a class="el" href="classstormm_1_1parse_1_1TextFile.html#aaa6a09d9b14ad8c2d19b1102e8e1ecfd" title="Get an abstract of a text file&#39;s CPU-RAM representation, for ease of use.">data()</a> getter functions, returning the appropriate kind of access depending on the const-ness of the <a class="el" href="classstormm_1_1diskutil_1_1TextFile.html" title="Structure for translating a text file into a compact, rapidly parsable vector of characters in CPU RA...">TextFile</a> object itself. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af8023463abc19ba5c0e75f4b4216423f" name="af8023463abc19ba5c0e75f4b4216423f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8023463abc19ba5c0e75f4b4216423f">&#9670;&#160;</a></span>TextFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">stormm::parse::TextFile::TextFile </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for taking an ascii file or a very long, formatted string and transforming it into a std::vector of characters with line limits recorded. </p>
<p>Overloaded:</p><ul>
<li>Construct an empty object after taking no arguments</li>
<li>Construct a complete object from a named file (throws an exception if the file does not exist)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_name</td><td>Name of the input file </td></tr>
    <tr><td class="paramname">source</td><td>Origin of the text&ndash;disk or RAM </td></tr>
    <tr><td class="paramname">content</td><td>Content for the <a class="el" href="classstormm_1_1diskutil_1_1TextFile.html" title="Structure for translating a text file into a compact, rapidly parsable vector of characters in CPU RA...">TextFile</a>, and perhaps later an ASCII text file, to hold </td></tr>
    <tr><td class="paramname">caller</td><td>(Optional) name of the calling function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a758d971db3c9db42ebb87fd7a44b4d6f" name="a758d971db3c9db42ebb87fd7a44b4d6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a758d971db3c9db42ebb87fd7a44b4d6f">&#9670;&#160;</a></span>extractChar4()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstormm_1_1data__types_1_1char4.html">char4</a> stormm::parse::TextFile::extractChar4 </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>line_number</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>start_pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>string_length</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract a <a class="el" href="structstormm_1_1char4.html">char4</a> tuple based on a line number, starting position, and length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">line_number</td><td>The line number where the text shall be found </td></tr>
    <tr><td class="paramname">start_pos</td><td>Starting position on the line to begin reading (defaults to the start of the line) </td></tr>
    <tr><td class="paramname">string_length</td><td>Length of the string to extract. The default value of 4 will try to read four characters, but shorter values will leave blank space at the end of the tuple. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4654bf08837d4f80b26c4777d80f3158" name="a4654bf08837d4f80b26c4777d80f3158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4654bf08837d4f80b26c4777d80f3158">&#9670;&#160;</a></span>extractString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string stormm::parse::TextFile::extractString </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>line_number</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>start_pos</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>string_length</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract a string based on a line number, starting position, and length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">line_number</td><td>The line number where the text shall be found </td></tr>
    <tr><td class="paramname">start_pos</td><td>Starting position on the line to begin reading (defaults to the start of the line) </td></tr>
    <tr><td class="paramname">string_length</td><td>Length of the string to extract. A value of -1 indicates that reading shall continue until the end of the line. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a187ab3370c0a4d698364038b94c86a8b" name="a187ab3370c0a4d698364038b94c86a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187ab3370c0a4d698364038b94c86a8b">&#9670;&#160;</a></span>getChar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char stormm::parse::TextFile::getChar </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get one character of a text file after converting it to a character vector in memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The character index, as ascertained by line limits and some offset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16459f198d56de3c23240f5a54ac98f7" name="a16459f198d56de3c23240f5a54ac98f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16459f198d56de3c23240f5a54ac98f7">&#9670;&#160;</a></span>getLineAsString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string stormm::parse::TextFile::getLineAsString </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>line_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a line from the file as a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">line_index</td><td>The line of interest, indexing starting from zero </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83ee3bc89ee0fff9973da8cae97d96fe" name="a83ee3bc89ee0fff9973da8cae97d96fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83ee3bc89ee0fff9973da8cae97d96fe">&#9670;&#160;</a></span>getLineLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stormm::parse::TextFile::getLineLength </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the length of a line. A bounds check will be applied to the line index number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The line index. The array of limits contains one more indices than the text file has lines, to allow the end of the last line to be determined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8eb2a68212ed2c0ee272c0e30ff36dbf" name="a8eb2a68212ed2c0ee272c0e30ff36dbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eb2a68212ed2c0ee272c0e30ff36dbf">&#9670;&#160;</a></span>getLineLimits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stormm::parse::TextFile::getLineLimits </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get one of the line limits of a text file converted to a character vector in memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The line index. The array of limits contains one more indices than the text file has lines, to allow the end of the last line to be determined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6eb60a24d63d128036623a9842399857" name="a6eb60a24d63d128036623a9842399857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eb60a24d63d128036623a9842399857">&#9670;&#160;</a></span>getLinePointer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * stormm::parse::TextFile::getLinePointer </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>line_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a char pointer to a specific line in the object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">line_index</td><td>The line of interest, indexing starting from zero </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa351eb0a36cfb3ac14f862b1c78194e0" name="aa351eb0a36cfb3ac14f862b1c78194e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa351eb0a36cfb3ac14f862b1c78194e0">&#9670;&#160;</a></span>getTextPointer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * stormm::parse::TextFile::getTextPointer </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a char pointer to a specific index in the object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The character index, as ascertained by line limits and some offset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac46abea5053d9bdbfaddf92eedc1c54" name="aac46abea5053d9bdbfaddf92eedc1c54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac46abea5053d9bdbfaddf92eedc1c54">&#9670;&#160;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string stormm::parse::TextFile::toString </td>
          <td>(</td>
          <td class="paramtype">TextEnds</td>          <td class="paramname"><span class="paramname"><em>line_endings</em></span><span class="paramdefsep"> = </span><span class="paramdefval">TextEnds::NEWLINE</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert all content to a string, with the option of making line endings carriage returns or simple spaces (fused line endings, which could create combined words out of the last word on one line and the first word on another, are not accepted). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">line_endings</td><td>Specify whether to insert newlines or white space between lines </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c80f18ddb3364aeaa4de15ae373c61c" name="a8c80f18ddb3364aeaa4de15ae373c61c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c80f18ddb3364aeaa4de15ae373c61c">&#9670;&#160;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::parse::TextFile::write </td>
          <td>(</td>
          <td class="paramtype">std::ofstream *</td>          <td class="paramname"><span class="paramname"><em>foutp</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the contents of the object to disk. </p>
<p>Overloaded:</p><ul>
<li>Supply an open file pointer</li>
<li>Supply a new file name, distinct from the original name stored in the object, and a file status expectation</li>
<li>Supply just a file status expectation and (overwrite, or perhaps append in some clever implementation) the original file</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">foutp</td><td>Open output stream </td></tr>
    <tr><td class="paramname">new_filename</td><td>Name of a distinct file to write </td></tr>
    <tr><td class="paramname">expectation</td><td>Expected state of the output file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/Parsing/<a class="el" href="textfile_8h_source.html">textfile.h</a></li>
<li>src/Parsing/<b>textfile.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2
</small></address>
</div><!-- doc-content -->
</body>
</html>
