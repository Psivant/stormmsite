<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>STORMM Source Documentation: stormm::structure::TricubicCell&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">STORMM Source Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>stormm</b></li><li class="navelem"><b>structure</b></li><li class="navelem"><a class="el" href="classstormm_1_1structure_1_1TricubicCell.html">TricubicCell</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classstormm_1_1structure_1_1TricubicCell-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">stormm::structure::TricubicCell&lt; T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>One element of a three-dimensional, space-filling tile representing a three-dimensional function to be interpolated by a tricubic spline.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="tricubic__cell_8h_source.html">tricubic_cell.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a28951ce7274a8dbf83b8a0a13459f023" id="r_a28951ce7274a8dbf83b8a0a13459f023"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28951ce7274a8dbf83b8a0a13459f023">getCoefficient</a> (int i, int j, int k) const</td></tr>
<tr class="memdesc:a28951ce7274a8dbf83b8a0a13459f023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve one of the 64 coefficients Aijk for the tricubic spline.  <br /></td></tr>
<tr class="separator:a28951ce7274a8dbf83b8a0a13459f023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3804b99fdf7cc07b5cb89eb33647a5d4" id="r_a3804b99fdf7cc07b5cb89eb33647a5d4"><td class="memItemLeft" align="right" valign="top"><a id="a3804b99fdf7cc07b5cb89eb33647a5d4" name="a3804b99fdf7cc07b5cb89eb33647a5d4"></a>
std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getCoefficients</b> () const</td></tr>
<tr class="memdesc:a3804b99fdf7cc07b5cb89eb33647a5d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a Standard Template Library vector containing all coefficients in the element. The order of coefficients is given in Fortran order: for the term Aijk x^i y^j z^k, the ith coefficient varies the most rapidly and the index for Aijk is given by (((k * 4) + j) * 4 + i. <br /></td></tr>
<tr class="separator:a3804b99fdf7cc07b5cb89eb33647a5d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188887cef3c8b609cad2a00071686f96" id="r_a188887cef3c8b609cad2a00071686f96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a188887cef3c8b609cad2a00071686f96">setCoefficient</a> (T value, int i, int j, int k)</td></tr>
<tr class="memdesc:a188887cef3c8b609cad2a00071686f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set one of the 64 coefficients Aijk for the tricubic spline. Parameter descriptions follow from above, with the addition of:  <br /></td></tr>
<tr class="separator:a188887cef3c8b609cad2a00071686f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa871fd1a1fdd9b2b8b28ea8408e63bb6" id="r_aa871fd1a1fdd9b2b8b28ea8408e63bb6"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa871fd1a1fdd9b2b8b28ea8408e63bb6">getData</a> (FunctionLevel kind, int i, int j, int k) const</td></tr>
<tr class="memdesc:aa871fd1a1fdd9b2b8b28ea8408e63bb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get one of the data points from the boundary. Parameter descriptions follow from above, with the addition of:  <br /></td></tr>
<tr class="separator:aa871fd1a1fdd9b2b8b28ea8408e63bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d36d3c615975a9ca270064a77bee1e" id="r_a66d36d3c615975a9ca270064a77bee1e"><td class="memItemLeft" align="right" valign="top"><a id="a66d36d3c615975a9ca270064a77bee1e" name="a66d36d3c615975a9ca270064a77bee1e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setData</b> (T value, FunctionLevel kind, int i, int j, int k)</td></tr>
<tr class="memdesc:a66d36d3c615975a9ca270064a77bee1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set one of the data items. Parameter descriptions follow from above. <br /></td></tr>
<tr class="separator:a66d36d3c615975a9ca270064a77bee1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842a5c65efffcba3c2f477b3ba962774" id="r_a842a5c65efffcba3c2f477b3ba962774"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a842a5c65efffcba3c2f477b3ba962774">getCellOrigin</a> (CartesianDimension dim) const</td></tr>
<tr class="memdesc:a842a5c65efffcba3c2f477b3ba962774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the cell origin along one dimension.  <br /></td></tr>
<tr class="separator:a842a5c65efffcba3c2f477b3ba962774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad759c4736a4d9de5eab8e433d35891d7" id="r_ad759c4736a4d9de5eab8e433d35891d7"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad759c4736a4d9de5eab8e433d35891d7">getCellLength</a> (CartesianDimension dim) const</td></tr>
<tr class="memdesc:ad759c4736a4d9de5eab8e433d35891d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the cell length along one dimension.  <br /></td></tr>
<tr class="separator:ad759c4736a4d9de5eab8e433d35891d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2bcf8a8e034e329ee8262ee1b967f6" id="r_a9d2bcf8a8e034e329ee8262ee1b967f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d2bcf8a8e034e329ee8262ee1b967f6">fractionalPosition</a> (T x, T y, T z, T *a_frac, T *b_frac, T *c_frac, ExceptionResponse policy=ExceptionResponse::SILENT, const char *caller=nullptr) const</td></tr>
<tr class="memdesc:a9d2bcf8a8e034e329ee8262ee1b967f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the fractional position of a point in Cartesian coordinates within a mesh cell. This includes a check on whether the point is actually within the mesh cell.  <br /></td></tr>
<tr class="separator:a9d2bcf8a8e034e329ee8262ee1b967f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab684b8f8e722841b20f5f4fcbd884782" id="r_ab684b8f8e722841b20f5f4fcbd884782"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab684b8f8e722841b20f5f4fcbd884782">evaluate</a> (T x, T y, T z) const</td></tr>
<tr class="memdesc:ab684b8f8e722841b20f5f4fcbd884782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the function at a specific point in space. This will take into account the grid cell's origin and lengths to determine where in the grid cell the point of interest lies. If the point is outside the grid cell, produce an error.  <br /></td></tr>
<tr class="separator:ab684b8f8e722841b20f5f4fcbd884782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bda52bbd1b5997c5fdde3f706ad2639" id="r_a2bda52bbd1b5997c5fdde3f706ad2639"><td class="memTemplParams" colspan="2"><a id="a2bda52bbd1b5997c5fdde3f706ad2639" name="a2bda52bbd1b5997c5fdde3f706ad2639"></a>
template&lt;typename T3&gt; </td></tr>
<tr class="memitem:a2bda52bbd1b5997c5fdde3f706ad2639"><td class="memTemplItemLeft" align="right" valign="top">T3&#160;</td><td class="memTemplItemRight" valign="bottom"><b>derivative</b> (T x, T y, T z) const</td></tr>
<tr class="memdesc:a2bda52bbd1b5997c5fdde3f706ad2639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the first derivatives of a tricubic mesh element at a point and return the results along Cartesian axes. Descriptions of input parameters follow from the <a class="el" href="classstormm_1_1stmath_1_1TricubicCell.html#ab684b8f8e722841b20f5f4fcbd884782" title="Evaluate the function at a specific point in space. This will take into account the grid cell&#39;s origi...">evaluate()</a> member function above. <br /></td></tr>
<tr class="separator:a2bda52bbd1b5997c5fdde3f706ad2639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9d8873b82c3dcf6aa34ad11bc690303f" id="r_a9d8873b82c3dcf6aa34ad11bc690303f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d8873b82c3dcf6aa34ad11bc690303f">TricubicCell</a> ()</td></tr>
<tr class="memdesc:a9d8873b82c3dcf6aa34ad11bc690303f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructor can take nothing and simply initialize all values to zero, or accept the tricubic weights matrix, a dimensions array, and details of the potential function.  <br /></td></tr>
<tr class="separator:a9d8873b82c3dcf6aa34ad11bc690303f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4da6ea2432be03b2b756c4603e6ab7f" id="r_af4da6ea2432be03b2b756c4603e6ab7f"><td class="memItemLeft" align="right" valign="top"><a id="af4da6ea2432be03b2b756c4603e6ab7f" name="af4da6ea2432be03b2b756c4603e6ab7f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TricubicCell</b> (const <a class="el" href="classstormm_1_1stmath_1_1TricubicStencil.html">TricubicStencil</a> weights_matrix, const std::vector&lt; double &gt; &amp;bounds, const std::vector&lt; T &gt; &amp;f_in, const std::vector&lt; T &gt; &amp;dx_in, const std::vector&lt; T &gt; &amp;dy_in, const std::vector&lt; T &gt; &amp;dz_in, const std::vector&lt; T &gt; &amp;dxx_in, const std::vector&lt; T &gt; &amp;dxy_in, const std::vector&lt; T &gt; &amp;dxz_in, const std::vector&lt; T &gt; &amp;dyy_in, const std::vector&lt; T &gt; &amp;dyz_in, const std::vector&lt; T &gt; &amp;dxxx_in, const std::vector&lt; T &gt; &amp;dxxy_in, const std::vector&lt; T &gt; &amp;dxxz_in, const std::vector&lt; T &gt; &amp;dxyy_in, const std::vector&lt; T &gt; &amp;dxyz_in)</td></tr>
<tr class="separator:af4da6ea2432be03b2b756c4603e6ab7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa35a6e35631b6d4af05f70e104e34fbe" id="r_aa35a6e35631b6d4af05f70e104e34fbe"><td class="memItemLeft" align="right" valign="top"><a id="aa35a6e35631b6d4af05f70e104e34fbe" name="aa35a6e35631b6d4af05f70e104e34fbe"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TricubicCell</b> (const <a class="el" href="classstormm_1_1stmath_1_1TricubicStencil.html">TricubicStencil</a> weights_matrix, const std::vector&lt; double &gt; &amp;bounds, const std::vector&lt; T &gt; &amp;f_in, const std::vector&lt; T &gt; &amp;dx_in, const std::vector&lt; T &gt; &amp;dy_in, const std::vector&lt; T &gt; &amp;dz_in, const std::vector&lt; T &gt; &amp;dxy_in, const std::vector&lt; T &gt; &amp;dxz_in, const std::vector&lt; T &gt; &amp;dyz_in, const std::vector&lt; T &gt; &amp;dxyz_in)</td></tr>
<tr class="separator:aa35a6e35631b6d4af05f70e104e34fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:acd898d9fc0818937521bd95becbc2b96" id="r_acd898d9fc0818937521bd95becbc2b96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd898d9fc0818937521bd95becbc2b96">secondDerivative</a> (T x, T y, T z, T *result) const</td></tr>
<tr class="memdesc:acd898d9fc0818937521bd95becbc2b96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the second derivatives of a tricubic mesh element at a point and return the results along Cartesian axes. Descriptions of input parameters follow from the <a class="el" href="classstormm_1_1stmath_1_1TricubicCell.html#ab684b8f8e722841b20f5f4fcbd884782" title="Evaluate the function at a specific point in space. This will take into account the grid cell&#39;s origi...">evaluate()</a> member function above, with the addition of:  <br /></td></tr>
<tr class="separator:acd898d9fc0818937521bd95becbc2b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3be6aba5a1dede6b3a40b345b6f52a0" id="r_aa3be6aba5a1dede6b3a40b345b6f52a0"><td class="memItemLeft" align="right" valign="top"><a id="aa3be6aba5a1dede6b3a40b345b6f52a0" name="aa3be6aba5a1dede6b3a40b345b6f52a0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>secondDerivative</b> (T x, T y, T z, std::vector&lt; T &gt; *result) const</td></tr>
<tr class="separator:aa3be6aba5a1dede6b3a40b345b6f52a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b8bf102e9d34c4c932ccbc91a341c45" id="r_a7b8bf102e9d34c4c932ccbc91a341c45"><td class="memItemLeft" align="right" valign="top"><a id="a7b8bf102e9d34c4c932ccbc91a341c45" name="a7b8bf102e9d34c4c932ccbc91a341c45"></a>
std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>secondDerivative</b> (T x, T y, T z) const</td></tr>
<tr class="separator:a7b8bf102e9d34c4c932ccbc91a341c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a19bd8633ba6d8a13f974e7e5f40c7d5d" id="r_a19bd8633ba6d8a13f974e7e5f40c7d5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19bd8633ba6d8a13f974e7e5f40c7d5d">thirdDerivative</a> (T x, T y, T z, T *result) const</td></tr>
<tr class="memdesc:a19bd8633ba6d8a13f974e7e5f40c7d5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the second derivatives of a tricubic mesh element at a point and return the results along Cartesian axes. Descriptions of input parameters follow from the <a class="el" href="classstormm_1_1stmath_1_1TricubicCell.html#ab684b8f8e722841b20f5f4fcbd884782" title="Evaluate the function at a specific point in space. This will take into account the grid cell&#39;s origi...">evaluate()</a> member function above, with the addition of:  <br /></td></tr>
<tr class="separator:a19bd8633ba6d8a13f974e7e5f40c7d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab987e034a4b859c7f4e45a10b96e30d8" id="r_ab987e034a4b859c7f4e45a10b96e30d8"><td class="memItemLeft" align="right" valign="top"><a id="ab987e034a4b859c7f4e45a10b96e30d8" name="ab987e034a4b859c7f4e45a10b96e30d8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>thirdDerivative</b> (T x, T y, T z, std::vector&lt; T &gt; *result) const</td></tr>
<tr class="separator:ab987e034a4b859c7f4e45a10b96e30d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e6b75f49b9ebc586b0cc0dbb13f400" id="r_a46e6b75f49b9ebc586b0cc0dbb13f400"><td class="memItemLeft" align="right" valign="top"><a id="a46e6b75f49b9ebc586b0cc0dbb13f400" name="a46e6b75f49b9ebc586b0cc0dbb13f400"></a>
std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>thirdDerivative</b> (T x, T y, T z) const</td></tr>
<tr class="separator:a46e6b75f49b9ebc586b0cc0dbb13f400"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T&gt;<br />
class stormm::structure::TricubicCell&lt; T &gt;</div><p>One element of a three-dimensional, space-filling tile representing a three-dimensional function to be interpolated by a tricubic spline. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9d8873b82c3dcf6aa34ad11bc690303f" name="a9d8873b82c3dcf6aa34ad11bc690303f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d8873b82c3dcf6aa34ad11bc690303f">&#9670;&#160;</a></span>TricubicCell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstormm_1_1stmath_1_1TricubicCell.html">stormm::stmath::TricubicCell</a>&lt; T &gt;::TricubicCell </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The constructor can take nothing and simply initialize all values to zero, or accept the tricubic weights matrix, a dimensions array, and details of the potential function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">weights_matrix</td><td>The inverse matrix of polynomial weights obtained from getTricubicMatrix() in this library </td></tr>
    <tr><td class="paramname">bounds</td><td>Array containing the Cartesian x, y, and z coordinates of the grid cell origin plus its lengths along each axis (the grid cell is NOT required to be orthorhombic). This array can have four entries (in which case the final entry is assumed to be the isotropic length parameter), six (for anisotropic cells), or twelve entries, in which case the last nine represent the column matrix of cell vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab684b8f8e722841b20f5f4fcbd884782" name="ab684b8f8e722841b20f5f4fcbd884782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab684b8f8e722841b20f5f4fcbd884782">&#9670;&#160;</a></span>evaluate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classstormm_1_1stmath_1_1TricubicCell.html">stormm::stmath::TricubicCell</a>&lt; T &gt;::evaluate </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>z</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the function at a specific point in space. This will take into account the grid cell's origin and lengths to determine where in the grid cell the point of interest lies. If the point is outside the grid cell, produce an error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Cartesian X location of the point </td></tr>
    <tr><td class="paramname">y</td><td>Cartesian Y location of the point </td></tr>
    <tr><td class="paramname">z</td><td>Cartesian Z location of the point </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d2bcf8a8e034e329ee8262ee1b967f6" name="a9d2bcf8a8e034e329ee8262ee1b967f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d2bcf8a8e034e329ee8262ee1b967f6">&#9670;&#160;</a></span>fractionalPosition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstormm_1_1stmath_1_1TricubicCell.html">stormm::stmath::TricubicCell</a>&lt; T &gt;::fractionalPosition </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>a_frac</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>b_frac</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>c_frac</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExceptionResponse</td>          <td class="paramname"><span class="paramname"><em>policy</em></span><span class="paramdefsep"> = </span><span class="paramdefval">ExceptionResponse::SILENT</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>caller</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the fractional position of a point in Cartesian coordinates within a mesh cell. This includes a check on whether the point is actually within the mesh cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Cartesian X coordinate </td></tr>
    <tr><td class="paramname">y</td><td>Cartesian Y coordinate </td></tr>
    <tr><td class="paramname">z</td><td>Cartesian Z coordinate </td></tr>
    <tr><td class="paramname">a_frac</td><td>Fractional coordinate along the mesh element's a axis, evaluated and returned </td></tr>
    <tr><td class="paramname">b_frac</td><td>Fractional coordinate along the mesh element's b axis, evaluated and returned </td></tr>
    <tr><td class="paramname">c_frac</td><td>Fractional coordinate along the mesh element's c axis, evaluated and returned </td></tr>
    <tr><td class="paramname">policy</td><td>Indicate the course of action if the point lies outside the mesh element </td></tr>
    <tr><td class="paramname">caller</td><td>Name of the calling function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad759c4736a4d9de5eab8e433d35891d7" name="ad759c4736a4d9de5eab8e433d35891d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad759c4736a4d9de5eab8e433d35891d7">&#9670;&#160;</a></span>getCellLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classstormm_1_1stmath_1_1TricubicCell.html">stormm::stmath::TricubicCell</a>&lt; T &gt;::getCellLength </td>
          <td>(</td>
          <td class="paramtype">CartesianDimension</td>          <td class="paramname"><span class="paramname"><em>dim</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the cell length along one dimension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>The Cartesian dimension along which to return the cell length </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a842a5c65efffcba3c2f477b3ba962774" name="a842a5c65efffcba3c2f477b3ba962774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a842a5c65efffcba3c2f477b3ba962774">&#9670;&#160;</a></span>getCellOrigin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classstormm_1_1stmath_1_1TricubicCell.html">stormm::stmath::TricubicCell</a>&lt; T &gt;::getCellOrigin </td>
          <td>(</td>
          <td class="paramtype">CartesianDimension</td>          <td class="paramname"><span class="paramname"><em>dim</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the cell origin along one dimension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>The Cartesian dimension along which to return the origin coordinate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28951ce7274a8dbf83b8a0a13459f023" name="a28951ce7274a8dbf83b8a0a13459f023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28951ce7274a8dbf83b8a0a13459f023">&#9670;&#160;</a></span>getCoefficient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classstormm_1_1stmath_1_1TricubicCell.html">stormm::stmath::TricubicCell</a>&lt; T &gt;::getCoefficient </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>j</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>k</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve one of the 64 coefficients Aijk for the tricubic spline. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The ith coefficient relevant to the notation Aijk </td></tr>
    <tr><td class="paramname">j</td><td>The jth coefficient relevant to the notation Aijk </td></tr>
    <tr><td class="paramname">k</td><td>The kth coefficient relevant to the notation Aijk </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa871fd1a1fdd9b2b8b28ea8408e63bb6" name="aa871fd1a1fdd9b2b8b28ea8408e63bb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa871fd1a1fdd9b2b8b28ea8408e63bb6">&#9670;&#160;</a></span>getData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classstormm_1_1stmath_1_1TricubicCell.html">stormm::stmath::TricubicCell</a>&lt; T &gt;::getData </td>
          <td>(</td>
          <td class="paramtype">FunctionLevel</td>          <td class="paramname"><span class="paramname"><em>kind</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>j</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>k</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get one of the data points from the boundary. Parameter descriptions follow from above, with the addition of: </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kind</td><td>The classification of the boundary condition as a derivative (or value) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd898d9fc0818937521bd95becbc2b96" name="acd898d9fc0818937521bd95becbc2b96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd898d9fc0818937521bd95becbc2b96">&#9670;&#160;</a></span>secondDerivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstormm_1_1stmath_1_1TricubicCell.html">stormm::stmath::TricubicCell</a>&lt; T &gt;::secondDerivative </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the second derivatives of a tricubic mesh element at a point and return the results along Cartesian axes. Descriptions of input parameters follow from the <a class="el" href="classstormm_1_1stmath_1_1TricubicCell.html#ab684b8f8e722841b20f5f4fcbd884782" title="Evaluate the function at a specific point in space. This will take into account the grid cell&#39;s origi...">evaluate()</a> member function above, with the addition of: </p>
<p>Overloaded:</p><ul>
<li>Use a pre-allocated space to hold the results (provided as a C-style array or Standard Template Library vector)</li>
<li>Produce a Standard Template Library vector holding the results (of trusted length 9)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>Pre-allocated space to hold the output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a188887cef3c8b609cad2a00071686f96" name="a188887cef3c8b609cad2a00071686f96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a188887cef3c8b609cad2a00071686f96">&#9670;&#160;</a></span>setCoefficient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstormm_1_1stmath_1_1TricubicCell.html">stormm::stmath::TricubicCell</a>&lt; T &gt;::setCoefficient </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>j</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>k</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set one of the 64 coefficients Aijk for the tricubic spline. Parameter descriptions follow from above, with the addition of: </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to apply </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a19bd8633ba6d8a13f974e7e5f40c7d5d" name="a19bd8633ba6d8a13f974e7e5f40c7d5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19bd8633ba6d8a13f974e7e5f40c7d5d">&#9670;&#160;</a></span>thirdDerivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstormm_1_1stmath_1_1TricubicCell.html">stormm::stmath::TricubicCell</a>&lt; T &gt;::thirdDerivative </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the second derivatives of a tricubic mesh element at a point and return the results along Cartesian axes. Descriptions of input parameters follow from the <a class="el" href="classstormm_1_1stmath_1_1TricubicCell.html#ab684b8f8e722841b20f5f4fcbd884782" title="Evaluate the function at a specific point in space. This will take into account the grid cell&#39;s origi...">evaluate()</a> member function above, with the addition of: </p>
<p>Overloaded:</p><ul>
<li>Use a pre-allocated space to hold the results (provided as a C-style array or Standard Template Library vector)</li>
<li>Produce a Standard Template Library vector holding the results (of trusted length 27)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>Pre-allocated space to hold the output tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/Math/<a class="el" href="tricubic__cell_8h_source.html">tricubic_cell.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2
</small></address>
</div><!-- doc-content -->
</body>
</html>
