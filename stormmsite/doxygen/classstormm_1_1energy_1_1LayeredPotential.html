<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>STORMM Source Documentation: stormm::energy::LayeredPotential&lt; T, T4 &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">STORMM Source Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>stormm</b></li><li class="navelem"><b>energy</b></li><li class="navelem"><a class="el" href="classstormm_1_1energy_1_1LayeredPotential.html">LayeredPotential</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classstormm_1_1energy_1_1LayeredPotential-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">stormm::energy::LayeredPotential&lt; T, T4 &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A long-ranged potential can be broken down into a series of successively smoother potentials applicable over longer and longer ranges. This object will manage a process whereby each potential and its first three derivatives decay exactly to zero at the specified boundary. The process generates some very complicated forms, particularly in the shortest-range potential where the effects assigned to all longer-ranged potentials must be subtracted off, but use of logarithmic adaptive splines can absorb the complexity.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="layered__potential_8h_source.html">layered_potential.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acfb992928d49536320feceba35bfb4bf" id="r_acfb992928d49536320feceba35bfb4bf"><td class="memItemLeft" align="right" valign="top"><a id="acfb992928d49536320feceba35bfb4bf" name="acfb992928d49536320feceba35bfb4bf"></a>
const <a class="el" href="classstormm_1_1energy_1_1LayeredPotentialMetrics.html">LayeredPotentialMetrics</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getParameters</b> () const</td></tr>
<tr class="memdesc:acfb992928d49536320feceba35bfb4bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reference to the underlying metrics, to view specifications such as the cutoff at a particular level, one of the exponential scaling factors, etc. All accessors in the nested class can then be utilized without copying the code. <br /></td></tr>
<tr class="separator:acfb992928d49536320feceba35bfb4bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad00d70c3b04eb0b8bb4a36342167b1c5" id="r_ad00d70c3b04eb0b8bb4a36342167b1c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstormm_1_1data__types_1_1double4.html">double4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad00d70c3b04eb0b8bb4a36342167b1c5">getSmoothingCoefficients</a> (int layer) const</td></tr>
<tr class="memdesc:ad00d70c3b04eb0b8bb4a36342167b1c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the quartet of coefficients for one of the layers.  <br /></td></tr>
<tr class="separator:ad00d70c3b04eb0b8bb4a36342167b1c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af62cf7fbc74954e12b582e483f379f95" id="r_af62cf7fbc74954e12b582e483f379f95"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af62cf7fbc74954e12b582e483f379f95">getSplinedValue</a> (int layer, T r, T r2=-1.0) const</td></tr>
<tr class="memdesc:af62cf7fbc74954e12b582e483f379f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of one of the potential functions at a specified layer and distance, using the appropriate internal spline table.  <br /></td></tr>
<tr class="separator:af62cf7fbc74954e12b582e483f379f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd4f5edfe60e784ab35a58e0795b4b0" id="r_a9dd4f5edfe60e784ab35a58e0795b4b0"><td class="memItemLeft" align="right" valign="top"><a id="a9dd4f5edfe60e784ab35a58e0795b4b0" name="a9dd4f5edfe60e784ab35a58e0795b4b0"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><b>getAnalyticValue</b> (int layer, T r, T r2=-1.0) const</td></tr>
<tr class="memdesc:a9dd4f5edfe60e784ab35a58e0795b4b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the value of one of the potential functions, using analytic expressions, at a specified layer and distance. Descriptions of input parameters follow from <a class="el" href="#af62cf7fbc74954e12b582e483f379f95" title="Get the value of one of the potential functions at a specified layer and distance,...">getSplinedValue()</a> above. <br /></td></tr>
<tr class="separator:a9dd4f5edfe60e784ab35a58e0795b4b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ea5bf1dbdfe5daea1154cc52da839a" id="r_a63ea5bf1dbdfe5daea1154cc52da839a"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63ea5bf1dbdfe5daea1154cc52da839a">getSplinedDerivative</a> (int layer, T r, T r2=-1.0, int order=1) const</td></tr>
<tr class="memdesc:a63ea5bf1dbdfe5daea1154cc52da839a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of the potential derivative at a specified layer and distance, making use of an internal table for the derivative.  <br /></td></tr>
<tr class="separator:a63ea5bf1dbdfe5daea1154cc52da839a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204ebf85d104dbc280dedf9badeb1ec7" id="r_a204ebf85d104dbc280dedf9badeb1ec7"><td class="memItemLeft" align="right" valign="top"><a id="a204ebf85d104dbc280dedf9badeb1ec7" name="a204ebf85d104dbc280dedf9badeb1ec7"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><b>getAnalyticDerivative</b> (int layer, T r, T r2=-1.0, int order=1) const</td></tr>
<tr class="memdesc:a204ebf85d104dbc280dedf9badeb1ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of the potential derivative at a specified layer and distance, using analytic calculations. Descriptions of input parameters follow from <a class="el" href="#a63ea5bf1dbdfe5daea1154cc52da839a" title="Get the value of the potential derivative at a specified layer and distance, making use of an interna...">getSplinedDerivative()</a> above. <br /></td></tr>
<tr class="separator:a204ebf85d104dbc280dedf9badeb1ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e9c2b2c39774e6193d69bee2480ef6" id="r_af2e9c2b2c39774e6193d69bee2480ef6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classstormm_1_1energy_1_1NrgLayerKit.html">NrgLayerKit</a>&lt; T4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2e9c2b2c39774e6193d69bee2480ef6">data</a> (int layer_index, HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:af2e9c2b2c39774e6193d69bee2480ef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a read-only abstract for the object, gear towards a specific layer of the potential. The abstract for the appropriate spline table, plus limits of the layer's range, will be included. Because the final spline segment might not terminate at precisely the layer's cutoff, it is essential to check whether any particular interaction is in the applicable range, rather than relying on spline table entries to be zero past the applicable range.  <br /></td></tr>
<tr class="separator:af2e9c2b2c39774e6193d69bee2480ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab166bd1a1d92ad34bf6d8aabc3a1d0f6" id="r_ab166bd1a1d92ad34bf6d8aabc3a1d0f6"><td class="memItemLeft" align="right" valign="top"><a id="ab166bd1a1d92ad34bf6d8aabc3a1d0f6" name="ab166bd1a1d92ad34bf6d8aabc3a1d0f6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>LayeredPotential</b> (const <a class="el" href="classstormm_1_1energy_1_1LayeredPotentialMetrics.html">LayeredPotentialMetrics</a> &amp;parameters_in=<a class="el" href="classstormm_1_1energy_1_1LayeredPotentialMetrics.html">LayeredPotentialMetrics</a>())</td></tr>
<tr class="memdesc:ab166bd1a1d92ad34bf6d8aabc3a1d0f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructor requires an enumeration to specify a particular potential form as well as a rough understanding of the box size. The CLASH form corresponds to an empty object. For van-der Waals potentials, the type of mixing rule can also be significant: the shortest-ranged potentials will turn on the 1/r^6 potential with a sigmoidal switching function to allow NBFIX and Lorentz-Berthelot style mixing rules to apply their unique interactions at close range, pushing back the transition to a geometric combining rule to a longer range where the difference between mixing rules is trivial. <br /></td></tr>
<tr class="separator:ab166bd1a1d92ad34bf6d8aabc3a1d0f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a18e2854b9dc6f54756bf7a2ce006ab30" id="r_a18e2854b9dc6f54756bf7a2ce006ab30"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18e2854b9dc6f54756bf7a2ce006ab30">LayeredPotential</a> (const <a class="el" href="classstormm_1_1energy_1_1LayeredPotential.html">LayeredPotential</a> &amp;original)=default</td></tr>
<tr class="memdesc:a18e2854b9dc6f54756bf7a2ce006ab30"><td class="mdescLeft">&#160;</td><td class="mdescRight">So long as the nested parameters manager and <a class="el" href="classstormm_1_1energy_1_1LogScaleSpline.html" title="A logarithmic spline can be very useful for interpolating functions that are steepest at low values o...">LogScaleSpline</a> objects copy and move correctly, the copy and move constructors, as well as the copy and move assignment operators will be valid.  <br /></td></tr>
<tr class="separator:a18e2854b9dc6f54756bf7a2ce006ab30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae91ab7f281239c97510591f92c00b2ed" id="r_ae91ab7f281239c97510591f92c00b2ed"><td class="memItemLeft" align="right" valign="top"><a id="ae91ab7f281239c97510591f92c00b2ed" name="ae91ab7f281239c97510591f92c00b2ed"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>LayeredPotential</b> (<a class="el" href="classstormm_1_1energy_1_1LayeredPotential.html">LayeredPotential</a> &amp;&amp;original)=default</td></tr>
<tr class="separator:ae91ab7f281239c97510591f92c00b2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a931e591c21b29d69db47abb84b7ad2d0" id="r_a931e591c21b29d69db47abb84b7ad2d0"><td class="memItemLeft" align="right" valign="top"><a id="a931e591c21b29d69db47abb84b7ad2d0" name="a931e591c21b29d69db47abb84b7ad2d0"></a>
<a class="el" href="classstormm_1_1energy_1_1LayeredPotential.html">LayeredPotential</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classstormm_1_1energy_1_1LayeredPotential.html">LayeredPotential</a> &amp;other)=default</td></tr>
<tr class="separator:a931e591c21b29d69db47abb84b7ad2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a074fc52e01cd8d565b8b31dbe2fa48d7" id="r_a074fc52e01cd8d565b8b31dbe2fa48d7"><td class="memItemLeft" align="right" valign="top"><a id="a074fc52e01cd8d565b8b31dbe2fa48d7" name="a074fc52e01cd8d565b8b31dbe2fa48d7"></a>
<a class="el" href="classstormm_1_1energy_1_1LayeredPotential.html">LayeredPotential</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classstormm_1_1energy_1_1LayeredPotential.html">LayeredPotential</a> &amp;&amp;other)=default</td></tr>
<tr class="separator:a074fc52e01cd8d565b8b31dbe2fa48d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T, typename T4&gt;<br />
class stormm::energy::LayeredPotential&lt; T, T4 &gt;</div><p>A long-ranged potential can be broken down into a series of successively smoother potentials applicable over longer and longer ranges. This object will manage a process whereby each potential and its first three derivatives decay exactly to zero at the specified boundary. The process generates some very complicated forms, particularly in the shortest-range potential where the effects assigned to all longer-ranged potentials must be subtracted off, but use of logarithmic adaptive splines can absorb the complexity. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a18e2854b9dc6f54756bf7a2ce006ab30" name="a18e2854b9dc6f54756bf7a2ce006ab30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18e2854b9dc6f54756bf7a2ce006ab30">&#9670;&#160;</a></span>LayeredPotential()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename T4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstormm_1_1energy_1_1LayeredPotential.html">stormm::energy::LayeredPotential</a>&lt; T, T4 &gt;::LayeredPotential </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstormm_1_1energy_1_1LayeredPotential.html">LayeredPotential</a>&lt; T, T4 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>original</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>So long as the nested parameters manager and <a class="el" href="classstormm_1_1energy_1_1LogScaleSpline.html" title="A logarithmic spline can be very useful for interpolating functions that are steepest at low values o...">LogScaleSpline</a> objects copy and move correctly, the copy and move constructors, as well as the copy and move assignment operators will be valid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">original</td><td>The existing object to copy or move </td></tr>
    <tr><td class="paramname">other</td><td>Another object to place on the right hand side of the assignment statement </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af2e9c2b2c39774e6193d69bee2480ef6" name="af2e9c2b2c39774e6193d69bee2480ef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2e9c2b2c39774e6193d69bee2480ef6">&#9670;&#160;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename T4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classstormm_1_1energy_1_1NrgLayerKit.html">NrgLayerKit</a>&lt; T4 &gt; <a class="el" href="classstormm_1_1energy_1_1LayeredPotential.html">stormm::energy::LayeredPotential</a>&lt; T, T4 &gt;::data </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>layer_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a read-only abstract for the object, gear towards a specific layer of the potential. The abstract for the appropriate spline table, plus limits of the layer's range, will be included. Because the final spline segment might not terminate at precisely the layer's cutoff, it is essential to check whether any particular interaction is in the applicable range, rather than relying on spline table entries to be zero past the applicable range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer_index</td><td>Index of the layer for which to prepare the abstract </td></tr>
    <tr><td class="paramname">tier</td><td>Assign pointers to target memory on the CPU host or GPU device </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad00d70c3b04eb0b8bb4a36342167b1c5" name="ad00d70c3b04eb0b8bb4a36342167b1c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad00d70c3b04eb0b8bb4a36342167b1c5">&#9670;&#160;</a></span>getSmoothingCoefficients()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename T4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstormm_1_1data__types_1_1double4.html">double4</a> <a class="el" href="classstormm_1_1energy_1_1LayeredPotential.html">stormm::energy::LayeredPotential</a>&lt; T, T4 &gt;::getSmoothingCoefficients </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>layer</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the quartet of coefficients for one of the layers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer</td><td>Index of the layer of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63ea5bf1dbdfe5daea1154cc52da839a" name="a63ea5bf1dbdfe5daea1154cc52da839a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63ea5bf1dbdfe5daea1154cc52da839a">&#9670;&#160;</a></span>getSplinedDerivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename T4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classstormm_1_1energy_1_1LayeredPotential.html">stormm::energy::LayeredPotential</a>&lt; T, T4 &gt;::getSplinedDerivative </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>layer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>r2</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>order</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of the potential derivative at a specified layer and distance, making use of an internal table for the derivative. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer</td><td>Index of the layer of interest </td></tr>
    <tr><td class="paramname">r</td><td>Distance at which to evaluate the interaction (specifying a value beyond the particular layer's cutoff will return zero) </td></tr>
    <tr><td class="paramname">order</td><td>The order of the derivative (default 1, the first derivative&ndash;specifying zero will return the function value) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af62cf7fbc74954e12b582e483f379f95" name="af62cf7fbc74954e12b582e483f379f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af62cf7fbc74954e12b582e483f379f95">&#9670;&#160;</a></span>getSplinedValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename T4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classstormm_1_1energy_1_1LayeredPotential.html">stormm::energy::LayeredPotential</a>&lt; T, T4 &gt;::getSplinedValue </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>layer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>r2</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1.0</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of one of the potential functions at a specified layer and distance, using the appropriate internal spline table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer</td><td>Index of the layer of interest </td></tr>
    <tr><td class="paramname">r</td><td>Distance at which to evaluate the interaction (specifying a value beyond the particular layer's cutoff will return zero) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/Potential/<a class="el" href="layered__potential_8h_source.html">layered_potential.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2
</small></address>
</div><!-- doc-content -->
</body>
</html>
