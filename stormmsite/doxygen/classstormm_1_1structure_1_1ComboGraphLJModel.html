<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>STORMM Source Documentation: stormm::structure::ComboGraphLJModel Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">STORMM Source Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>stormm</b></li><li class="navelem"><b>structure</b></li><li class="navelem"><a class="el" href="classstormm_1_1structure_1_1ComboGraphLJModel.html">ComboGraphLJModel</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classstormm_1_1structure_1_1ComboGraphLJModel-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">stormm::structure::ComboGraphLJModel Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>An object to manage the combination of Lennard-Jones parameters from two topologies. This can be used to insert "NBFix" pair-specific (off-rule) parameters where neither topology by itself might contain the requisite information. It can also be used to build parameter tables for a union of the two underlying topologies and produce arrays indices into that table for a new topology.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="combograph__ljmodel_8h_source.html">combograph_ljmodel.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3d319c9f91a791d48654286f47b744f0" id="r_a3d319c9f91a791d48654286f47b744f0"><td class="memItemLeft" align="right" valign="top"><a id="a3d319c9f91a791d48654286f47b744f0" name="a3d319c9f91a791d48654286f47b744f0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getSetCount</b> () const</td></tr>
<tr class="memdesc:a3d319c9f91a791d48654286f47b744f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of Lennard-Jones parameter matrix sets. <br /></td></tr>
<tr class="separator:a3d319c9f91a791d48654286f47b744f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e4b4272e8594f156ad7dc1172554ab" id="r_ad2e4b4272e8594f156ad7dc1172554ab"><td class="memItemLeft" align="right" valign="top"><a id="ad2e4b4272e8594f156ad7dc1172554ab" name="ad2e4b4272e8594f156ad7dc1172554ab"></a>
VdwCombiningRule&#160;</td><td class="memItemRight" valign="bottom"><b>getDefaultCombiningRule</b> () const</td></tr>
<tr class="memdesc:ad2e4b4272e8594f156ad7dc1172554ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default combining rule for mixing parameters of different topologies. <br /></td></tr>
<tr class="separator:ad2e4b4272e8594f156ad7dc1172554ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5868df18a3fe9db332d80f6e7712f2aa" id="r_a5868df18a3fe9db332d80f6e7712f2aa"><td class="memItemLeft" align="right" valign="top"><a id="a5868df18a3fe9db332d80f6e7712f2aa" name="a5868df18a3fe9db332d80f6e7712f2aa"></a>
VdwCombiningRule&#160;</td><td class="memItemRight" valign="bottom"><b>getPrimaryTopologyRule</b> () const</td></tr>
<tr class="memdesc:a5868df18a3fe9db332d80f6e7712f2aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the combining rule effective in the primary topology. <br /></td></tr>
<tr class="separator:a5868df18a3fe9db332d80f6e7712f2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8eacc3dffc5bd0f6e8c304973d6c661" id="r_ad8eacc3dffc5bd0f6e8c304973d6c661"><td class="memItemLeft" align="right" valign="top">VdwCombiningRule&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8eacc3dffc5bd0f6e8c304973d6c661">getSecondaryTopologyRule</a> (int index) const</td></tr>
<tr class="memdesc:ad8eacc3dffc5bd0f6e8c304973d6c661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the combining rule effective in one of the secondary topologies.  <br /></td></tr>
<tr class="separator:ad8eacc3dffc5bd0f6e8c304973d6c661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109dcc2f380eefee68abc03863c82f5f" id="r_a109dcc2f380eefee68abc03863c82f5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstormm_1_1data__types_1_1int2.html">int2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a109dcc2f380eefee68abc03863c82f5f">getMatrixSize</a> (int index) const</td></tr>
<tr class="memdesc:a109dcc2f380eefee68abc03863c82f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of atom types in the primary topology.  <br /></td></tr>
<tr class="separator:a109dcc2f380eefee68abc03863c82f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7992bf0a8bc17b4b3f6bedd644894762" id="r_a7992bf0a8bc17b4b3f6bedd644894762"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7992bf0a8bc17b4b3f6bedd644894762">getACoefficients</a> (int index) const</td></tr>
<tr class="memdesc:a7992bf0a8bc17b4b3f6bedd644894762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the matrix of Lennard-Jones A coefficients between the primary topology and another topology. The primary atom types control rows of the matrix, while the other topology's atom types control columns. The matrix has column format, like others in STORMM.  <br /></td></tr>
<tr class="separator:a7992bf0a8bc17b4b3f6bedd644894762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2752cfa0c46ad3b4aad388aac6e09f21" id="r_a2752cfa0c46ad3b4aad388aac6e09f21"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2752cfa0c46ad3b4aad388aac6e09f21">getBCoefficients</a> (int index) const</td></tr>
<tr class="memdesc:a2752cfa0c46ad3b4aad388aac6e09f21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the matrix of Lennard-Jones B coefficients between the primary topology and another topology. The primary atom types control rows of the matrix, while the other topology's atom types control columns. The matrix has column format, like others in STORMM.  <br /></td></tr>
<tr class="separator:a2752cfa0c46ad3b4aad388aac6e09f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa9a04a38ae51d2bc39d552a5c860513" id="r_aaa9a04a38ae51d2bc39d552a5c860513"><td class="memItemLeft" align="right" valign="top"><a id="aaa9a04a38ae51d2bc39d552a5c860513" name="aaa9a04a38ae51d2bc39d552a5c860513"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>computeConsensusParameters</b> () const</td></tr>
<tr class="separator:aaa9a04a38ae51d2bc39d552a5c860513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d51a55e12b96522e7476a57668150cd" id="r_a2d51a55e12b96522e7476a57668150cd"><td class="memItemLeft" align="right" valign="top"><a id="a2d51a55e12b96522e7476a57668150cd" name="a2d51a55e12b96522e7476a57668150cd"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getAtomTypeUnionSize</b> ()</td></tr>
<tr class="memdesc:a2d51a55e12b96522e7476a57668150cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of unique atom types across all topologies other than the primary. This is done by finding unique fingerprints among the columns of the A and B coefficient matrices for each combination parameter set. <br /></td></tr>
<tr class="separator:a2d51a55e12b96522e7476a57668150cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa7410944d5effc1cbbce713d247a9396" id="r_aa7410944d5effc1cbbce713d247a9396"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7410944d5effc1cbbce713d247a9396">ComboGraphLJModel</a> (const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> *primary_ag_in, const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> *ag_secondary_in=nullptr, VdwCombiningRule default_rule_in=VdwCombiningRule::LORENTZ_BERTHELOT, const std::vector&lt; <a class="el" href="structstormm_1_1topology_1_1PairLJInteraction.html">PairLJInteraction</a> &gt; &amp;edits={})</td></tr>
<tr class="memdesc:aa7410944d5effc1cbbce713d247a9396"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructor accepts two topologies or two Lennard-Jones parameter sets. Edits to the Lennard-Jones parameters can be provided to the constructor or entered later.  <br /></td></tr>
<tr class="separator:aa7410944d5effc1cbbce713d247a9396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a161e11fddb7714007cccf6336718ef19" id="r_a161e11fddb7714007cccf6336718ef19"><td class="memItemLeft" align="right" valign="top"><a id="a161e11fddb7714007cccf6336718ef19" name="a161e11fddb7714007cccf6336718ef19"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ComboGraphLJModel</b> (const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;primary_ag_in, const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;ag_secondary_in, VdwCombiningRule default_rule_in=VdwCombiningRule::LORENTZ_BERTHELOT, const std::vector&lt; <a class="el" href="structstormm_1_1topology_1_1PairLJInteraction.html">PairLJInteraction</a> &gt; &amp;edits={})</td></tr>
<tr class="separator:a161e11fddb7714007cccf6336718ef19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4972f0ac59f59b1288fdfe06f430e79d" id="r_a4972f0ac59f59b1288fdfe06f430e79d"><td class="memItemLeft" align="right" valign="top"><a id="a4972f0ac59f59b1288fdfe06f430e79d" name="a4972f0ac59f59b1288fdfe06f430e79d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ComboGraphLJModel</b> (const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;primary_ag_in, const <a class="el" href="classstormm_1_1synthesis_1_1AtomGraphSynthesis.html">AtomGraphSynthesis</a> &amp;poly_ag_secondary, VdwCombiningRule default_rule_in=VdwCombiningRule::LORENTZ_BERTHELOT, const std::vector&lt; <a class="el" href="structstormm_1_1topology_1_1PairLJInteraction.html">PairLJInteraction</a> &gt; &amp;edits={})</td></tr>
<tr class="separator:a4972f0ac59f59b1288fdfe06f430e79d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae904da16a3c3be6d28f30bfdf0dd3d41" id="r_ae904da16a3c3be6d28f30bfdf0dd3d41"><td class="memItemLeft" align="right" valign="top"><a id="ae904da16a3c3be6d28f30bfdf0dd3d41" name="ae904da16a3c3be6d28f30bfdf0dd3d41"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ComboGraphLJModel</b> (const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> *primary_ag_in, const std::vector&lt; double &gt; &amp;lj_a_in, const std::vector&lt; double &gt; &amp;lj_b_in, const std::vector&lt; <a class="el" href="structstormm_1_1data__types_1_1char4.html">char4</a> &gt; &amp;lj_type_names={}, VdwCombiningRule default_rule_in=VdwCombiningRule::LORENTZ_BERTHELOT, const std::vector&lt; <a class="el" href="structstormm_1_1topology_1_1PairLJInteraction.html">PairLJInteraction</a> &gt; &amp;edits={})</td></tr>
<tr class="separator:ae904da16a3c3be6d28f30bfdf0dd3d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d7157182ed37422f6882bb20f9bb01" id="r_a48d7157182ed37422f6882bb20f9bb01"><td class="memItemLeft" align="right" valign="top"><a id="a48d7157182ed37422f6882bb20f9bb01" name="a48d7157182ed37422f6882bb20f9bb01"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ComboGraphLJModel</b> (const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;primary_ag_in, const std::vector&lt; double &gt; &amp;lj_a_in, const std::vector&lt; double &gt; &amp;lj_b_in, const std::vector&lt; <a class="el" href="structstormm_1_1data__types_1_1char4.html">char4</a> &gt; &amp;lj_type_names={}, VdwCombiningRule default_rule_in=VdwCombiningRule::LORENTZ_BERTHELOT, const std::vector&lt; <a class="el" href="structstormm_1_1topology_1_1PairLJInteraction.html">PairLJInteraction</a> &gt; &amp;edits={})</td></tr>
<tr class="separator:a48d7157182ed37422f6882bb20f9bb01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4705e028861bf6af07bea2717561e3b4" id="r_a4705e028861bf6af07bea2717561e3b4"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a4705e028861bf6af07bea2717561e3b4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4705e028861bf6af07bea2717561e3b4">addCombination</a> (const T *lja_in, const T *ljb_in, int lj_type_count, const <a class="el" href="structstormm_1_1data__types_1_1char4.html">char4</a> *lj_type_names=nullptr, const std::vector&lt; <a class="el" href="structstormm_1_1topology_1_1PairLJInteraction.html">PairLJInteraction</a> &gt; &amp;edits={})</td></tr>
<tr class="memdesc:a4705e028861bf6af07bea2717561e3b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an interaction matrix to the list of combinations.  <br /></td></tr>
<tr class="separator:a4705e028861bf6af07bea2717561e3b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8671a9cebbb8ef0077cab5f1aaeb05c" id="r_ab8671a9cebbb8ef0077cab5f1aaeb05c"><td class="memTemplParams" colspan="2"><a id="ab8671a9cebbb8ef0077cab5f1aaeb05c" name="ab8671a9cebbb8ef0077cab5f1aaeb05c"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:ab8671a9cebbb8ef0077cab5f1aaeb05c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>addCombination</b> (const std::vector&lt; T &gt; &amp;lja_in, const std::vector&lt; T &gt; &amp;ljb_in, const std::vector&lt; <a class="el" href="structstormm_1_1data__types_1_1char4.html">char4</a> &gt; &amp;lj_type_names={}, const std::vector&lt; <a class="el" href="structstormm_1_1topology_1_1PairLJInteraction.html">PairLJInteraction</a> &gt; &amp;edits={})</td></tr>
<tr class="separator:ab8671a9cebbb8ef0077cab5f1aaeb05c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50774705fcecc0f2f0e1f018bee10647" id="r_a50774705fcecc0f2f0e1f018bee10647"><td class="memItemLeft" align="right" valign="top"><a id="a50774705fcecc0f2f0e1f018bee10647" name="a50774705fcecc0f2f0e1f018bee10647"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addCombination</b> (const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> *ag_secondary, const std::vector&lt; <a class="el" href="structstormm_1_1topology_1_1PairLJInteraction.html">PairLJInteraction</a> &gt; &amp;edits={})</td></tr>
<tr class="separator:a50774705fcecc0f2f0e1f018bee10647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab2fbc7bb6a7977bede79071d83825b" id="r_a9ab2fbc7bb6a7977bede79071d83825b"><td class="memItemLeft" align="right" valign="top"><a id="a9ab2fbc7bb6a7977bede79071d83825b" name="a9ab2fbc7bb6a7977bede79071d83825b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addCombination</b> (const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;ag_secondary, const std::vector&lt; <a class="el" href="structstormm_1_1topology_1_1PairLJInteraction.html">PairLJInteraction</a> &gt; &amp;edits={})</td></tr>
<tr class="separator:a9ab2fbc7bb6a7977bede79071d83825b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An object to manage the combination of Lennard-Jones parameters from two topologies. This can be used to insert "NBFix" pair-specific (off-rule) parameters where neither topology by itself might contain the requisite information. It can also be used to build parameter tables for a union of the two underlying topologies and produce arrays indices into that table for a new topology. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa7410944d5effc1cbbce713d247a9396" name="aa7410944d5effc1cbbce713d247a9396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7410944d5effc1cbbce713d247a9396">&#9670;&#160;</a></span>ComboGraphLJModel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">stormm::topology::ComboGraphLJModel::ComboGraphLJModel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> *</td>          <td class="paramname"><span class="paramname"><em>primary_ag_in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> *</td>          <td class="paramname"><span class="paramname"><em>ag_secondary_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VdwCombiningRule</td>          <td class="paramname"><span class="paramname"><em>default_rule_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">VdwCombiningRule::LORENTZ_BERTHELOT</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structstormm_1_1topology_1_1PairLJInteraction.html">PairLJInteraction</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>edits</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The constructor accepts two topologies or two Lennard-Jones parameter sets. Edits to the Lennard-Jones parameters can be provided to the constructor or entered later. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly_ag_secondary</td><td>A synthesis of topologies form which to harvest unique Lennard-Jones types </td></tr>
    <tr><td class="paramname">edits_in</td><td>A list of edits to apply to modify pair-specific Lennard-Jones </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4705e028861bf6af07bea2717561e3b4" name="a4705e028861bf6af07bea2717561e3b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4705e028861bf6af07bea2717561e3b4">&#9670;&#160;</a></span>addCombination()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stormm::topology::ComboGraphLJModel::addCombination </td>
          <td>(</td>
          <td class="paramtype">const T *</td>          <td class="paramname"><span class="paramname"><em>lja_in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *</td>          <td class="paramname"><span class="paramname"><em>ljb_in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>lj_type_count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstormm_1_1data__types_1_1char4.html">char4</a> *</td>          <td class="paramname"><span class="paramname"><em>lj_type_names</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structstormm_1_1topology_1_1PairLJInteraction.html">PairLJInteraction</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>edits</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an interaction matrix to the list of combinations. </p>
<p>Overloaded:</p><ul>
<li>Provide a combination of vectors or C-style arrays for the new parameter set</li>
<li>Provide the new topology by const pointer or const reference</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lja_in</td><td>Array of Lennard-Jones A coefficients, i.e. U = A/r^12 + B/r^6, to be combined per the object's default rule </td></tr>
    <tr><td class="paramname">ljb_in</td><td>Array of Lennard-Jones B coefficients, to be combined per the object's default rule </td></tr>
    <tr><td class="paramname">lj_type_count</td><td>The number of Lennard-Jones types, implying a trusted length for lja_in and ljb_in, if provided as C-style arrays </td></tr>
    <tr><td class="paramname">ag_new</td><td>The topology to incorporate. A null pointer will abort the inclusion. </td></tr>
    <tr><td class="paramname">edits</td><td>A list of pair-specific Lennard-Jones parameters to apply </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7992bf0a8bc17b4b3f6bedd644894762" name="a7992bf0a8bc17b4b3f6bedd644894762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7992bf0a8bc17b4b3f6bedd644894762">&#9670;&#160;</a></span>getACoefficients()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; double &gt; &amp; stormm::topology::ComboGraphLJModel::getACoefficients </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the matrix of Lennard-Jones A coefficients between the primary topology and another topology. The primary atom types control rows of the matrix, while the other topology's atom types control columns. The matrix has column format, like others in STORMM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The combination of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2752cfa0c46ad3b4aad388aac6e09f21" name="a2752cfa0c46ad3b4aad388aac6e09f21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2752cfa0c46ad3b4aad388aac6e09f21">&#9670;&#160;</a></span>getBCoefficients()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; double &gt; &amp; stormm::topology::ComboGraphLJModel::getBCoefficients </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the matrix of Lennard-Jones B coefficients between the primary topology and another topology. The primary atom types control rows of the matrix, while the other topology's atom types control columns. The matrix has column format, like others in STORMM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The combination of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a109dcc2f380eefee68abc03863c82f5f" name="a109dcc2f380eefee68abc03863c82f5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a109dcc2f380eefee68abc03863c82f5f">&#9670;&#160;</a></span>getMatrixSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstormm_1_1data__types_1_1int2.html">int2</a> stormm::topology::ComboGraphLJModel::getMatrixSize </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of atom types in the primary topology. </p>
<p>Get the size of a particular combination matrix. The matrix has as many rows as the primary topology has atom types and as many columns as the new (other) topology has atom types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The combination of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad8eacc3dffc5bd0f6e8c304973d6c661" name="ad8eacc3dffc5bd0f6e8c304973d6c661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8eacc3dffc5bd0f6e8c304973d6c661">&#9670;&#160;</a></span>getSecondaryTopologyRule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VdwCombiningRule stormm::topology::ComboGraphLJModel::getSecondaryTopologyRule </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the combining rule effective in one of the secondary topologies. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The secondary topology of interest (the ith secondary topology takes part in the ith combination with the primary topology) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/Topology/<a class="el" href="combograph__ljmodel_8h_source.html">combograph_ljmodel.h</a></li>
<li>src/Topology/<b>combograph_ljmodel.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2
</small></address>
</div><!-- doc-content -->
</body>
</html>
