import{_ as o,c as l,b as i,a as e,d as s,e as t,w as a,f as r,o as d}from"./app-Bm2u2Kmo.js";const c={},u=i('<h1 id="creating-your-own-input-blocks" tabindex="-1"><a class="header-anchor" href="#creating-your-own-input-blocks"><span>Creating Your Own Input Blocks</span></a></h1><p>With few exceptions, creating custom programs, or modifying existing programs, requires the developer to create input options for the user to control new features. STORMM uses a native C++ emulator for Fortran-like namelists, allowing it to read input files that look much like those of the AMBER molecular dynamics engines <strong>sander</strong> and <strong>pmemd</strong>. The namelist syntax in STORMM is enhanced, allowing users to forego <code>=</code> signs and commas: <code>keyword_a = value_a, keyword_b = value_b</code> is interpreted in the same way as <code>keyword_a value_a keyword_b value_b</code>, although a comma would help for legibility. STORMM also lets the developer specify keywords to take <code>STRUCT</code> inputs, signified by brace characters before and after a list of sub-key entries, e.g. <code>composite_a = { -part_i value_i, -part_ii value_ii, -part_iv value_iv }</code> with sub-keys being optional or required at the developer&#39;s discretion. Furthermore, STORMM lets the developer stipulate whether a keyword will accept multiple entries. In this tutorial, we will explore how to make a custom input block and give the user a pathway to feeding information into programs written with STORMM.</p><h2 id="the-method" tabindex="-1"><a class="header-anchor" href="#the-method"><span>The Method</span></a></h2><p>There are three major steps to passing user input into STORMM, each requiring C++ code of moderate density.</p>',4),m=e("code",null,"NamelistEmulator",-1),p=e("li",null,[s("Run a file stream by that "),e("code",null,"NamelistEmulator"),s(" object to load it up user input directives")],-1),h=e("code",null,"NamelistEmulator",-1),v=e("code",null,"&dynamics",-1),g=e("code",null,"&precision",-1),b=e("code",null,"DynamicsControls",-1),f=e("code",null,"PrecisionControls",-1),w=e("code",null,"NamelistEmulator",-1),_=e("code",null,"TextFile",-1),y=e("code",null,"NamelistEmulator",-1),k=e("code",null,"NamelistEmulator",-1),x=e("code",null,"readNamelist",-1),q=e("code",null,"NamelistEmulator",-1),T=i(`<div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">#include &quot;/stormm/home/src/Namelists/namelist_emulator.h&quot;</span>
<span class="line">#include &quot;/stormm/home/src/Parsing/textfile.h&quot;</span>
<span class="line"></span>
<span class="line">using stormm::namelist::NamelistEmulator;</span>
<span class="line"></span>
<span class="line">NamelistEmulator starInput(const TextFile &amp;input_ascii_text);</span>
<span class="line"></span>
<span class="line">class StarControls() {</span>
<span class="line">public:</span>
<span class="line">  StarControls(const TextFile &amp;input_ascii_text);</span>
<span class="line"></span>
<span class="line">  int getPlanetCount() const;</span>
<span class="line">  double getMass() const;</span>
<span class="line">  double getBrightness() const;</span>
<span class="line">  </span>
<span class="line">private:</span>
<span class="line">  int planet_count;   // Number of planets in orbit</span>
<span class="line">  double mass;        // Mass in units of solar masses</span>
<span class="line">  double brightness;  // Brightness expressed in apparent magnitude</span>
<span class="line">};</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>In the example above, which will be expanded in the Tutorial III program, the namelist <code>&amp;star</code> is configured into a <code>NamelistEmulator</code> by the <code>starInput</code> function. The contents of that function, which again accomplishes the first and second stages of the overall process, could be as follows (a slightly longer version is found in the tutorial &quot;answer&quot; program, <strong>/stormm/home/apps/Tutorial/tutorial_iii.cpp</strong>).</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">#include &quot;/stormm/home/src/Constants/behavior.h&quot;</span>
<span class="line">#include &quot;/stormm/home/src/Namelists/input.h&quot;</span>
<span class="line">#include &quot;/stormm/home/src/Namelists/namelist_enumerators.h&quot;</span>
<span class="line">#include &quot;/stormm/home/src/Parse/parsing_enumerators.h&quot;</span>
<span class="line"></span>
<span class="line">using stormm::constants::ExceptionResponse;</span>
<span class="line">using stormm::constants::CaseSensitivity;</span>
<span class="line">using stormm::namelist::NamelistType;</span>
<span class="line">using stormm::parse::WrapTextSearch;</span>
<span class="line"></span>
<span class="line">NamelistEmulator starInput(const TextFile &amp;input_ascii_text) {</span>
<span class="line">  NamelistEmulator result(&quot;star&quot;, CaseSensitivity::YES, ExceptionResponse::DIE, &quot;Parameters for &quot;</span>
<span class="line">                          &quot;a star in the sky&quot;);</span>
<span class="line">  result.addKeyword(&quot;planets&quot;, NamelistType::INTEGER, std::to_string(8));</span>
<span class="line">  result.addKeyword(&quot;mass&quot;, NamelistType::REAL, std::to_string(1.0));</span>
<span class="line">  result.addKeyword(&quot;brightness&quot;, NamelistType::REAL, std::to_string(-26.74));</span>
<span class="line">  int start_line = 0;</span>
<span class="line">  readNamelist(input_ascii_text, &amp;result, &amp;start_line, WrapTextSearch::YES, tf.getLineCount());</span>
<span class="line">  return result;</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The <code>starInput</code> function carried out the laborious task of sifting through the entire input file, or a portion of its lines if we had some intelligent way to put limits on the range. This converted the potentially large block of character input into a developer-defined collection of keyword-value pairs. It is incorporated into the <code>StarControls</code> class constructor to carry out, once, the relatively strenuous task of sifting through the keyword-value pairs to find the appropriate values needed by the program based on their keywords. Its abridged contents might be:</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">StarControls::StarControls(const TextFile &amp;input_ascii_text) :</span>
<span class="line">    planet_count{0}, mass{1.0}, brightness{1.0}</span>
<span class="line">{</span>
<span class="line">  NamelistEmulator t_nml = starInput(input_ascii_text);</span>
<span class="line">  t_nml.assignVariable(&amp;planet_count, &quot;planets&quot;);</span>
<span class="line">  t_nml.assignVariable(&amp;mass, &quot;mass&quot;);</span>
<span class="line">  t_nml.assignVariable(&amp;brightness, &quot;brightness&quot;);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Once the <code>StarControls</code> class object is constructed, getting the number of planets around a star no longer requires a series of string comparisons against every keyword in the <code>&amp;star</code> namelist, it can be retrieved by a single call to the <code>StarControls::getPlanetCount()</code> accessor function (the contents of which were not written out above, but should be obvious). The <code>NamelistEmulator</code> methods such as <code>assignVariable</code> and <code>addKeyword</code> come with many overloads to give developers freedom in organizing the keywords and their associated descriptions. In a real application, there might be more than a dozen keywords in the new input block. Configuring the <code>NamelistEmulator</code> and unpacking it in this way will comprise the bulk of the code to write, and is intended to be as script-like as possible.</p><h2 id="the-command-line-is-a-namelist-too" tabindex="-1"><a class="header-anchor" href="#the-command-line-is-a-namelist-too"><span>The Command Line is a Namelist, Too!</span></a></h2>`,7),N=e("code",null,"CommandLineParser",-1),E=e("code",null,"NamelistEmulator",-1),C=i(`<h2 id="displaying-keyword-documentation" tabindex="-1"><a class="header-anchor" href="#displaying-keyword-documentation"><span>Displaying Keyword Documentation</span></a></h2><p>In addition to the means for developing new namelists, STORMM has a way to give each program a user manual with an interactive display through the command line. With this system, running the program with no arguments or with <code>--help</code> and variations thereof will produce a summary of the program&#39;s declared purpose and a list of namelist conntrol block titles, with their own provided descriptions, in the terminal window. Running the program with the title of one of the applicable namelists as the command line argument will produce a table of keywords in the namelist, complete with data types, default values, and descriptions. All of this is done by accessing the configured <code>NamelistEmulator</code>, and works with many of the same methods used to display namelist contents and input choices when printing a report file at the end of a run.</p><p>In order to add help messages for each keyword, we must go to the function wherein the namelist is being configured. The help messages can , in fact, be included with each keyword&#39;s configuration, although the <code>addKeyword</code> method has many overloads and it can be unwieldy to include so much documentation in the space of a single function call. STORMM also provides the <code>addHelp</code> method within the <code>NamelistEmulator</code> class to set the user documentation (more precisely, <code>addHelp</code> will modify the message after the constructor assigns a blank message). The documentation for each keyword, building on the above code to configure <code>NamelistEmulator result</code>, could be:</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">  result.addHelp(&quot;planets&quot;, &quot;The number of planets known to orbit the star&quot;);</span>
<span class="line">  result.addHelp(&quot;mass&quot;, &quot;Estimated mass of the star, in units of solar masses&quot;);</span>
<span class="line">  result.addHelp(&quot;brightness&quot;, &quot;Apparent magnitude of the star, as observed from Earth&quot;);</span>
<span class="line">  result.addHelp(&quot;name&quot;, &quot;Common name given to the star&quot;);</span>
<span class="line">  result.addHelp(&quot;constellation&quot;, &quot;Name of the constellation in which the star appears, or the &quot;</span>
<span class="line">                 &quot;constellation giving a direction in which to find the star&quot;);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Once the keyword descriptions are configured in the namelist, the developer needs to ensure that they can be conveyed to the user. In STORMM programs, the convention is that running the program with no arguments (or, <code>--help</code>) will print a list of all relevant namelist control blocks, with general descriptions (for <code>&amp;star</code>, the description was &quot;Parameters for a star in the sky&quot;). Re-running the program with the title of a namelist as the command line argument will, in turn, print documentation on the keywords within. But, how do we tell the system about our new namelist, <code>&amp;star</code>?</p><p>It&#39;s worthwhile to point out here that STORMM has a number of general-purpose control blocks for developers to mix and match the input. To reiterate, a <code>NamelistEmulator</code> class object is not much, until it&#39;s configured. That&#39;s why the convention is to encapsulate the configuration for each namelist control block into a specific function, e.g. <code>starInput</code> shown above, so that the documentation system can call on that function to produce a new <code>NamelistEmulator</code> object configured for the control block of interest. We can then use a simple class to connect each configuring function with a namelist title string, and that is the <code>NamelistToken</code> class in <strong>/stormm/home/src/Namelists/namelist_inventory.h</strong>. The class stores a function pointer and contains a method to execute that function on demand. The documentation system can then read through its lists, match the user&#39;s request to the title of a namelist that it knows, and configure a new <code>NamelistEmulator</code> object with all of the relevant keywords. It can then dive in and grab the documentation with the <code>NamelistEmulator</code> method <code>printHelp</code>.</p><p>All we need to do is make the documentation system aware of our new control block. To do that, we can make a vector of tokens the custom namelists, which in this case is just <code>&amp;star</code>:</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">#include &quot;/stormm/home/src/Namelists/namelist_inventory.h&quot;</span>
<span class="line"></span>
<span class="line">using stormm::namelist::NamelistToken;</span>
<span class="line"></span>
<span class="line">  const std:vector&lt;NamelistToken&gt; tutorial_specific_namelists = {</span>
<span class="line">    NamelistToken(std::string(&quot;&amp;star&quot;), starInput);</span>
<span class="line">  };</span>
<span class="line">  clip.addCustomNamelists(tutorial_specific_namelists);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Note that the new namelist&#39;s token was added to the <code>CommandLineParser</code>. This is so that the command line parser does not confuse the title of an actual namelist for some other argument that it is supposed to parse. In fact, requests for namelist documentation will be intercepted before the call to <code>CommandLineParser::parseUserInput(argc, argv)</code>. We use code from STORMM&#39;s <code>display</code> library:</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">#include &quot;/stormm/home/src/Reporting/help_messages.h&quot;</span>
<span class="line"></span>
<span class="line">using stormm::display::displayNamelistHelp;</span>
<span class="line"></span>
<span class="line">  if (displayNamelistHelp(argc, argv, {}, tutorial_specific_namelists) &amp;&amp;</span>
<span class="line">      clip.doesProgramExitOnHelp()) {</span>
<span class="line">    return 0;</span>
<span class="line">  }</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>All documentation will be printed to the terminal in the <code>displayNamelistHelp</code> function. The <code>CommandLineParser</code> can be set to have the program continue after rendering the messages, but the default behavior is to exit and await the user&#39;s next attempt.</p>`,11);function M(S,R){const n=r("RouteLink");return d(),l("div",null,[u,e("ul",null,[e("li",null,[s("Establish a new "),t(n,{to:"/doxygen/classstormm_1_1namelist_1_1NamelistEmulator.html"},{default:a(()=>[m]),_:1}),s(" class object.")]),p,e("li",null,[s("Write an original class to offload information from the "),h,s(" and digest it for the rest of the program The third step is not essential, but in general it is a good idea to streamline the extraction of information from a general-purpose format (where each access requires interpreting, checking, and comparing a character string) to an application-specific dispenser. STORMM also comes with a number of modular namelists, e.g. "),v,s(" and "),g,s(", which can be included in programs from the main libraries. Each of these native input blocks comes with its own unique class to filter the user's input by the strategy above, e.g. "),t(n,{to:"/doxygen/classstormm_1_1namelist_1_1DynamicsControls.html"},{default:a(()=>[b]),_:1}),s(" or "),t(n,{to:"/doxygen/classstormm_1_1namelist_1_1PrecisionControls.html"},{default:a(()=>[f]),_:1})])]),e("p",null,[s("The preferred route is to make a function to configure the "),w,s(" with input elements, then have that function take the user input file or a "),t(n,{to:"/doxygen/classstormm_1_1parse_1_1TextFile.html"},{default:a(()=>[_]),_:1}),s(" class object that has already loaded the input text into memory. The bulk of this function will involve configuring the "),y,s(" with keywords, defaults and help messages. Before returning the "),k,s(" object, the function will load it up using the "),t(n,{to:"/doxygen/input_8h_source.html"},{default:a(()=>[x]),_:1}),s(" function. Again, this will search for keywords in an ascii text file to convert the user input into a general-purpose dispenser which can then dispense the information by issuing queries based on those keywords. The function that manages configuration and loading of the "),q,s(" object for a given control block will be called by the constructor for the application-specific class that dispense information to the rest of the program. An abbreviated header for the protocol is written below:")]),T,e("p",null,[s("The first place STORMM programs take in user information isn't the input file, though: it's the command line. Command line arguments need documentation as well, and to address this need, STORMM bundles all of the character strings passed in from the command line and bundles them as if they were the contents of a namelist. This is done using the "),t(n,{to:"/doxygen/classstormm_1_1namelist_1_1CommandLineParser.html"},{default:a(()=>[N]),_:1}),s(" class, which includes among its members a "),E,s(" and a collection of common keywords (with descriptions) that a developer can add as command line arguments by including them in the constructor call. The developer may add original command line arguments by reaching into the parser to edit the namelist stored inside, and even have the parser coordinate with other classes which look to the command line for information so as not to have keyword collisions or raise exceptions when one parser doesn't recognize a keyword to be used by another.")]),C])}const O=o(c,[["render",M],["__file","tutorial_iii.html.vue"]]),j=JSON.parse('{"path":"/tutorials/tutorial_iii.html","title":"Creating Your Own Input Blocks","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"The Method","slug":"the-method","link":"#the-method","children":[]},{"level":2,"title":"The Command Line is a Namelist, Too!","slug":"the-command-line-is-a-namelist-too","link":"#the-command-line-is-a-namelist-too","children":[]},{"level":2,"title":"Displaying Keyword Documentation","slug":"displaying-keyword-documentation","link":"#displaying-keyword-documentation","children":[]}],"git":{"updatedTime":1749542913000},"filePathRelative":"tutorials/tutorial_iii.md"}');export{O as comp,j as data};
