import{_ as a,c as s,b as n,a as e,d as t,e as i,w as r,f as c,o as l}from"./app-Du_p9-ry.js";const h="/stormmsite/assets/class_abs-BhVuNlIX.png",d={},m=n('<h1 id="the-stormm-view-of-coding-for-molecular-science" tabindex="-1"><a class="header-anchor" href="#the-stormm-view-of-coding-for-molecular-science"><span>The STORMM View of Coding for Molecular Science</span></a></h1><p>Computational science is a practice of applying theory to scientific questions through numerical models and simulations. As such, it is best that scientists who want to develop methods have a connection to the underlying numbers, and this is best achieved with a collection of modular and open-source data structures tailored to the elemental operations of the simulation. For molecular modeling, the basic data structures are molecular topologies and coordinates, but most codes for such computations mount the data in a series of individual arrays and are built for doing one or a set number of such calculations at a time.</p><p>STORMM starts by creating its own unique classes for collecting molecular parameters and coordinates, then makes these first-class C++ classes to take advantage of all functionality in the <a href="https://en.cppreference.com/w/cpp/standard_library" target="_blank" rel="noopener noreferrer">C++ Standard Library</a>: objects of these classes may be used in dynamic array allocation, passed to functions, returned by functions, copied, and named as the developer likes. The next step is to elaborate on the parameters and coordinates with classes to interact with them, enabling simulations, evaluate the textbook chemical structures out of thousands of atoms, and optimize compute-intensive aspects of a simulation.</p><p>For more than a decade, computational science has been transformed by vectorized, general-purpose graphics processors (GPUs). The degree of efficiency afforded by this end point of non-uniform memory access computing is staggering: a single consumer-grade card running on a few hundred watts can perform more calculations than supercomputers of the past, based on single-core or multicore processors. The cards also deliver a much greater degree of parallel scaling: a supercomputer in 2005 might have delieverd as little as 5-10% efficiency on a parallel simulation sprawling over hundreds of processors. A GPU in 2025 may utilize upwards of 50% of its available floating point instructions when propagating the same simulation.</p><p>In the modern computing environment, connecting scientists to the numbers in their calculations also means providing a transparent and simple way to transfer that information to the GPU to support GPU kernels (functions) which carry out the algorithm of interest. GPU programming is difficult due to the nature of finding errors among thousands of threads accessing a single block of memory. STORMM solves these problems with the style and standards of its C++ classes, letting them produce abstracts of pointers and critical array sizes which can be submitted to GPU kernels with much the same appearance as a function call in a C program. Furthermore, all C++ classes are built on a built-in dynamic memory format which manages allocations on both the GPU device and CPU host, as well as transfers between them. The C++ layer provides a means of organizing data and testing its veracity with minimal obfuscation as might be encountered in something like a Python program. The class abstract convention in STORMM ensures that the algorithms and ideas carry over to the GPU.</p><h2 id="keep-dependencies-minimal" tabindex="-1"><a class="header-anchor" href="#keep-dependencies-minimal"><span>Keep Dependencies Minimal</span></a></h2><h2 id="c-to-c-and-then-to-cuda" tabindex="-1"><a class="header-anchor" href="#c-to-c-and-then-to-cuda"><span>C++ to C, and then to CUDA</span></a></h2><p>STORMM is built to run <a href="https://developer.nvidia.com/cuda-toolkit" target="_blank" rel="noopener noreferrer">NVIDIA&#39;s CUDA</a> for the time being, although the code is written to make a transition to some agnostic state with respect to the high-performance computing language. The workflow for porting a new algorithm or memory structure to the GPU is illustrated in the following diagram. Starting with a C++ <code>class</code> containing data in <code>Hybrid&lt;T&gt;</code> dynamically allocated arrays (as opposed to the C++ Standar Template Library <code>std::vector&lt;T&gt;</code> dynamic memory allocation system), a class method is written to return a <code>struct</code> containing critical array size constants and pointers to the relevant memory. If the <code>class</code> contained <code>std::vector&lt;T&gt;</code> arrays for its memory, a set of pointers to each array&#39;s <code>.data()</code> member variable and constants for its <code>.size()</code> would, in effect, allow the developer to traverse the <code>class</code> object&#39;s data s if it were a C <code>struct</code> object. In STORMM, there is an additional choice to make: while the size of any given array will be the same on the CPU or on the GPU, the pointers can refer to data on the CPU host or on the GPU device. The developer can still traverse the host-side data as if it were a C <code>struct</code>, but also take the abstract with pointers to memory on the device and traverse it with C-like CUDA.</p><p><img src="'+h+'" alt="ClassAbstracting"></p>',9),p=e("code",null,"Hybrid",-1),u=e("code",null,"int",-1),f=e("code",null,"double",-1),g=e("code",null,"AtomGraph",-1),y=e("code",null,"Hybrid",-1),b=e("code",null,"StormmClass",-1),v=e("code",null,"double",-1),w=e("code",null,"class",-1),_=e("code",null,"const",-1),C=e("h2",{id:"the-synthesis-not-just-an-array-of-topologies-or-coordinate-sets",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#the-synthesis-not-just-an-array-of-topologies-or-coordinate-sets"},[e("span",null,"The Synthesis: Not Just an Array of Topologies or Coordinate Sets")])],-1),T=e("p",null,"It's easy to think of the",-1);function k(M,S){const o=c("RouteLink");return l(),s("div",null,[m,e("p",null,[t("In the above diagram, a hypothetical STORMM class contains five "),p,t(" arrays in two different data types, e.g. "),u,t(" and "),f,t(". It also contains a pointer to another object, of the STORMM topology type (this is called "),i(o,{to:"/doxygen/classstormm_1_1topology_1_1AtomGraph.html"},{default:r(()=>[g]),_:1}),t(" in the code, but that detail is irrelevant here). The pointer to the STORMM topology, which may be stored in the object as a way to trace the original inputs used to create / calculate its contents, is only valid for the CPU, and therefore doesn't become part of the abstract. Each of the "),y,t(" arrays, however, hold valid pointers to data on the CPU host as well as on the GPU device, so the abstract is created based on a choice of whether pointers should be directed towwards data on either resource to facilitate computations there. The "),b,t(" also contains a tuple of three extra parameters, i.e. three "),v,t(" values, which are included in the abstract as constants. The abstract is a key to the data in the "),w,t("--if the values of the tuple are changing over time, the convention in most STORMM classes is to have the abstract be a snapshot of the class at any given time, with "),_,t(" qualifiers on such values to treat them as constants.")]),C,T])}const P=a(d,[["render",k],["__file","dev-philosophy.html.vue"]]),G=JSON.parse('{"path":"/dev-philosophy.html","title":"The STORMM View of Coding for Molecular Science","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"Keep Dependencies Minimal","slug":"keep-dependencies-minimal","link":"#keep-dependencies-minimal","children":[]},{"level":2,"title":"C++ to C, and then to CUDA","slug":"c-to-c-and-then-to-cuda","link":"#c-to-c-and-then-to-cuda","children":[]},{"level":2,"title":"The Synthesis: Not Just an Array of Topologies or Coordinate Sets","slug":"the-synthesis-not-just-an-array-of-topologies-or-coordinate-sets","link":"#the-synthesis-not-just-an-array-of-topologies-or-coordinate-sets","children":[]}],"git":{"updatedTime":1747640046000},"filePathRelative":"dev-philosophy.md"}');export{P as comp,G as data};
