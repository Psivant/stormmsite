import{_ as t,c as a,o as n,a as e,d as o}from"./app-BkfPAuxt.js";const s={},i=e("h1",{id:"the-molecular-mechanics-workbench-creating-and-unpacking-stormm-s-topologies-and-coordinates",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#the-molecular-mechanics-workbench-creating-and-unpacking-stormm-s-topologies-and-coordinates"},[e("span",null,"The Molecular Mechanics Workbench: Creating and Unpacking STORMM's Topologies and Coordinates")])],-1),r=e("p",null,[o("Memory management, class conventions, and input mechanisms are essential preconditions for a programming environment that supports GPU programming, but the purpose of STORMM is to collect many molecular systems into a single program instance and have them communicate where helpful or subdivide into some common denominator of work units to stack problems together when the goal is to optimize GPU utilization. First, we will need a toopology class, which in STORMM is the "),e("code",null,"AtomGraph"),o(". Second, we require a means for storing structures, and also perhaps atomic velocities and force accumulators, and for that STORMM has several options. "),e("a",{href:"../dev-philosophy#syntheses-not-just-arrays-of-topologies-or-coordinate-sets"},"Topologies and coordinates collate into syntheses"),o(", as described elsewhere on the site.")],-1),c=[i,r];function l(h,d){return n(),a("div",null,c)}const p=t(s,[["render",l],["__file","tutorial_iv.html.vue"]]),u=JSON.parse(`{"path":"/tutorials/tutorial_iv.html","title":"The Molecular Mechanics Workbench: Creating and Unpacking STORMM's Topologies and Coordinates","lang":"en-US","frontmatter":{},"headers":[],"git":{"updatedTime":1749137539000},"filePathRelative":"tutorials/tutorial_iv.md"}`);export{p as comp,u as data};
