import{_ as i,c as r,b as n,a as e,d as t,e as a,w as s,f as l,o as c}from"./app-BYxB36F3.js";const h="/assets/class_abs-BhVuNlIX.png",d="/assets/synth_layout-BgDqYR0V.png",m={},u=n('<h1 id="the-stormm-view-of-coding-for-molecular-science" tabindex="-1"><a class="header-anchor" href="#the-stormm-view-of-coding-for-molecular-science"><span>The STORMM View of Coding for Molecular Science</span></a></h1><p>Computational science is a practice of applying theory to scientific questions through numerical models and simulations. As such, it is best that scientists who want to develop methods have a connection to the underlying numbers, and this is best achieved with a collection of modular and open-source data structures tailored to the elemental operations of the simulation. For molecular modeling, the basic data structures are molecular topologies and coordinates, but most codes for such computations mount the data in a series of individual arrays and are built for doing one or a set number of such calculations at a time.</p><p>STORMM starts by creating its own unique classes for collecting molecular parameters and coordinates, then makes these first-class C++ classes to take advantage of all functionality in the <a href="https://en.cppreference.com/w/cpp/standard_library" target="_blank" rel="noopener noreferrer">C++ Standard Library</a>: objects of these classes may be used in dynamic array allocation, passed to functions, returned by functions, copied, and named as the developer likes. The next step is to elaborate on the parameters and coordinates with classes to interact with them, enabling simulations, evaluate the textbook chemical structures out of thousands of atoms, and optimize compute-intensive aspects of a simulation.</p><p>For more than a decade, computational science has been transformed by vectorized, general-purpose graphics processors (GPUs). The degree of efficiency afforded by this end point of non-uniform memory access computing is staggering: a single consumer-grade card running on a few hundred watts can perform more calculations than megawatt supercomputers of the past built around single-core or multicore processors. The cards also deliver a much greater degree of parallel scaling: a supercomputer in 2005 might have delieverd as little as 5-10% efficiency on a parallel simulation sprawling over hundreds of processors. A GPU in 2025 may utilize upwards of 50% of its available floating point instructions when propagating the same simulation.</p><p>In the modern computing environment, connecting scientists to the numbers in their calculations also means providing a transparent and simple way to transfer that information to the GPU to support kernels (functions) which carry out the algorithm of interest. GPU programming is difficult due to the nature of finding errors among thousands of threads accessing a single block of memory, designing the information layout so that cache overturn and memory traffic remain at the lowest possible levels, and managing all of the pointers that the kernels need in order to access relevant data. STORMM solves these problems with the style and standards of its C++ classes, letting them produce abstracts of pointers and critical array sizes which can be submitted to GPU kernels with much the same appearance as a function call in a C program. Furthermore, all C++ classes are built on a built-in dynamic memory format which manages allocations on both the GPU device and CPU host, as well as transfers between them. The C++ layer provides a means of organizing data and testing its veracity with minimal obfuscation as might be encountered in something like a Python program. The class abstract convention in STORMM ensures that the algorithms and ideas carry over to the GPU.</p><h2 id="keep-dependencies-minimal" tabindex="-1"><a class="header-anchor" href="#keep-dependencies-minimal"><span>Keep Dependencies Minimal</span></a></h2>',6),p=e("a",{href:"https://developer.nvidia.com/thrust",target:"_blank",rel:"noopener noreferrer"},"NVIDIA's CUDA Thrust",-1),f=e("a",{href:"https://github.com/ROCm/rocThrust",target:"_blank",rel:"noopener noreferrer"},"AMD's RocThrust",-1),g=e("code",null,"Hybrid<T>",-1),y=e("code",null,"Hybrid<T>",-1),_=e("code",null,"TestEnvironment",-1),b=e("h2",{id:"c-to-c-and-then-to-cuda",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#c-to-c-and-then-to-cuda"},[e("span",null,"C++ to C, and then to CUDA")])],-1),w=e("a",{href:"https://developer.nvidia.com/cuda-toolkit",target:"_blank",rel:"noopener noreferrer"},"NVIDIA's CUDA",-1),v=e("code",null,"class",-1),T=e("code",null,"Hybrid<T>",-1),k=e("a",{href:"https://cplusplus.com/reference/vector/vector/",target:"_blank",rel:"noopener noreferrer"},[e("code",null,"std::vector<T>")],-1),C=e("code",null,"struct",-1),S=e("code",null,"class",-1),M=e("code",null,"std::vector<T>",-1),P=e("code",null,".data()",-1),U=e("code",null,".size()",-1),x=e("code",null,"class",-1),A=e("code",null,"struct",-1),G=e("code",null,"struct",-1),R=e("p",null,[e("img",{src:h,alt:"ClassAbstracting"})],-1),j=e("code",null,"Hybrid",-1),O=e("code",null,"int",-1),I=e("code",null,"double",-1),z=e("code",null,"AtomGraph",-1),D=e("code",null,"Hybrid",-1),N=e("code",null,"StormmClass",-1),V=e("code",null,"double",-1),F=e("code",null,"class",-1),H=e("code",null,"const",-1),q=e("h2",{id:"syntheses-not-just-arrays-of-topologies-or-coordinate-sets",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#syntheses-not-just-arrays-of-topologies-or-coordinate-sets"},[e("span",null,"Syntheses: Not Just Arrays of Topologies or Coordinate Sets")])],-1),B=e("code",null,"Hybrid<T>",-1),E=e("code",null,"double",-1),K=e("code",null,"char",-1),L=e("code",null,"unsigned int",-1),J=e("em",null,"storing",-1),W=e("em",null,"synthesis",-1),X=e("em",null,"x",-1),Y=e("code",null,"AtomGraphSynthesis",-1),Q=e("code",null,"PhaseSpaceSynthesis",-1),Z=n('<p><img src="'+d+'" alt="Synthesis Distinction"></p><p>Above, a series of molecular coordinate objects is first arranged in a traditional array. It could be a <code>std::vector&lt;Coordinates&gt;</code>, but this would be cumbersome to port data to and from the GPU for reasons already mentioned. The essential elements are the allocated data for the array elements, the sub-allocations for atomic positions within each coordinate object, and the number of molecular systems in the array. In contrast, the synthesis of such systems arranges all Cartesian <em>x</em>, <em>y</em>, and <em>z</em> coordinates into their own arrays, and might store an additional array of tuples containing the first and final array elements at which to find the positions of atoms in each system. The number of systems <em>K</em>, dictating the length of the bounds array, is likewise stored. While the above example reduces the number of pointers three-fold, in principle any number of systems&#39; coordinates can be stored in a synthesis of the same format, whereas the array of coordinate objects continues to required 3<em>K</em> + 1 pointers.</p>',2);function $(ee,te){const o=l("RouteLink");return c(),r("div",null,[u,e("p",null,[t("STORMM's compilation is fast and robust due to careful construction of the CMake scripts and a low dependence on external software packages. Planning for compatibility in trajectories that it will write and other data it might store, STORMM compiles with NetCDF. For speed in CPU computations as well as versatility in a fundamental mathematical operation STORMM compiles with PocketFFT. Otherwise, rather than bring in "),p,t(" or "),f,t(", STORMM uses its own "),a(o,{to:"/doxygen/hybrid_8h_source.html"},{default:s(()=>[g]),_:1}),t(" dynamic memory class to manage corresponding data on the CPU host and the GPU device. Features of the "),y,t(" class are entwined with exception handling to expedite backtracing. Another built-in dependency bypass is the unit testing library, including the "),a(o,{to:"/doxygen/classstormm_1_1testing_1_1TestEnvironment.html"},{default:s(()=>[_]),_:1}),t(" class which rolls together customizable command line input with runtime success and failure tallies as well as test summary output. The testing functions replicate the essential features of popular unit testing packages with specializations for the sorts of computations common to computational chemistry. Having all of these features rolled into a single code base also presents developers with a unified resource, the "),a(o,{to:"/doxygen/"},{default:s(()=>[t("STORMM doxygen documentation")]),_:1}),t(", to delve through when looking for particular methods and data structures.")]),b,e("p",null,[t("STORMM is built to run "),w,t(" for the time being, although the code is prepared for a transition to some agnostic state with respect to the high-performance computing language in the future. The workflow for porting a new algorithm or memory structure to the GPU is illustrated in the following diagram. Starting with a C++ "),v,t(" containing data in "),a(o,{to:"/doxygen/hybrid_8h_source.html"},{default:s(()=>[T]),_:1}),t(" dynamically allocated arrays (as opposed to the C++ Standard Template Library "),k,t(" dynamic memory allocation system), a class method is written to return a "),C,t(" containing critical array size constants and pointers to the relevant memory. If the "),S,t(" contained "),M,t(" arrays for its memory, a set of pointers to each array's "),P,t(" member variable and constants for its "),U,t(" would, in effect, allow the developer to traverse the "),x,t(" object's data as if it were a C "),A,t(" object. In STORMM, there is an additional choice to make: while the size of any given array will be the same on the CPU or on the GPU, the pointers can refer to data on the CPU host or on the GPU device. The developer can still traverse the host-side data as if it were a C "),G,t(", but also take the abstract with pointers to memory on the device and traverse it with C-like CUDA.")]),R,e("p",null,[t("In the above diagram, a hypothetical STORMM class contains five "),j,t(" arrays in two different data types, e.g. "),O,t(" and "),I,t(". It also contains a pointer to another object of the STORMM topology type (this is called "),a(o,{to:"/doxygen/classstormm_1_1topology_1_1AtomGraph.html"},{default:s(()=>[z]),_:1}),t(" in the code, but that detail is irrelevant here), as a way to trace the original inputs used to create / calculate its contents. This pointer is only valid for the CPU, and therefore doesn't become part of the abstract. Each of the "),D,t(" arrays, however, hold valid pointers to data on the CPU host as well as on the GPU device, so the abstract is created based on a choice of whether pointers should be directed towards data on either resource to facilitate computations there. The "),N,t(" also contains a tuple of three extra parameters, i.e. three "),V,t(" values, which are included in the abstract as constants. The abstract is a key to the data in the "),F,t("--if the values of the tuple are changing over time, the convention in most STORMM classes is to have the abstract be a snapshot of the class at any given time, with "),H,t(" qualifiers on such values to treat them as constants.")]),q,e("p",null,[t("It's easy to think that the way to stage multiple problems on the GPU is to create arrays of the basic "),a(o,{to:"/doxygen/classstormm_1_1topology_1_1AtomGraph.html"},{default:s(()=>[t("AtomGraph")]),_:1}),t(" topology or "),a(o,{to:"/doxygen/classstormm_1_1trajectory_1_1PhaseSpace.html"},{default:s(()=>[t("PhaseSpace")]),_:1}),t(" coordinate and force-holding objects. However, this is bad for two reasons: first, for engineering safety, the "),B,t(" data type is restricted to various elemental data types, e.g. "),E,t(", "),K,t(", or "),L,t(". It cannot be used to create an array of topologies or coordinate objects, and even if it was then there would be host- and device-level pointers to the host- and device-level elements of each topology or coordinate set in the list, which would only be valid if accessed in particular ways. A more mundane form of pointer acrobatics gives rise to the second, performance-centric reason: a list of objects with their own sub-arrays would require threads in a GPU kernel to de-reference the list pointer and then the array pointers of the underlying objects. A list of abstracts would do no better. It's a cost to de-reference a pointer, which is why optimized codes like to get into an array and then go straight down all of its elements to utilize all of the vectorization the chip can muster. In C++ code, it's easy enough to store a temporary pointer to the location of interest and cut through a series of pointers in that manner, but "),J,t(" a temporary pointer exacts a cost in registers which are in short supply on the GPU (this, more than cache rationing, is perhaps the most significant distinction in GPU program optimization). The GPU should be directed to as few arrays as possible, and a always given means of striding through them from start to finish.")]),e("p",null,[t("A "),W,t(" of topologies or coordinates is therefore a new class which has similar numbers of member variables to the corresponding classes for a single system, but collates all systems' data of a particular type, e.g. all "),X,t(" coordinates or all atomic partial charges, into a single array. Padding is applied between systems to ensure that one warp accessing the data will read a single cache line. The synthesis of topologies, "),a(o,{to:"/doxygen/classstormm_1_1synthesis_1_1AtomGraphSynthesis.html"},{default:s(()=>[Y]),_:1}),t(", stores a series of integer markers to indicate where each system's details start and stop, as does the coordinate synthesis, the "),a(o,{to:"/doxygen/classstormm_1_1synthesis_1_1PhaseSpaceSynthesis.html"},{default:s(()=>[Q]),_:1}),t(". The arrangement, and the contrast between a synthesis and an array of objects, is illustrated in the following diagram:")]),Z])}const ae=i(m,[["render",$],["__file","dev-philosophy.html.vue"]]),se=JSON.parse('{"path":"/dev-philosophy.html","title":"The STORMM View of Coding for Molecular Science","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"Keep Dependencies Minimal","slug":"keep-dependencies-minimal","link":"#keep-dependencies-minimal","children":[]},{"level":2,"title":"C++ to C, and then to CUDA","slug":"c-to-c-and-then-to-cuda","link":"#c-to-c-and-then-to-cuda","children":[]},{"level":2,"title":"Syntheses: Not Just Arrays of Topologies or Coordinate Sets","slug":"syntheses-not-just-arrays-of-topologies-or-coordinate-sets","link":"#syntheses-not-just-arrays-of-topologies-or-coordinate-sets","children":[]}],"git":{"updatedTime":1747937135000},"filePathRelative":"dev-philosophy.md"}');export{ae as comp,se as data};
