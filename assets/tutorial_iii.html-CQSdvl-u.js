import{_ as o,c as l,b as a,a as e,d as s,e as t,w as i,f as r,o as d}from"./app-CQW7U6ok.js";const c={},u=a('<h1 id="creating-your-own-input-blocks" tabindex="-1"><a class="header-anchor" href="#creating-your-own-input-blocks"><span>Creating Your Own Input Blocks</span></a></h1><p>With few exceptions, creating custom programs, or modifying existing programs, requires the developer to create input options for the user to control new features. STORMM uses a native C++ emulator for Fortran-like namelists, allowing it to read input files that look much like those of the AMBER molecular dynamics engines <strong>sander</strong> and <strong>pmemd</strong>. The namelist syntax in STORMM is enhanced, allowing users to forego <code>=</code> signs and commas: <code>keyword_a = value_a, keyword_b = value_b</code> is interpreted in the same way as <code>keyword_a value_a keyword_b value_b</code>, although a comma would help for legibility. STORMM also lets the developer specify keywords to take <code>STRUCT</code> inputs, signified by brace characters before and after a list of sub-key entries, e.g. <code>composite_a = { -part_i value_i, -part_ii value_ii, -part_iv value_iv }</code> with sub-keys being optional or required at the developer&#39;s discretion. Furthermore, STORMM lets the developer stipulate whether a keyword will accept multiple entries. In this tutorial, we will explore how to make a custom input block and give the user a pathway to feeding information into programs written with STORMM.</p><h2 id="the-method" tabindex="-1"><a class="header-anchor" href="#the-method"><span>The Method</span></a></h2><p>There are three major steps to passing user input into STORMM, each requiring C++ code of moderate density.</p>',4),m=e("code",null,"NamelistEmulator",-1),p=e("li",null,[s("Run a file stream by that "),e("code",null,"NamelistEmulator"),s(" object to load it up user input directives")],-1),h=e("code",null,"NamelistEmulator",-1),v=e("code",null,"&dynamics",-1),g=e("code",null,"&precision",-1),b=e("code",null,"DynamicsControls",-1),f=e("code",null,"PrecisionControls",-1),_=e("code",null,"NamelistEmulator",-1),w=e("code",null,"TextFile",-1),y=e("code",null,"NamelistEmulator",-1),k=e("code",null,"NamelistEmulator",-1),x=e("code",null,"readNamelist",-1),T=e("code",null,"NamelistEmulator",-1),q=e("code",null,"NamelistEmulator",-1),N=a(`<div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">#include &quot;/stormm/home/src/Namelists/namelist_emulator.h&quot;</span>
<span class="line">#include &quot;/stormm/home/src/Parsing/textfile.h&quot;</span>
<span class="line"></span>
<span class="line">using stormm::namelist::NamelistEmulator;</span>
<span class="line"></span>
<span class="line">NamelistEmulator starInput(const TextFile &amp;input_ascii_text);</span>
<span class="line"></span>
<span class="line">class StarControls() {</span>
<span class="line">public:</span>
<span class="line">  StarControls(const TextFile &amp;input_ascii_text);</span>
<span class="line"></span>
<span class="line">  int getPlanetCount() const;</span>
<span class="line">  double getMass() const;</span>
<span class="line">  double getBrightness() const;</span>
<span class="line">  </span>
<span class="line">private:</span>
<span class="line">  int planet_count;   // Number of planets in orbit</span>
<span class="line">  double mass;        // Mass in units of solar masses</span>
<span class="line">  double brightness;  // Brightness expressed in apparent magnitude</span>
<span class="line">};</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>In the example above, which will be expanded in the Tutorial III program, the namelist <code>&amp;star</code> is configured into a <code>NamelistEmulator</code> by the <code>starInput</code> function. The contents of that function, which again accomplishes the first and second stages of the overall process, could be:</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">#include &quot;/stormm/home/src/Constants/behavior.h&quot;</span>
<span class="line">#include &quot;/stormm/home/src/Namelists/input.h&quot;</span>
<span class="line">#include &quot;/stormm/home/src/Namelists/namelist_enumerators.h&quot;</span>
<span class="line">#include &quot;/stormm/home/src/Parse/parsing_enumerators.h&quot;</span>
<span class="line"></span>
<span class="line">using stormm::constants::ExceptionResponse;</span>
<span class="line">using stormm::constants::CaseSensitivity;</span>
<span class="line">using stormm::namelist::NamelistType;</span>
<span class="line">using stormm::parse::WrapTextSearch;</span>
<span class="line"></span>
<span class="line">NamelistEmulator starInput(const TextFile &amp;input_ascii_text) {</span>
<span class="line">  NamelistEmulator result(&quot;star&quot;, CaseSensitivity::YES, ExceptionResponse::DIE, &quot;Accepts data &quot;</span>
<span class="line">                          &quot;entry for a star in the sky&quot;);</span>
<span class="line">  result.addKeyword(&quot;planets&quot;, NamelistType::INTEGER, std::to_string(8));</span>
<span class="line">  result.addKeyword(&quot;mass&quot;, NamelistType::REAL, std::to_string(1.0));</span>
<span class="line">  result.addKeyword(&quot;brightness&quot;, NamelistType::REAL, std::to_string(-26.74));</span>
<span class="line">  int start_line = 0;</span>
<span class="line">  readNamelist(input_ascii_text, &amp;result, &amp;start_line, WrapTextSearch::YES, tf.getLineCount());</span>
<span class="line">  return result;</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The <code>starInput</code> function carried out the laborious task of sifting through the entire input file, or a portion of its lines if we had some intelligent way to put limits on the range. This converted the potentially large block of character input into a developer-defined collection of keyword-value pairs. It is incorporated into the <code>StarControls</code> class constructor to carry out, once, the relatively strenuous task of sifting through the keyword-value pairs to find the appropriate values needed by the program based on their keywords. Its abridged contents might be:</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">StarControls::StarControls(const TextFile &amp;input_ascii_text) :</span>
<span class="line">    planet_count{0}, mass{1.0}, brightness{1.0}</span>
<span class="line">{</span>
<span class="line">  NamelistEmulator t_nml = starInput(input_ascii_text);</span>
<span class="line">  t_nml.assignVariable(&amp;planet_count, &quot;planets&quot;);</span>
<span class="line">  t_nml.assignVariable(&amp;mass, &quot;mass&quot;);</span>
<span class="line">  t_nml.assignVariable(&amp;brightness, &quot;brightness&quot;);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Once the <code>StarControls</code> class object is constructed, getting the number of planets around a star no longer requires a series of string comparisons against every keyword in the <code>&amp;star</code> namelist, it can be retrieved by a single call to the <code>StarControls::getPlanetCount()</code> accessor function (the contents of which were not written out above, but should be obvious). The <code>NamelistEmulator</code> methods such as <code>assignVariable</code> and <code>addKeyword</code> come with many overloads to give developers freedom in organizing the keywords and their associated descriptions. In a real application, there might be more than a dozen keywords in the new input block. Configuring the <code>NamelistEmulator</code> and unpacking it in this way will comprise the bulk of the code to write, and is intended to be as script-like as possible.</p><h2 id="displaying-keyword-documentation" tabindex="-1"><a class="header-anchor" href="#displaying-keyword-documentation"><span>Displaying Keyword Documentation</span></a></h2><p>In addition to the means for developing new namelists, STORMM has a way to give each program a user manual with an interactive display through the command line. With this system, running the program with no arguments or with <code>--help</code> and variations thereof will produce a summary of the program&#39;s declared purpose and a list of namelist conntrol block titles, with their own provided descriptions, in the terminal window. Running the program with the title of one of the applicable namelists as the command line argument will produce a table of keywords in the namelist, complete with data types, default values, and descriptions. All of this is done by accessing the configured <code>NamelistEmulator</code>, and works with many of the same methods used to display namelist contents and input choices when printing a report file at the end of a run.</p><h2 id="the-command-line-is-a-namelist-too" tabindex="-1"><a class="header-anchor" href="#the-command-line-is-a-namelist-too"><span>The Command Line is a Namelist, Too!</span></a></h2>`,9),E=e("code",null,"CommandLineParser",-1),C=e("code",null,"NamelistEmulator",-1);function S(M,R){const n=r("RouteLink");return d(),l("div",null,[u,e("ul",null,[e("li",null,[s("Establish a new "),t(n,{to:"/doxygen/classstormm_1_1namelist_1_1NamelistEmulator.html"},{default:i(()=>[m]),_:1}),s(" class object.")]),p,e("li",null,[s("Write an original class to offload information from the "),h,s(" and digest it for the rest of the program The third step is not essential, but in general is a good idea to streamline the extraction of information from a general-purpose format (where each access requires interpreting, checking, and comparing a character string) to an application-specific dispenser. STORMM also comes with a number of modular namelists, e.g. "),v,s(" and "),g,s(", which can be included in programs from the main libraries. Each of these native input blocks comes with its own unique class to digest the user's input by the strategy above, e.g. "),t(n,{to:"/doxygen/classstormm_1_1namelist_1_1DynamicsControls.html"},{default:i(()=>[b]),_:1}),s(" or "),t(n,{to:"/doxygen/classstormm_1_1namelist_1_1PrecisionControls.html"},{default:i(()=>[f]),_:1})])]),e("p",null,[s("The preferred route is to make a function to configure the "),_,s(" with input elements, and have that function take the user input file or a "),t(n,{to:"/doxygen/classstormm_1_1parse_1_1TextFile.html"},{default:i(()=>[w]),_:1}),s(" class object that has already loaded the input text into memory. The bulk of this function will involve configuring the "),y,s(" with keywords, defaults and help messages. Before returning the "),k,s(" object, the function will load it up using the "),t(n,{to:"/doxygen/input_8h_source.html"},{default:i(()=>[x]),_:1}),s(" function. Again, this will search for keywords in an ascii text file to convert the user input into a general-purpose dispenser which can then dispense the information by issuing queries based on those keywords. The function that manages configuration and loading of the "),T,s(" object for a given control block will be called by the class constructor for the application-specific class which further digests information in the "),q,s(" to make the user input available through specific accessor functions. An abbreviated protocol is written below:")]),N,e("p",null,[s("The first place STORMM programs take in user information isn't the input file, though: it's the command line. Command line arguments need documentation as well, and to address this need, STORMM bundles all of the character strings passed in from the command line and bundles them as if they were the contents of a namelist. This is done using the "),t(n,{to:"/doxygen/classstormm_1_1namelist_1_1CommandLineParser.html"},{default:i(()=>[E]),_:1}),s(" class, which includes among its members a "),C,s(" and a collection of common keywords (with descriptions) that a developer can add as command line arguments by including them in the constructor call. The developer may add original command line arguments by reaching into the parser to edit the namelist stored inside, and even have the parser coordinate with other classes which look to the command line for information so as not to have keyword collisions or raise exceptions when one parser doesn't recognize a keyword to be used by another.")])])}const O=o(c,[["render",S],["__file","tutorial_iii.html.vue"]]),j=JSON.parse('{"path":"/tutorials/tutorial_iii.html","title":"Creating Your Own Input Blocks","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"The Method","slug":"the-method","link":"#the-method","children":[]},{"level":2,"title":"Displaying Keyword Documentation","slug":"displaying-keyword-documentation","link":"#displaying-keyword-documentation","children":[]},{"level":2,"title":"The Command Line is a Namelist, Too!","slug":"the-command-line-is-a-namelist-too","link":"#the-command-line-is-a-namelist-too","children":[]}],"git":{"updatedTime":1749452686000},"filePathRelative":"tutorials/tutorial_iii.md"}');export{O as comp,j as data};
