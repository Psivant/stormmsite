<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>STORMM Source Documentation: stormm::energy::LogScaleSpline&lt; T4 &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">STORMM Source Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>stormm</b></li><li class="navelem"><b>energy</b></li><li class="navelem"><a class="el" href="classstormm_1_1energy_1_1LogScaleSpline.html">LogScaleSpline</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classstormm_1_1energy_1_1LogScaleSpline-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">stormm::energy::LogScaleSpline&lt; T4 &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A logarithmic spline can be very useful for interpolating functions that are steepest at low values of the argument, provided that the argument is never negative. This is a useful class of functions for describing inter-atomic potentials. The strategy is to utilize the logarithmic nature (and IEEE format) of a floating point number, taking the highest N bits of the mantissa and the exponent as an unsigned integer (because measurements of absolute distance will never be negative, the highest bit (the sign bit) will always be set to zero). It is most useful if the square root operation can be avoided altogether, indexing the table by the square of the function argument. This creates a more accurate table as well as saving arithmetic, although obtaining function derivatives (as a function of the argument, not its square) from the table becomes more expensive. In fact, this object abandons continuous derivatives in the tables and instead splines the derivative of the desired function as a separate logarithmic table.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="log__scale__spline_8h_source.html">log_scale_spline.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab04c19393fa4e972bb507e3d80128527" id="r_ab04c19393fa4e972bb507e3d80128527"><td class="memItemLeft" align="right" valign="top"><a id="ab04c19393fa4e972bb507e3d80128527" name="ab04c19393fa4e972bb507e3d80128527"></a>
LogSplineForm&#160;</td><td class="memItemRight" valign="bottom"><b>getForm</b> () const</td></tr>
<tr class="memdesc:ab04c19393fa4e972bb507e3d80128527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the target form of the function represented by the table. <br /></td></tr>
<tr class="separator:ab04c19393fa4e972bb507e3d80128527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3889293556f4352d1e88f856b5d7821" id="r_af3889293556f4352d1e88f856b5d7821"><td class="memItemLeft" align="right" valign="top"><a id="af3889293556f4352d1e88f856b5d7821" name="af3889293556f4352d1e88f856b5d7821"></a>
TableIndexing&#160;</td><td class="memItemRight" valign="bottom"><b>getIndexingMethod</b> () const</td></tr>
<tr class="memdesc:af3889293556f4352d1e88f856b5d7821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the method of indexing the table, an expression based on the target function's argument, e.g. the squared distance. <br /></td></tr>
<tr class="separator:af3889293556f4352d1e88f856b5d7821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a98fc5982a476752ce9cf918fada415" id="r_a6a98fc5982a476752ce9cf918fada415"><td class="memItemLeft" align="right" valign="top"><a id="a6a98fc5982a476752ce9cf918fada415" name="a6a98fc5982a476752ce9cf918fada415"></a>
BasisFunctions&#160;</td><td class="memItemRight" valign="bottom"><b>getBasisSet</b> () const</td></tr>
<tr class="memdesc:a6a98fc5982a476752ce9cf918fada415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the basis functions used to construt each spline. <br /></td></tr>
<tr class="separator:a6a98fc5982a476752ce9cf918fada415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62c0b2f9c62b2a3fed90b93c002987c6" id="r_a62c0b2f9c62b2a3fed90b93c002987c6"><td class="memItemLeft" align="right" valign="top"><a id="a62c0b2f9c62b2a3fed90b93c002987c6" name="a62c0b2f9c62b2a3fed90b93c002987c6"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getBitStride</b> () const</td></tr>
<tr class="memdesc:a62c0b2f9c62b2a3fed90b93c002987c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of leading bits in the mantissa used to determine the array index. <br /></td></tr>
<tr class="separator:a62c0b2f9c62b2a3fed90b93c002987c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab32ea6f230e88e554f4d8d2578424d05" id="r_ab32ea6f230e88e554f4d8d2578424d05"><td class="memItemLeft" align="right" valign="top"><a id="ab32ea6f230e88e554f4d8d2578424d05" name="ab32ea6f230e88e554f4d8d2578424d05"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getSplineDensity</b> () const</td></tr>
<tr class="memdesc:ab32ea6f230e88e554f4d8d2578424d05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of spline segments per stride. This is two raised to the power of the result of <a class="el" href="classstormm_1_1stmath_1_1LogScaleSpline.html#a62c0b2f9c62b2a3fed90b93c002987c6" title="Get the number of leading bits in the mantissa used to determine the array index.">getBitStride()</a>. <br /></td></tr>
<tr class="separator:ab32ea6f230e88e554f4d8d2578424d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee2af30d960702ba85fa3c7a63366a0" id="r_a1ee2af30d960702ba85fa3c7a63366a0"><td class="memItemLeft" align="right" valign="top"><a id="a1ee2af30d960702ba85fa3c7a63366a0" name="a1ee2af30d960702ba85fa3c7a63366a0"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getEwaldCoefficient</b> () const</td></tr>
<tr class="memdesc:a1ee2af30d960702ba85fa3c7a63366a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Ewald coefficient in use for this spline table. A check will be made to ensure that the spline is of the proper type to have a valid Ewald coefficient. <br /></td></tr>
<tr class="separator:a1ee2af30d960702ba85fa3c7a63366a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0f0122ab3e9cd33cedeccd83c9ea72" id="r_aff0f0122ab3e9cd33cedeccd83c9ea72"><td class="memItemLeft" align="right" valign="top"><a id="aff0f0122ab3e9cd33cedeccd83c9ea72" name="aff0f0122ab3e9cd33cedeccd83c9ea72"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getCoulombConstant</b> () const</td></tr>
<tr class="memdesc:aff0f0122ab3e9cd33cedeccd83c9ea72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of Coulomb's constant in use by the spline. A check will be made to ensure that the spline is of the proper type to have a valid Coulomb constant. <br /></td></tr>
<tr class="separator:aff0f0122ab3e9cd33cedeccd83c9ea72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8373f3808ef692efb797d948d533f7b3" id="r_a8373f3808ef692efb797d948d533f7b3"><td class="memItemLeft" align="right" valign="top"><a id="a8373f3808ef692efb797d948d533f7b3" name="a8373f3808ef692efb797d948d533f7b3"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getMaximumRange</b> () const</td></tr>
<tr class="memdesc:a8373f3808ef692efb797d948d533f7b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum range of the spline. <br /></td></tr>
<tr class="separator:a8373f3808ef692efb797d948d533f7b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee42da6a19212c155f18356b8c44d6a" id="r_a6ee42da6a19212c155f18356b8c44d6a"><td class="memItemLeft" align="right" valign="top"><a id="a6ee42da6a19212c155f18356b8c44d6a" name="a6ee42da6a19212c155f18356b8c44d6a"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getMinimumRange</b> () const</td></tr>
<tr class="memdesc:a6ee42da6a19212c155f18356b8c44d6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum absolute range of the spline. <br /></td></tr>
<tr class="separator:a6ee42da6a19212c155f18356b8c44d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d516dc7d5286a8862863d43a6274511" id="r_a1d516dc7d5286a8862863d43a6274511"><td class="memItemLeft" align="right" valign="top"><a id="a1d516dc7d5286a8862863d43a6274511" name="a1d516dc7d5286a8862863d43a6274511"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>getIndexingOffset</b> () const</td></tr>
<tr class="memdesc:a1d516dc7d5286a8862863d43a6274511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the indexing offset. <br /></td></tr>
<tr class="separator:a1d516dc7d5286a8862863d43a6274511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f882df0b414d58f27e936ae4b7bc55f" id="r_a3f882df0b414d58f27e936ae4b7bc55f"><td class="memItemLeft" align="right" valign="top"><a id="a3f882df0b414d58f27e936ae4b7bc55f" name="a3f882df0b414d58f27e936ae4b7bc55f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getOptimizationDepth</b> () const</td></tr>
<tr class="memdesc:a3f882df0b414d58f27e936ae4b7bc55f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the optimization depth. <br /></td></tr>
<tr class="separator:a3f882df0b414d58f27e936ae4b7bc55f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af25a0968fb407b55d8aaa4256b5b0413" id="r_af25a0968fb407b55d8aaa4256b5b0413"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af25a0968fb407b55d8aaa4256b5b0413">getSplineIndex</a> (double r) const</td></tr>
<tr class="memdesc:af25a0968fb407b55d8aaa4256b5b0413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the spline index for a particular value of the argument of the tabulated function which has already been transformed to meet the object's indexing system.  <br /></td></tr>
<tr class="separator:af25a0968fb407b55d8aaa4256b5b0413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64fb8bd80916a182f86e2ea1b70503fe" id="r_a64fb8bd80916a182f86e2ea1b70503fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64fb8bd80916a182f86e2ea1b70503fe">getSplineIndexByRealArg</a> (double r) const</td></tr>
<tr class="memdesc:a64fb8bd80916a182f86e2ea1b70503fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the spline index for a particular value of the argument of the tabulated function. Transformation of the input will occur internally based on how the object indexes its internal spline table, in a manner consistent with the object's precision model.  <br /></td></tr>
<tr class="separator:a64fb8bd80916a182f86e2ea1b70503fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f869260b258a5ebc458f7ea9206bdc0" id="r_a6f869260b258a5ebc458f7ea9206bdc0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f869260b258a5ebc458f7ea9206bdc0">interpolateByValue</a> (double r) const</td></tr>
<tr class="memdesc:a6f869260b258a5ebc458f7ea9206bdc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of the underlying function based on a value of the function argument. This accessor will throw a warning or an error if trying to access the a table built to be accessed using the squared value of the function.  <br /></td></tr>
<tr class="separator:a6f869260b258a5ebc458f7ea9206bdc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad831aaf81732b9459329be3d5b197e4d" id="r_ad831aaf81732b9459329be3d5b197e4d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad831aaf81732b9459329be3d5b197e4d">interpolateBySquaredValue</a> (double r2) const</td></tr>
<tr class="memdesc:ad831aaf81732b9459329be3d5b197e4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of the underlying function based on a squared value of the function argument. This accessor will throw a warning or an error if trying to access the a table built to be accessed using the value of the function.  <br /></td></tr>
<tr class="separator:ad831aaf81732b9459329be3d5b197e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943e7bd1c0bee86ca3e2643b73fcd9d5" id="r_a943e7bd1c0bee86ca3e2643b73fcd9d5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a943e7bd1c0bee86ca3e2643b73fcd9d5">evaluate</a> (double r) const</td></tr>
<tr class="memdesc:a943e7bd1c0bee86ca3e2643b73fcd9d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the underlying function represented by the spline at a point expressed in the object's native indexing system (meaning, if the object indexes by the squared argument of the underlying function, then the input will reflect r^2 rather than r).  <br /></td></tr>
<tr class="separator:a943e7bd1c0bee86ca3e2643b73fcd9d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a62d613f912c75bebb0012b406789a8" id="r_a5a62d613f912c75bebb0012b406789a8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a62d613f912c75bebb0012b406789a8">evaluateByRealArg</a> (double r) const</td></tr>
<tr class="memdesc:a5a62d613f912c75bebb0012b406789a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the underlying function represented by the spline at a point on the natural axis of the underlying function. Transformation of this argument will be handled internally, and in a manner that reflects the object's precision model, before returning the result.  <br /></td></tr>
<tr class="separator:a5a62d613f912c75bebb0012b406789a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab14332af86be5cbce1f4c29b9f8902cb" id="r_ab14332af86be5cbce1f4c29b9f8902cb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structstormm_1_1stmath_1_1LogSplineTable.html">LogSplineTable</a>&lt; T4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab14332af86be5cbce1f4c29b9f8902cb">data</a> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:ab14332af86be5cbce1f4c29b9f8902cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the object's abstract for the CPU host or GPU device in either of two precision modes.  <br /></td></tr>
<tr class="separator:ab14332af86be5cbce1f4c29b9f8902cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a844fac5c6616e2410a11cd294191d" id="r_ab7a844fac5c6616e2410a11cd294191d"><td class="memItemLeft" align="right" valign="top"><a id="ab7a844fac5c6616e2410a11cd294191d" name="ab7a844fac5c6616e2410a11cd294191d"></a>
const <a class="el" href="structstormm_1_1stmath_1_1LogSplineTable.html">LogSplineTable</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>templateFreeData</b> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:ab7a844fac5c6616e2410a11cd294191d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the object's abstract with templating removed. <br /></td></tr>
<tr class="separator:ab7a844fac5c6616e2410a11cd294191d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb248377fb3ff08f835d7ce0f3925fc" id="r_accb248377fb3ff08f835d7ce0f3925fc"><td class="memItemLeft" align="right" valign="top"><a id="accb248377fb3ff08f835d7ce0f3925fc" name="accb248377fb3ff08f835d7ce0f3925fc"></a>
const <a class="el" href="classstormm_1_1stmath_1_1LogScaleSpline.html">LogScaleSpline</a>&lt; T4 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>getSelfPointer</b> () const</td></tr>
<tr class="memdesc:accb248377fb3ff08f835d7ce0f3925fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the original object. <br /></td></tr>
<tr class="separator:accb248377fb3ff08f835d7ce0f3925fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2319ccdb019d7238bf118f0d02a69fa2" id="r_a2319ccdb019d7238bf118f0d02a69fa2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2319ccdb019d7238bf118f0d02a69fa2">setMinimumSignificantRange</a> (double min_range_in)</td></tr>
<tr class="memdesc:a2319ccdb019d7238bf118f0d02a69fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the minimum significant range. This is purely for error analysis and will not affect the array indexing or other details of the spline. The value is set to 0.5 at initialization.  <br /></td></tr>
<tr class="separator:a2319ccdb019d7238bf118f0d02a69fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac83a996aa660acbb3a0dc680b3e45a36" id="r_ac83a996aa660acbb3a0dc680b3e45a36"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac83a996aa660acbb3a0dc680b3e45a36">LogScaleSpline</a> (LogSplineForm target_form_in, double ewald_coefficient_in, double coulomb_constant_in=amber_ancient_bioq, int mantissa_bits_in=default_logtab_mantissa_bits, double max_range_in=default_logtab_max_range, double min_range_in=default_logtab_min_range, TableIndexing indexing_method_in=TableIndexing::SQUARED_ARG, BasisFunctions basis_set_in=BasisFunctions::POLYNOMIAL, int ulp_optimization_depth_in=2, float indexing_offset_in=0.0, ExceptionResponse policy=ExceptionResponse::DIE)</td></tr>
<tr class="memdesc:ac83a996aa660acbb3a0dc680b3e45a36"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructor needs an indication of the functional form to render. The number of bits will be decided by the data type if not indicated by the developer. Interpolation is fixed at cubic, for simplicity and speed. Additional input may be used to specify a particular function to spline.  <br /></td></tr>
<tr class="separator:ac83a996aa660acbb3a0dc680b3e45a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30704fe94ee6ca067a65c294e52e381" id="r_ab30704fe94ee6ca067a65c294e52e381"><td class="memItemLeft" align="right" valign="top"><a id="ab30704fe94ee6ca067a65c294e52e381" name="ab30704fe94ee6ca067a65c294e52e381"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>LogScaleSpline</b> (LogSplineForm target_form_in, const std::vector&lt; std::vector&lt; <a class="el" href="structstormm_1_1data__types_1_1double2.html">double2</a> &gt; &gt; &amp;custom_form_in, int mantissa_bits_in=default_logtab_mantissa_bits, double max_range_in=default_logtab_max_range, double min_range_in=default_logtab_min_range, TableIndexing indexing_method_in=TableIndexing::SQUARED_ARG, BasisFunctions basis_set_in=BasisFunctions::POLYNOMIAL, int ulp_optimization_depth_in=2, float indexing_offset_in=0.0, ExceptionResponse policy=ExceptionResponse::WARN)</td></tr>
<tr class="separator:ab30704fe94ee6ca067a65c294e52e381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aca3210e9cd6d27b44cfed37d2977c9ef" id="r_aca3210e9cd6d27b44cfed37d2977c9ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca3210e9cd6d27b44cfed37d2977c9ef">LogScaleSpline</a> (const <a class="el" href="classstormm_1_1stmath_1_1LogScaleSpline.html">LogScaleSpline</a> &amp;original)=default</td></tr>
<tr class="memdesc:aca3210e9cd6d27b44cfed37d2977c9ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">With no pointers to repair and no const members, the default copy and move constructors as well as assignment operators are all valid.  <br /></td></tr>
<tr class="separator:aca3210e9cd6d27b44cfed37d2977c9ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30e86dd6968ed6cf9dd48671ab3b3fa5" id="r_a30e86dd6968ed6cf9dd48671ab3b3fa5"><td class="memItemLeft" align="right" valign="top"><a id="a30e86dd6968ed6cf9dd48671ab3b3fa5" name="a30e86dd6968ed6cf9dd48671ab3b3fa5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>LogScaleSpline</b> (<a class="el" href="classstormm_1_1stmath_1_1LogScaleSpline.html">LogScaleSpline</a> &amp;&amp;original)=default</td></tr>
<tr class="separator:a30e86dd6968ed6cf9dd48671ab3b3fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1bd8145189fe70aaecd809827033663" id="r_af1bd8145189fe70aaecd809827033663"><td class="memItemLeft" align="right" valign="top"><a id="af1bd8145189fe70aaecd809827033663" name="af1bd8145189fe70aaecd809827033663"></a>
<a class="el" href="classstormm_1_1stmath_1_1LogScaleSpline.html">LogScaleSpline</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classstormm_1_1stmath_1_1LogScaleSpline.html">LogScaleSpline</a> &amp;original)=default</td></tr>
<tr class="separator:af1bd8145189fe70aaecd809827033663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f9463c054e2a23db36ce0787d9c12c" id="r_a51f9463c054e2a23db36ce0787d9c12c"><td class="memItemLeft" align="right" valign="top"><a id="a51f9463c054e2a23db36ce0787d9c12c" name="a51f9463c054e2a23db36ce0787d9c12c"></a>
<a class="el" href="classstormm_1_1stmath_1_1LogScaleSpline.html">LogScaleSpline</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classstormm_1_1stmath_1_1LogScaleSpline.html">LogScaleSpline</a> &amp;&amp;original)=default</td></tr>
<tr class="separator:a51f9463c054e2a23db36ce0787d9c12c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a7ee276f2ffb0779a054a954ab0eb2aec" id="r_a7ee276f2ffb0779a054a954ab0eb2aec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstormm_1_1data__types_1_1double3.html">double3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ee276f2ffb0779a054a954ab0eb2aec">getErrorEstimate</a> () const</td></tr>
<tr class="memdesc:a7ee276f2ffb0779a054a954ab0eb2aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the estimated error as a function of the distance at which the splines are evaluated. Mean error is returned in the "x" member of the tuple while standard deviation about the mean error is given in the "y" member of the tuple. The maximum and error value is returned in the tuple's "z" member.  <br /></td></tr>
<tr class="separator:a7ee276f2ffb0779a054a954ab0eb2aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90bebcebfde533edad811d1015e89694" id="r_a90bebcebfde533edad811d1015e89694"><td class="memItemLeft" align="right" valign="top"><a id="a90bebcebfde533edad811d1015e89694" name="a90bebcebfde533edad811d1015e89694"></a>
<a class="el" href="structstormm_1_1data__types_1_1double3.html">double3</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getErrorEstimate</b> (double r) const</td></tr>
<tr class="separator:a90bebcebfde533edad811d1015e89694"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T4&gt;<br />
class stormm::energy::LogScaleSpline&lt; T4 &gt;</div><p>A logarithmic spline can be very useful for interpolating functions that are steepest at low values of the argument, provided that the argument is never negative. This is a useful class of functions for describing inter-atomic potentials. The strategy is to utilize the logarithmic nature (and IEEE format) of a floating point number, taking the highest N bits of the mantissa and the exponent as an unsigned integer (because measurements of absolute distance will never be negative, the highest bit (the sign bit) will always be set to zero). It is most useful if the square root operation can be avoided altogether, indexing the table by the square of the function argument. This creates a more accurate table as well as saving arithmetic, although obtaining function derivatives (as a function of the argument, not its square) from the table becomes more expensive. In fact, this object abandons continuous derivatives in the tables and instead splines the derivative of the desired function as a separate logarithmic table. </p>
<p>The process generates 2^N spline segments in the ranges [0, 2^-k), [2^-k, 2^(1-k)), [2^(1-k), 2^(2-k)), and so on for all k representable by floating point format's exponent. For N=5, there are 32 spline segments covering the ranges [1/4, 1/2), [1/2, 1), [1, 2), [2, 4), and so on. While a great deal of the table is spent covering infinitesimal increments over very negative powers of 2, the quantity of such numbers is limited by the size of the exponent (256 for 32-bit floats and 2048 for 64-bit floats in IEEE format), and these values are hardly ever accessed. For N = 5 in 32-bit floats, the cubic spline coefficients occupy 128kB of space, of which splines to cover the range [0.5, 16.0) occupy 2.5kB. For N = 8 in 64-bit floats, the cubic spline coefficients occupy 8MB of space and splines to cover the range [0.5, 16.0) occupy 40kB. The latter may be of use on CPU resources with higher cache, or in GPU contexts where caching can be well managed, but the former is quite useful in many GPU cases. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac83a996aa660acbb3a0dc680b3e45a36" name="ac83a996aa660acbb3a0dc680b3e45a36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac83a996aa660acbb3a0dc680b3e45a36">&#9670;&#160;</a></span>LogScaleSpline() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstormm_1_1stmath_1_1LogScaleSpline.html">stormm::stmath::LogScaleSpline</a>&lt; T4 &gt;::LogScaleSpline </td>
          <td>(</td>
          <td class="paramtype">LogSplineForm</td>          <td class="paramname"><span class="paramname"><em>target_form_in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>ewald_coefficient_in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>coulomb_constant_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">amber_ancient_bioq</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>mantissa_bits_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">default_logtab_mantissa_bits</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>max_range_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">default_logtab_max_range</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>min_range_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">default_logtab_min_range</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TableIndexing</td>          <td class="paramname"><span class="paramname"><em>indexing_method_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">TableIndexing::SQUARED_ARG</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BasisFunctions</td>          <td class="paramname"><span class="paramname"><em>basis_set_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">BasisFunctions::POLYNOMIAL</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ulp_optimization_depth_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">2</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>indexing_offset_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExceptionResponse</td>          <td class="paramname"><span class="paramname"><em>policy</em></span><span class="paramdefsep"> = </span><span class="paramdefval">ExceptionResponse::DIE</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The constructor needs an indication of the functional form to render. The number of bits will be decided by the data type if not indicated by the developer. Interpolation is fixed at cubic, for simplicity and speed. Additional input may be used to specify a particular function to spline. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">custom_form_in</td><td>If provided, this collection of arrays will provide the known values of the function to be splined (in each tuple's "y" member) and the value of the function argument for which the function is known (in each tuple's "x" member) </td></tr>
    <tr><td class="paramname">max_range_in</td><td>This will translate into the maximum_range member variable, after some checking and refinement </td></tr>
    <tr><td class="paramname">min_range_in</td><td>This will translate into the minimum_absolute_range member variable, after some checking and refinement </td></tr>
    <tr><td class="paramname">policy</td><td>Indicate what to do in the event of bad input, i.e. if custom spline data is not able to fulfill the range requested </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca3210e9cd6d27b44cfed37d2977c9ef" name="aca3210e9cd6d27b44cfed37d2977c9ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca3210e9cd6d27b44cfed37d2977c9ef">&#9670;&#160;</a></span>LogScaleSpline() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstormm_1_1stmath_1_1LogScaleSpline.html">stormm::stmath::LogScaleSpline</a>&lt; T4 &gt;::LogScaleSpline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstormm_1_1stmath_1_1LogScaleSpline.html">LogScaleSpline</a>&lt; T4 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>original</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>With no pointers to repair and no const members, the default copy and move constructors as well as assignment operators are all valid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">original</td><td>The existing object to copy or move </td></tr>
    <tr><td class="paramname">other</td><td>Another object placed on the right hand side of the assignment statement </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab14332af86be5cbce1f4c29b9f8902cb" name="ab14332af86be5cbce1f4c29b9f8902cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab14332af86be5cbce1f4c29b9f8902cb">&#9670;&#160;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structstormm_1_1stmath_1_1LogSplineTable.html">LogSplineTable</a>&lt; T4 &gt; <a class="el" href="classstormm_1_1stmath_1_1LogScaleSpline.html">stormm::stmath::LogScaleSpline</a>&lt; T4 &gt;::data </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the object's abstract for the CPU host or GPU device in either of two precision modes. </p>
<p>tier Indicate whether to retrieve pointers on the GPU device or CPU host </p>

</div>
</div>
<a id="a943e7bd1c0bee86ca3e2643b73fcd9d5" name="a943e7bd1c0bee86ca3e2643b73fcd9d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a943e7bd1c0bee86ca3e2643b73fcd9d5">&#9670;&#160;</a></span>evaluate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classstormm_1_1stmath_1_1LogScaleSpline.html">stormm::stmath::LogScaleSpline</a>&lt; T4 &gt;::evaluate </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the underlying function represented by the spline at a point expressed in the object's native indexing system (meaning, if the object indexes by the squared argument of the underlying function, then the input will reflect r^2 rather than r). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Argument to the underlying function, transformed as appropriate for indexing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a62d613f912c75bebb0012b406789a8" name="a5a62d613f912c75bebb0012b406789a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a62d613f912c75bebb0012b406789a8">&#9670;&#160;</a></span>evaluateByRealArg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classstormm_1_1stmath_1_1LogScaleSpline.html">stormm::stmath::LogScaleSpline</a>&lt; T4 &gt;::evaluateByRealArg </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the underlying function represented by the spline at a point on the natural axis of the underlying function. Transformation of this argument will be handled internally, and in a manner that reflects the object's precision model, before returning the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Argument to the underlying function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ee276f2ffb0779a054a954ab0eb2aec" name="a7ee276f2ffb0779a054a954ab0eb2aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ee276f2ffb0779a054a954ab0eb2aec">&#9670;&#160;</a></span>getErrorEstimate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstormm_1_1data__types_1_1double3.html">double3</a> <a class="el" href="classstormm_1_1stmath_1_1LogScaleSpline.html">stormm::stmath::LogScaleSpline</a>&lt; T4 &gt;::getErrorEstimate </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the estimated error as a function of the distance at which the splines are evaluated. Mean error is returned in the "x" member of the tuple while standard deviation about the mean error is given in the "y" member of the tuple. The maximum and error value is returned in the tuple's "z" member. </p>
<p>Overloaded:</p><ul>
<li>Get the overall error estimate</li>
<li>Get the error estimate for the spline segment comprising a particular value of distance</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The distance of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af25a0968fb407b55d8aaa4256b5b0413" name="af25a0968fb407b55d8aaa4256b5b0413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af25a0968fb407b55d8aaa4256b5b0413">&#9670;&#160;</a></span>getSplineIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classstormm_1_1stmath_1_1LogScaleSpline.html">stormm::stmath::LogScaleSpline</a>&lt; T4 &gt;::getSplineIndex </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the spline index for a particular value of the argument of the tabulated function which has already been transformed to meet the object's indexing system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The argument to the tabulated function. The exact meaning will be interpreted based on the table's internal indexing_method setting. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64fb8bd80916a182f86e2ea1b70503fe" name="a64fb8bd80916a182f86e2ea1b70503fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64fb8bd80916a182f86e2ea1b70503fe">&#9670;&#160;</a></span>getSplineIndexByRealArg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classstormm_1_1stmath_1_1LogScaleSpline.html">stormm::stmath::LogScaleSpline</a>&lt; T4 &gt;::getSplineIndexByRealArg </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the spline index for a particular value of the argument of the tabulated function. Transformation of the input will occur internally based on how the object indexes its internal spline table, in a manner consistent with the object's precision model. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The argument to the tabulated function, expressed on its natural axis </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad831aaf81732b9459329be3d5b197e4d" name="ad831aaf81732b9459329be3d5b197e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad831aaf81732b9459329be3d5b197e4d">&#9670;&#160;</a></span>interpolateBySquaredValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classstormm_1_1stmath_1_1LogScaleSpline.html">stormm::stmath::LogScaleSpline</a>&lt; T4 &gt;::interpolateBySquaredValue </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>r2</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of the underlying function based on a squared value of the function argument. This accessor will throw a warning or an error if trying to access the a table built to be accessed using the value of the function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r2</td><td>The squared value at which to evaluate the underlying function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f869260b258a5ebc458f7ea9206bdc0" name="a6f869260b258a5ebc458f7ea9206bdc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f869260b258a5ebc458f7ea9206bdc0">&#9670;&#160;</a></span>interpolateByValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classstormm_1_1stmath_1_1LogScaleSpline.html">stormm::stmath::LogScaleSpline</a>&lt; T4 &gt;::interpolateByValue </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of the underlying function based on a value of the function argument. This accessor will throw a warning or an error if trying to access the a table built to be accessed using the squared value of the function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The value of at which to evaluate the underlying function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2319ccdb019d7238bf118f0d02a69fa2" name="a2319ccdb019d7238bf118f0d02a69fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2319ccdb019d7238bf118f0d02a69fa2">&#9670;&#160;</a></span>setMinimumSignificantRange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstormm_1_1stmath_1_1LogScaleSpline.html">stormm::stmath::LogScaleSpline</a>&lt; T4 &gt;::setMinimumSignificantRange </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>min_range_in</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the minimum significant range. This is purely for error analysis and will not affect the array indexing or other details of the spline. The value is set to 0.5 at initialization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min_range_in</td><td>The minimum range to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/Math/<a class="el" href="log__scale__spline_8h_source.html">log_scale_spline.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2
</small></address>
</div><!-- doc-content -->
</body>
</html>
