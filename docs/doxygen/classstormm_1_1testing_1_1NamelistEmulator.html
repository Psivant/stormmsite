<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>STORMM Source Documentation: stormm::testing::NamelistEmulator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">STORMM Source Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>stormm</b></li><li class="navelem"><b>testing</b></li><li class="navelem"><a class="el" href="classstormm_1_1testing_1_1NamelistEmulator.html">NamelistEmulator</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classstormm_1_1testing_1_1NamelistEmulator-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">stormm::testing::NamelistEmulator Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Collection of variables to transcribe information contained within a namelist.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="namelist__emulator_8h_source.html">namelist_emulator.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a495ac253a5f50a3d6d1b425932b93c3a" id="r_a495ac253a5f50a3d6d1b425932b93c3a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a495ac253a5f50a3d6d1b425932b93c3a">NamelistEmulator</a> (const std::string &amp;title_in, CaseSensitivity casing_in=CaseSensitivity::AUTOMATIC, ExceptionResponse unknown_keyword_policy=ExceptionResponse::WARN, const std::string &amp;help_in=std::string(&quot;No description provided&quot;), bool cli_content_in=false)</td></tr>
<tr class="memdesc:a495ac253a5f50a3d6d1b425932b93c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an object to emulate Fortran namelist functionality, with improvements.  <br /></td></tr>
<tr class="separator:a495ac253a5f50a3d6d1b425932b93c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fdf50704afcc3fe1ac60136610d2486" id="r_a8fdf50704afcc3fe1ac60136610d2486"><td class="memItemLeft" align="right" valign="top"><a id="a8fdf50704afcc3fe1ac60136610d2486" name="a8fdf50704afcc3fe1ac60136610d2486"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getTitle</b> () const</td></tr>
<tr class="memdesc:a8fdf50704afcc3fe1ac60136610d2486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the title of this namelist (i.e. &amp;cntrl or &amp;dock) <br /></td></tr>
<tr class="separator:a8fdf50704afcc3fe1ac60136610d2486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad92e3629750c869156c0dcf4be20df2e" id="r_ad92e3629750c869156c0dcf4be20df2e"><td class="memItemLeft" align="right" valign="top"><a id="ad92e3629750c869156c0dcf4be20df2e" name="ad92e3629750c869156c0dcf4be20df2e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isCommandLineContent</b> () const</td></tr>
<tr class="memdesc:ad92e3629750c869156c0dcf4be20df2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect whether the namelist emulator serves command-line inputs for a program. <br /></td></tr>
<tr class="separator:ad92e3629750c869156c0dcf4be20df2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14533e588c774f621d403b1bf1bd817" id="r_af14533e588c774f621d403b1bf1bd817"><td class="memItemLeft" align="right" valign="top"><a id="af14533e588c774f621d403b1bf1bd817" name="af14533e588c774f621d403b1bf1bd817"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getKeywordCount</b> () const</td></tr>
<tr class="memdesc:af14533e588c774f621d403b1bf1bd817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the number of parameters catalogged within this namelist emulator. <br /></td></tr>
<tr class="separator:af14533e588c774f621d403b1bf1bd817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae20400b4e96854a3d21eda6552c642e2" id="r_ae20400b4e96854a3d21eda6552c642e2"><td class="memItemLeft" align="right" valign="top"><a id="ae20400b4e96854a3d21eda6552c642e2" name="ae20400b4e96854a3d21eda6552c642e2"></a>
CaseSensitivity&#160;</td><td class="memItemRight" valign="bottom"><b>getCaseSensitivity</b> () const</td></tr>
<tr class="memdesc:ae20400b4e96854a3d21eda6552c642e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the case sensitivity setting for this namelist. <br /></td></tr>
<tr class="separator:ae20400b4e96854a3d21eda6552c642e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ae0ef1fe9d40259ebc7eaf485f3f6d" id="r_ae5ae0ef1fe9d40259ebc7eaf485f3f6d"><td class="memItemLeft" align="right" valign="top"><a id="ae5ae0ef1fe9d40259ebc7eaf485f3f6d" name="ae5ae0ef1fe9d40259ebc7eaf485f3f6d"></a>
ExceptionResponse&#160;</td><td class="memItemRight" valign="bottom"><b>getPolicy</b> () const</td></tr>
<tr class="memdesc:ae5ae0ef1fe9d40259ebc7eaf485f3f6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relay the exception handling policy for this namelist. <br /></td></tr>
<tr class="separator:ae5ae0ef1fe9d40259ebc7eaf485f3f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af79ba492a62c286c9d0fb6a11bfc75da" id="r_af79ba492a62c286c9d0fb6a11bfc75da"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af79ba492a62c286c9d0fb6a11bfc75da">getKeyword</a> (size_t index) const</td></tr>
<tr class="memdesc:af79ba492a62c286c9d0fb6a11bfc75da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a keyword from this namelist based on an index. This is for retrieving the keyword itself, not a value associated with a keyword.  <br /></td></tr>
<tr class="separator:af79ba492a62c286c9d0fb6a11bfc75da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b2788cdf61c64c5f60a94d149c87246" id="r_a9b2788cdf61c64c5f60a94d149c87246"><td class="memItemLeft" align="right" valign="top">NamelistType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b2788cdf61c64c5f60a94d149c87246">getKeywordKind</a> (const std::string &amp;keyword_query) const</td></tr>
<tr class="memdesc:a9b2788cdf61c64c5f60a94d149c87246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of a specific keyword within this namelist.  <br /></td></tr>
<tr class="separator:a9b2788cdf61c64c5f60a94d149c87246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a223c0d51042cdede19e03c329529e5e6" id="r_a223c0d51042cdede19e03c329529e5e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a223c0d51042cdede19e03c329529e5e6">getKeywordEntries</a> (const std::string &amp;keyword_query) const</td></tr>
<tr class="memdesc:a223c0d51042cdede19e03c329529e5e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of entries associated with a specific keyword.  <br /></td></tr>
<tr class="separator:a223c0d51042cdede19e03c329529e5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc3266bda2e8f900d91d4a0b4dc5fd9" id="r_a9fc3266bda2e8f900d91d4a0b4dc5fd9"><td class="memItemLeft" align="right" valign="top"><a id="a9fc3266bda2e8f900d91d4a0b4dc5fd9" name="a9fc3266bda2e8f900d91d4a0b4dc5fd9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getSubKeyCount</b> (const std::string &amp;keyword_query) const</td></tr>
<tr class="memdesc:a9fc3266bda2e8f900d91d4a0b4dc5fd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the template size of a keyword, the number of sub-keys it contains. For non-struct keywords the template size is reported as 0. <br /></td></tr>
<tr class="separator:a9fc3266bda2e8f900d91d4a0b4dc5fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90542974cfe83a4ef361fffb7b2b98b0" id="r_a90542974cfe83a4ef361fffb7b2b98b0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90542974cfe83a4ef361fffb7b2b98b0">getAllBoolValues</a> (const std::string &amp;keyword_query, const std::string &amp;sub_key) const</td></tr>
<tr class="memdesc:a90542974cfe83a4ef361fffb7b2b98b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all boolen values assigned to a particular keyword. The keyword must have STRUCT type, as the only other option for a BOOL keyword is a single value.  <br /></td></tr>
<tr class="separator:a90542974cfe83a4ef361fffb7b2b98b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a097dcffc28b4c3bdaf8bf9086716aef3" id="r_a097dcffc28b4c3bdaf8bf9086716aef3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a097dcffc28b4c3bdaf8bf9086716aef3">getAllIntValues</a> (const std::string &amp;keyword_query, const std::string &amp;sub_key=std::string(&quot;&quot;)) const</td></tr>
<tr class="memdesc:a097dcffc28b4c3bdaf8bf9086716aef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all integer values assigned to a particular keyword.  <br /></td></tr>
<tr class="separator:a097dcffc28b4c3bdaf8bf9086716aef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add056415bf0acf12a71e4f515e2778d4" id="r_add056415bf0acf12a71e4f515e2778d4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add056415bf0acf12a71e4f515e2778d4">getAllRealValues</a> (const std::string &amp;keyword_query, const std::string &amp;sub_key=std::string(&quot;&quot;)) const</td></tr>
<tr class="memdesc:add056415bf0acf12a71e4f515e2778d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all real values assigned to a particular keyword.  <br /></td></tr>
<tr class="separator:add056415bf0acf12a71e4f515e2778d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7143f4e7ed3e0ec0307d602af95cf20b" id="r_a7143f4e7ed3e0ec0307d602af95cf20b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7143f4e7ed3e0ec0307d602af95cf20b">getAllStringValues</a> (const std::string &amp;keyword_query, const std::string &amp;sub_key=std::string(&quot;&quot;)) const</td></tr>
<tr class="memdesc:a7143f4e7ed3e0ec0307d602af95cf20b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all string values assigned to a particular keyword.  <br /></td></tr>
<tr class="separator:a7143f4e7ed3e0ec0307d602af95cf20b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af56f5ac16dc7b67b2d744fd1b27511ac" id="r_af56f5ac16dc7b67b2d744fd1b27511ac"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af56f5ac16dc7b67b2d744fd1b27511ac">getHelp</a> () const</td></tr>
<tr class="memdesc:af56f5ac16dc7b67b2d744fd1b27511ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report the help message associated with a keyword or sub-key. This can be useful for developers who wish to alert users to erroneous input.  <br /></td></tr>
<tr class="separator:af56f5ac16dc7b67b2d744fd1b27511ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e2da395475c4d6b655fe3fe97e1a1d" id="r_ae7e2da395475c4d6b655fe3fe97e1a1d"><td class="memItemLeft" align="right" valign="top"><a id="ae7e2da395475c4d6b655fe3fe97e1a1d" name="ae7e2da395475c4d6b655fe3fe97e1a1d"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getHelp</b> (const std::string &amp;keyword_query) const</td></tr>
<tr class="separator:ae7e2da395475c4d6b655fe3fe97e1a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e393bbf1e2c959ea5132349b9d329a8" id="r_a1e393bbf1e2c959ea5132349b9d329a8"><td class="memItemLeft" align="right" valign="top"><a id="a1e393bbf1e2c959ea5132349b9d329a8" name="a1e393bbf1e2c959ea5132349b9d329a8"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getHelp</b> (const std::string &amp;keyword_query, const std::string &amp;sub_key) const</td></tr>
<tr class="separator:a1e393bbf1e2c959ea5132349b9d329a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a4deed3a9e66e422718ab74cd105825" id="r_a8a4deed3a9e66e422718ab74cd105825"><td class="memItemLeft" align="right" valign="top"><a id="a8a4deed3a9e66e422718ab74cd105825" name="a8a4deed3a9e66e422718ab74cd105825"></a>
const <a class="el" href="classstormm_1_1namelist_1_1NamelistEmulator.html">NamelistEmulator</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getSelfPointer</b> () const</td></tr>
<tr class="memdesc:a8a4deed3a9e66e422718ab74cd105825"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the object itself. <br /></td></tr>
<tr class="separator:a8a4deed3a9e66e422718ab74cd105825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d56cf390a43fc124ebaedf6f8aba4b" id="r_a17d56cf390a43fc124ebaedf6f8aba4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17d56cf390a43fc124ebaedf6f8aba4b">setTitle</a> (const std::string &amp;title_in)</td></tr>
<tr class="memdesc:a17d56cf390a43fc124ebaedf6f8aba4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the title of the namelist.  <br /></td></tr>
<tr class="separator:a17d56cf390a43fc124ebaedf6f8aba4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9026fe7e7d04c210bc6fc455dab8076a" id="r_a9026fe7e7d04c210bc6fc455dab8076a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9026fe7e7d04c210bc6fc455dab8076a">setCommandLineContent</a> (bool cli_content_in=true)</td></tr>
<tr class="memdesc:a9026fe7e7d04c210bc6fc455dab8076a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether the namelist actually serves command line input for a whole program.  <br /></td></tr>
<tr class="separator:a9026fe7e7d04c210bc6fc455dab8076a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f3af172a3966e79b72609bc516398a" id="r_a59f3af172a3966e79b72609bc516398a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59f3af172a3966e79b72609bc516398a">addDefaultValue</a> (const std::string &amp;key, const std::string &amp;next_default)</td></tr>
<tr class="memdesc:a59f3af172a3966e79b72609bc516398a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a value to one keyword's default settings. This enables a single keyword to have a collection of default values. The keyword will be checked to ensure that it permits multiple values.  <br /></td></tr>
<tr class="separator:a59f3af172a3966e79b72609bc516398a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a339eb144680793a06bc32ba5607d16d7" id="r_a339eb144680793a06bc32ba5607d16d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a339eb144680793a06bc32ba5607d16d7">triggerResizeBuffer</a> (const std::string &amp;key)</td></tr>
<tr class="memdesc:a339eb144680793a06bc32ba5607d16d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">When loading data for STRUCT-type keywords, the decision to increment the number of entries on file cannot be made with the first sub-key assignment. Instead, the entire struct must be read from input before the number of entries can be incremented. Because a function (readNamelist(), see <a class="el" href="input_8h_source.html">input.h</a>) that manages a <a class="el" href="classstormm_1_1testing_1_1NamelistEmulator.html" title="Collection of variables to transcribe information contained within a namelist.">NamelistEmulator</a> loops over the input that can be associated with each list of subk-eys for a given STRUCT, that function must go through the <a class="el" href="classstormm_1_1testing_1_1NamelistEmulator.html" title="Collection of variables to transcribe information contained within a namelist.">NamelistEmulator</a> in order to increment the keyword's entry count.  <br /></td></tr>
<tr class="separator:a339eb144680793a06bc32ba5607d16d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15f3238efce5b3a7380644f46b93d8d" id="r_ab15f3238efce5b3a7380644f46b93d8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab15f3238efce5b3a7380644f46b93d8d">addCategory</a> (const std::string &amp;new_category)</td></tr>
<tr class="memdesc:ab15f3238efce5b3a7380644f46b93d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a category to a namelist to group its keywords for user documentation.  <br /></td></tr>
<tr class="separator:ab15f3238efce5b3a7380644f46b93d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b4ae4d0f8e881dd1f478ad976a1c322" id="r_a0b4ae4d0f8e881dd1f478ad976a1c322"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b4ae4d0f8e881dd1f478ad976a1c322">categorizeKeyword</a> (const std::string &amp;key, const std::string &amp;category_label)</td></tr>
<tr class="memdesc:a0b4ae4d0f8e881dd1f478ad976a1c322"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place a namelist keyword into one of a list of arbitrary categories defined by the developer. This is for organizing the user documentation.  <br /></td></tr>
<tr class="separator:a0b4ae4d0f8e881dd1f478ad976a1c322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeefb9d69cb2fc28fa398fea35a57901e" id="r_aeefb9d69cb2fc28fa398fea35a57901e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeefb9d69cb2fc28fa398fea35a57901e">printKeywordDocumentation</a> (int p_idx, int name_width, int kw_kind_width, const std::string &amp;kw_dflt) const</td></tr>
<tr class="memdesc:aeefb9d69cb2fc28fa398fea35a57901e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the documentation for a specific keyword. The format is fixed in the sense that it will have a set indentation, a dash for a bullet point, and the keyword printed in a space large enough for a series of related keywords in a column.  <br /></td></tr>
<tr class="separator:aeefb9d69cb2fc28fa398fea35a57901e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab523a9cccc0e693035b7351b9ec17711" id="r_ab523a9cccc0e693035b7351b9ec17711"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab523a9cccc0e693035b7351b9ec17711">convertDefaultToString</a> (const NamelistElement &amp;tkw) const</td></tr>
<tr class="memdesc:ab523a9cccc0e693035b7351b9ec17711"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the default value of a keyword to a string for output in a formatted table.  <br /></td></tr>
<tr class="separator:ab523a9cccc0e693035b7351b9ec17711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a450d560f754cf2671fcbbc984983ea61" id="r_a450d560f754cf2671fcbbc984983ea61"><td class="memItemLeft" align="right" valign="top"><a id="a450d560f754cf2671fcbbc984983ea61" name="a450d560f754cf2671fcbbc984983ea61"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>printHelp</b> () const</td></tr>
<tr class="memdesc:a450d560f754cf2671fcbbc984983ea61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a detailed message concerning the user documentation for keywords in this namelist. This function can be called from the main program, for any namelists that accept its inputs, and is itself called by the printProgramDocumentation() function in the docs namespace (see Reporting/custom_help.h) <br /></td></tr>
<tr class="separator:a450d560f754cf2671fcbbc984983ea61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3f5f377d74fc16e5ced33a3e018f21ed" id="r_a3f5f377d74fc16e5ced33a3e018f21ed"><td class="memItemLeft" align="right" valign="top">InputStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f5f377d74fc16e5ced33a3e018f21ed">getKeywordStatus</a> (const std::string &amp;keyword_query) const</td></tr>
<tr class="memdesc:a3f5f377d74fc16e5ced33a3e018f21ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether a keyword has been set, be that by default or user input.  <br /></td></tr>
<tr class="separator:a3f5f377d74fc16e5ced33a3e018f21ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aac0861d849983950e513ae09660349" id="r_a2aac0861d849983950e513ae09660349"><td class="memItemLeft" align="right" valign="top"><a id="a2aac0861d849983950e513ae09660349" name="a2aac0861d849983950e513ae09660349"></a>
InputStatus&#160;</td><td class="memItemRight" valign="bottom"><b>getKeywordStatus</b> (const std::string &amp;keyword_query, const std::string &amp;sub_key, int repeat_no=0) const</td></tr>
<tr class="separator:a2aac0861d849983950e513ae09660349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab2b0d89154b2086ad2d69ba20d9f7c66" id="r_ab2b0d89154b2086ad2d69ba20d9f7c66"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2b0d89154b2086ad2d69ba20d9f7c66">hasKeyword</a> (const std::string &amp;query) const</td></tr>
<tr class="memdesc:ab2b0d89154b2086ad2d69ba20d9f7c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether a namelist contains a particular keyword at all.  <br /></td></tr>
<tr class="separator:ab2b0d89154b2086ad2d69ba20d9f7c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bda1d4c85f181048ea7d31b8788a0b6" id="r_a9bda1d4c85f181048ea7d31b8788a0b6"><td class="memItemLeft" align="right" valign="top"><a id="a9bda1d4c85f181048ea7d31b8788a0b6" name="a9bda1d4c85f181048ea7d31b8788a0b6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasKeyword</b> (const std::string &amp;query, NamelistType query_kind) const</td></tr>
<tr class="separator:a9bda1d4c85f181048ea7d31b8788a0b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3a5b12ae8a69f2c20cd38eaca7174200" id="r_a3a5b12ae8a69f2c20cd38eaca7174200"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a5b12ae8a69f2c20cd38eaca7174200">getBoolValue</a> (const std::string &amp;keyword_query) const</td></tr>
<tr class="memdesc:a3a5b12ae8a69f2c20cd38eaca7174200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a boolean keyword from the within the namelist.  <br /></td></tr>
<tr class="separator:a3a5b12ae8a69f2c20cd38eaca7174200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4ed35614805411becc5512de91f057" id="r_a2f4ed35614805411becc5512de91f057"><td class="memItemLeft" align="right" valign="top"><a id="a2f4ed35614805411becc5512de91f057" name="a2f4ed35614805411becc5512de91f057"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>getBoolValue</b> (const std::string &amp;keyword_query, const std::string &amp;sub_key, int index=0) const</td></tr>
<tr class="separator:a2f4ed35614805411becc5512de91f057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a49f1923801b7a4979df49d1614214702" id="r_a49f1923801b7a4979df49d1614214702"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49f1923801b7a4979df49d1614214702">getIntValue</a> (const std::string &amp;keyword_query, int index=0) const</td></tr>
<tr class="memdesc:a49f1923801b7a4979df49d1614214702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a labeled integer value from within the namelist.  <br /></td></tr>
<tr class="separator:a49f1923801b7a4979df49d1614214702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c1fa4c84b9e5c0e9af8caa44577c638" id="r_a4c1fa4c84b9e5c0e9af8caa44577c638"><td class="memItemLeft" align="right" valign="top"><a id="a4c1fa4c84b9e5c0e9af8caa44577c638" name="a4c1fa4c84b9e5c0e9af8caa44577c638"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getIntValue</b> (const std::string &amp;keyword_query, const std::string &amp;sub_key, int index=0) const</td></tr>
<tr class="separator:a4c1fa4c84b9e5c0e9af8caa44577c638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a30b7cc5b1797f8d73d651bfb402c00a0" id="r_a30b7cc5b1797f8d73d651bfb402c00a0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30b7cc5b1797f8d73d651bfb402c00a0">getRealValue</a> (const std::string &amp;keyword_query, int index=0) const</td></tr>
<tr class="memdesc:a30b7cc5b1797f8d73d651bfb402c00a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a labeled real number value from within the namelist.  <br /></td></tr>
<tr class="separator:a30b7cc5b1797f8d73d651bfb402c00a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2374db97fe4d9c461af43b245b326673" id="r_a2374db97fe4d9c461af43b245b326673"><td class="memItemLeft" align="right" valign="top"><a id="a2374db97fe4d9c461af43b245b326673" name="a2374db97fe4d9c461af43b245b326673"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getRealValue</b> (const std::string &amp;keyword_query, const std::string &amp;sub_key, int index=0) const</td></tr>
<tr class="separator:a2374db97fe4d9c461af43b245b326673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0db9faab27fbdbe80101765d51019bb6" id="r_a0db9faab27fbdbe80101765d51019bb6"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0db9faab27fbdbe80101765d51019bb6">getStringValue</a> (const std::string &amp;keyword_query, int index=0) const</td></tr>
<tr class="memdesc:a0db9faab27fbdbe80101765d51019bb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a labeled string value from within the namelist.  <br /></td></tr>
<tr class="separator:a0db9faab27fbdbe80101765d51019bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3647a0544d24006a6c2d3b3640ca9761" id="r_a3647a0544d24006a6c2d3b3640ca9761"><td class="memItemLeft" align="right" valign="top"><a id="a3647a0544d24006a6c2d3b3640ca9761" name="a3647a0544d24006a6c2d3b3640ca9761"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getStringValue</b> (const std::string &amp;keyword_query, const std::string &amp;sub_key, int index=0) const</td></tr>
<tr class="separator:a3647a0544d24006a6c2d3b3640ca9761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5fd4cc934ef346b4b5009af0161e5b7e" id="r_a5fd4cc934ef346b4b5009af0161e5b7e"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a5fd4cc934ef346b4b5009af0161e5b7e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5fd4cc934ef346b4b5009af0161e5b7e">assignVariable</a> (T *var, double mult, const std::string &amp;keyword_query, int index=0) const</td></tr>
<tr class="memdesc:a5fd4cc934ef346b4b5009af0161e5b7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a value, external to the object, based on the content inside of it. This will first check whether the appropriate keyword is not missing (that is has a default value, or has been specified by the user). If the associated keyword is indeed missing, there will be no effect on the external variable.  <br /></td></tr>
<tr class="separator:a5fd4cc934ef346b4b5009af0161e5b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6ca0aa6ce5a31fdbdd2fb7e99bd41eb" id="r_ab6ca0aa6ce5a31fdbdd2fb7e99bd41eb"><td class="memTemplParams" colspan="2"><a id="ab6ca0aa6ce5a31fdbdd2fb7e99bd41eb" name="ab6ca0aa6ce5a31fdbdd2fb7e99bd41eb"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:ab6ca0aa6ce5a31fdbdd2fb7e99bd41eb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assignVariable</b> (T *var, const std::string &amp;keyword_query, int index=0) const</td></tr>
<tr class="separator:ab6ca0aa6ce5a31fdbdd2fb7e99bd41eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a22ab62901de08ea34c71e2b8b5674b" id="r_a0a22ab62901de08ea34c71e2b8b5674b"><td class="memItemLeft" align="right" valign="top"><a id="a0a22ab62901de08ea34c71e2b8b5674b" name="a0a22ab62901de08ea34c71e2b8b5674b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>assignVariable</b> (std::string *var, double mult, const std::string &amp;keyword_query, int index=0) const</td></tr>
<tr class="separator:a0a22ab62901de08ea34c71e2b8b5674b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9aeddacc24a15d29c9134460736bdc2" id="r_af9aeddacc24a15d29c9134460736bdc2"><td class="memItemLeft" align="right" valign="top"><a id="af9aeddacc24a15d29c9134460736bdc2" name="af9aeddacc24a15d29c9134460736bdc2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>assignVariable</b> (std::string *var, const std::string &amp;keyword_query, int index=0) const</td></tr>
<tr class="separator:af9aeddacc24a15d29c9134460736bdc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac877be5e0a0300d683e336d8a22e2797" id="r_ac877be5e0a0300d683e336d8a22e2797"><td class="memTemplParams" colspan="2"><a id="ac877be5e0a0300d683e336d8a22e2797" name="ac877be5e0a0300d683e336d8a22e2797"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:ac877be5e0a0300d683e336d8a22e2797"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assignVariable</b> (T *var_x, T *var_y, T *var_z, double mult, const std::string &amp;keyword_query, int index=0) const</td></tr>
<tr class="separator:ac877be5e0a0300d683e336d8a22e2797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c04066fca6a6d225dc4123a5a32184d" id="r_a5c04066fca6a6d225dc4123a5a32184d"><td class="memTemplParams" colspan="2"><a id="a5c04066fca6a6d225dc4123a5a32184d" name="a5c04066fca6a6d225dc4123a5a32184d"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:a5c04066fca6a6d225dc4123a5a32184d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assignVariable</b> (T *var_x, T *var_y, T *var_z, const std::string &amp;keyword_query, int index=0) const</td></tr>
<tr class="separator:a5c04066fca6a6d225dc4123a5a32184d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee95e10a21d95a2276e9c608eb8105b" id="r_a5ee95e10a21d95a2276e9c608eb8105b"><td class="memTemplParams" colspan="2"><a id="a5ee95e10a21d95a2276e9c608eb8105b" name="a5ee95e10a21d95a2276e9c608eb8105b"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:a5ee95e10a21d95a2276e9c608eb8105b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assignVariable</b> (T *var, const std::string &amp;keyword_query, const std::string &amp;sub_key, int index=0) const</td></tr>
<tr class="separator:a5ee95e10a21d95a2276e9c608eb8105b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39f091a13987d4fd82e3d6c1d602fade" id="r_a39f091a13987d4fd82e3d6c1d602fade"><td class="memTemplParams" colspan="2"><a id="a39f091a13987d4fd82e3d6c1d602fade" name="a39f091a13987d4fd82e3d6c1d602fade"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:a39f091a13987d4fd82e3d6c1d602fade"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assignVariable</b> (T *var, double mult, const std::string &amp;keyword_query, const std::string &amp;sub_key, int index=0) const</td></tr>
<tr class="separator:a39f091a13987d4fd82e3d6c1d602fade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968bb160e89f8a3f922bd9deb59171bf" id="r_a968bb160e89f8a3f922bd9deb59171bf"><td class="memItemLeft" align="right" valign="top"><a id="a968bb160e89f8a3f922bd9deb59171bf" name="a968bb160e89f8a3f922bd9deb59171bf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>assignVariable</b> (std::string *var, double mult, const std::string &amp;keyword_query, const std::string &amp;sub_key, int index=0) const</td></tr>
<tr class="separator:a968bb160e89f8a3f922bd9deb59171bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0085943e1f545ba4f0c74c791f7331e" id="r_ae0085943e1f545ba4f0c74c791f7331e"><td class="memItemLeft" align="right" valign="top"><a id="ae0085943e1f545ba4f0c74c791f7331e" name="ae0085943e1f545ba4f0c74c791f7331e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>assignVariable</b> (std::string *var, const std::string &amp;keyword_query, const std::string &amp;sub_key, int index=0) const</td></tr>
<tr class="separator:ae0085943e1f545ba4f0c74c791f7331e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d70af4a5913796754ded663e4cdbf7c" id="r_a2d70af4a5913796754ded663e4cdbf7c"><td class="memTemplParams" colspan="2"><a id="a2d70af4a5913796754ded663e4cdbf7c" name="a2d70af4a5913796754ded663e4cdbf7c"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:a2d70af4a5913796754ded663e4cdbf7c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assignVariable</b> (T *var_x, T *var_y, T *var_z, double mult, const std::string &amp;keyword_query, const std::string &amp;sub_key, int index=0) const</td></tr>
<tr class="separator:a2d70af4a5913796754ded663e4cdbf7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55429d009518087d7d978638411a762c" id="r_a55429d009518087d7d978638411a762c"><td class="memTemplParams" colspan="2"><a id="a55429d009518087d7d978638411a762c" name="a55429d009518087d7d978638411a762c"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:a55429d009518087d7d978638411a762c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assignVariable</b> (T *var_x, T *var_y, T *var_z, const std::string &amp;keyword_query, const std::string &amp;sub_key, int index=0) const</td></tr>
<tr class="separator:a55429d009518087d7d978638411a762c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3e25028d157c5d45afccb1802676c038" id="r_a3e25028d157c5d45afccb1802676c038"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e25028d157c5d45afccb1802676c038">addKeyword</a> (const std::vector&lt; NamelistElement &gt; &amp;new_keys)</td></tr>
<tr class="memdesc:a3e25028d157c5d45afccb1802676c038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a keyword to the namelist.  <br /></td></tr>
<tr class="separator:a3e25028d157c5d45afccb1802676c038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd14bcd2ad01272b3226c8eb26eb527d" id="r_abd14bcd2ad01272b3226c8eb26eb527d"><td class="memItemLeft" align="right" valign="top"><a id="abd14bcd2ad01272b3226c8eb26eb527d" name="abd14bcd2ad01272b3226c8eb26eb527d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addKeyword</b> (const NamelistElement &amp;new_key)</td></tr>
<tr class="separator:abd14bcd2ad01272b3226c8eb26eb527d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc2d5b4b8f169cfaa1b3d84b5b1cd891" id="r_adc2d5b4b8f169cfaa1b3d84b5b1cd891"><td class="memItemLeft" align="right" valign="top"><a id="adc2d5b4b8f169cfaa1b3d84b5b1cd891" name="adc2d5b4b8f169cfaa1b3d84b5b1cd891"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addKeyword</b> (const std::string &amp;keyword_in, NamelistType kind_in, const std::string &amp;default_in=std::string(&quot;&quot;), DefaultIsObligatory obligate=DefaultIsObligatory::NO, InputRepeats rep_in=InputRepeats::NO, const std::string &amp;help_in=std::string(&quot;No description provided&quot;))</td></tr>
<tr class="separator:adc2d5b4b8f169cfaa1b3d84b5b1cd891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e16a53041fb4e37d3d97b3c89ac6fe" id="r_a32e16a53041fb4e37d3d97b3c89ac6fe"><td class="memItemLeft" align="right" valign="top"><a id="a32e16a53041fb4e37d3d97b3c89ac6fe" name="a32e16a53041fb4e37d3d97b3c89ac6fe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addKeyword</b> (const std::string keyword_in, const std::vector&lt; std::string &gt; &amp;sub_keys_in, const std::vector&lt; NamelistType &gt; &amp;sub_kinds_in, const std::vector&lt; std::string &gt; &amp;default_list, DefaultIsObligatory obligate_list=DefaultIsObligatory::NO, InputRepeats rep_in=InputRepeats::NO, const std::string &amp;help_in=std::string(&quot;No description provided&quot;), const std::vector&lt; std::string &gt; &amp;sub_help_in=std::vector&lt; std::string &gt;(1, &quot;No description provided&quot;), const std::vector&lt; KeyRequirement &gt; &amp;template_requirements_in={})</td></tr>
<tr class="separator:a32e16a53041fb4e37d3d97b3c89ac6fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a0f93de9059a9e2ab1cf04c5b4b653" id="r_a93a0f93de9059a9e2ab1cf04c5b4b653"><td class="memItemLeft" align="right" valign="top"><a id="a93a0f93de9059a9e2ab1cf04c5b4b653" name="a93a0f93de9059a9e2ab1cf04c5b4b653"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addKeyword</b> (const <a class="el" href="classstormm_1_1namelist_1_1NamelistEmulator.html">NamelistEmulator</a> *other, const std::string &amp;query)</td></tr>
<tr class="separator:a93a0f93de9059a9e2ab1cf04c5b4b653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a211a244774733e9179565932c85b3ca2" id="r_a211a244774733e9179565932c85b3ca2"><td class="memItemLeft" align="right" valign="top"><a id="a211a244774733e9179565932c85b3ca2" name="a211a244774733e9179565932c85b3ca2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addKeyword</b> (const <a class="el" href="classstormm_1_1namelist_1_1NamelistEmulator.html">NamelistEmulator</a> &amp;other, const std::string &amp;query)</td></tr>
<tr class="separator:a211a244774733e9179565932c85b3ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5e8990606d8a334348baab74909fd07" id="r_ab5e8990606d8a334348baab74909fd07"><td class="memItemLeft" align="right" valign="top"><a id="ab5e8990606d8a334348baab74909fd07" name="ab5e8990606d8a334348baab74909fd07"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addKeywords</b> (const std::vector&lt; NamelistElement &gt; &amp;new_keys)</td></tr>
<tr class="separator:ab5e8990606d8a334348baab74909fd07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1370da85b55a1f96e99ced5e3e0e8e46" id="r_a1370da85b55a1f96e99ced5e3e0e8e46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1370da85b55a1f96e99ced5e3e0e8e46">setDefaultValue</a> (const std::string &amp;key, const std::string &amp;modified_default, int default_idx=0)</td></tr>
<tr class="memdesc:a1370da85b55a1f96e99ced5e3e0e8e46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a default value for one of the namelist's keywords. Like <a class="el" href="classstormm_1_1namelist_1_1NamelistEmulator.html#a59f3af172a3966e79b72609bc516398a" title="Add a value to one keyword&#39;s default settings. This enables a single keyword to have a collection of ...">addDefaultValue()</a> and other functions below, the effect will be to pass through the <a class="el" href="classstormm_1_1testing_1_1NamelistEmulator.html" title="Collection of variables to transcribe information contained within a namelist.">NamelistEmulator</a> to.  <br /></td></tr>
<tr class="separator:a1370da85b55a1f96e99ced5e3e0e8e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcdf3df30aaf5edf6d8c4e0e4dc66dcb" id="r_adcdf3df30aaf5edf6d8c4e0e4dc66dcb"><td class="memItemLeft" align="right" valign="top"><a id="adcdf3df30aaf5edf6d8c4e0e4dc66dcb" name="adcdf3df30aaf5edf6d8c4e0e4dc66dcb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setDefaultValue</b> (const std::string &amp;key, const std::vector&lt; std::string &gt; &amp;modified_defaults, const std::vector&lt; std::string &gt; &amp;sub_key_specs)</td></tr>
<tr class="separator:adcdf3df30aaf5edf6d8c4e0e4dc66dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac73a22f79f1e41cc2239def750001fc0" id="r_ac73a22f79f1e41cc2239def750001fc0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac73a22f79f1e41cc2239def750001fc0">activateBool</a> (const std::string &amp;key)</td></tr>
<tr class="memdesc:ac73a22f79f1e41cc2239def750001fc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate a BOOL-type keyword, or a BOOL-type member of a STRUCT-type keyword. These functions are analogous to <a class="el" href="classstormm_1_1namelist_1_1NamelistEmulator.html#a8d87d6fbc81500e936d5c5825e98e39f" title="Assign values to elements of each particular NamelistType. These overloaded functions can be called f...">assignElement()</a> below, but because BOOL-type keywords do not take distinct values the functions that set BOOL-type variables to ON are named differently.  <br /></td></tr>
<tr class="separator:ac73a22f79f1e41cc2239def750001fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2345413385fadf85f03f1364d5e6829d" id="r_a2345413385fadf85f03f1364d5e6829d"><td class="memItemLeft" align="right" valign="top"><a id="a2345413385fadf85f03f1364d5e6829d" name="a2345413385fadf85f03f1364d5e6829d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>activateBool</b> (const std::string &amp;key, const std::string &amp;sub_key)</td></tr>
<tr class="separator:a2345413385fadf85f03f1364d5e6829d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a8d87d6fbc81500e936d5c5825e98e39f" id="r_a8d87d6fbc81500e936d5c5825e98e39f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d87d6fbc81500e936d5c5825e98e39f">assignElement</a> (const std::string &amp;key, const std::string &amp;value)</td></tr>
<tr class="memdesc:a8d87d6fbc81500e936d5c5825e98e39f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign values to elements of each particular NamelistType. These overloaded functions can be called from anywhere, but constructors making control objects for programs using the STORMM libraries are the ideal place to use them. They in turn call the set(...)Value member functions of the target <a class="el" href="classstormm_1_1namelist_1_1NamelistElement.html" title="One keyword found in a namelist, ready to store the namelist variable moniker, the type,...">NamelistElement</a> object in the <a class="el" href="classstormm_1_1testing_1_1NamelistEmulator.html" title="Collection of variables to transcribe information contained within a namelist.">NamelistEmulator</a>. Returns 1 if the given value was successfully assigned to the label or 0 if not.  <br /></td></tr>
<tr class="separator:a8d87d6fbc81500e936d5c5825e98e39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5dcc290ff87c2884fe48fd5d8f51ab1" id="r_ab5dcc290ff87c2884fe48fd5d8f51ab1"><td class="memItemLeft" align="right" valign="top"><a id="ab5dcc290ff87c2884fe48fd5d8f51ab1" name="ab5dcc290ff87c2884fe48fd5d8f51ab1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>assignElement</b> (const std::string &amp;key, const std::string &amp;sub_key, const std::string &amp;value)</td></tr>
<tr class="separator:ab5dcc290ff87c2884fe48fd5d8f51ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aae653509cde8737e737437f9d89a5575" id="r_aae653509cde8737e737437f9d89a5575"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae653509cde8737e737437f9d89a5575">addHelp</a> (const std::string &amp;blurb)</td></tr>
<tr class="memdesc:aae653509cde8737e737437f9d89a5575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach a help message to the namelist itself, to a keyword within the namelist, or even to a member variable of a STRUCT-associated keyword in the namelist. This is provided so that developers do not have to include help messages at the initialization of each namelist keyword. This will overwrite existing help messages.  <br /></td></tr>
<tr class="separator:aae653509cde8737e737437f9d89a5575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99dbf220a8d48f836f190a11041f2d2a" id="r_a99dbf220a8d48f836f190a11041f2d2a"><td class="memItemLeft" align="right" valign="top"><a id="a99dbf220a8d48f836f190a11041f2d2a" name="a99dbf220a8d48f836f190a11041f2d2a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addHelp</b> (const std::string &amp;key, const std::string &amp;blurb)</td></tr>
<tr class="separator:a99dbf220a8d48f836f190a11041f2d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e888ba5b1bd8496e05ded5e098fd17f" id="r_a9e888ba5b1bd8496e05ded5e098fd17f"><td class="memItemLeft" align="right" valign="top"><a id="a9e888ba5b1bd8496e05ded5e098fd17f" name="a9e888ba5b1bd8496e05ded5e098fd17f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addHelp</b> (const std::string &amp;key, const std::string &amp;sub_key, const std::string &amp;blurb)</td></tr>
<tr class="separator:a9e888ba5b1bd8496e05ded5e098fd17f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a7cf89676273af57c20c32f3ed0317c87" id="r_a7cf89676273af57c20c32f3ed0317c87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7cf89676273af57c20c32f3ed0317c87">setImperative</a> (const std::string &amp;key, KeyRequirement req)</td></tr>
<tr class="memdesc:a7cf89676273af57c20c32f3ed0317c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the requirement associated with a keyword. By default, all keywords are set to "REQUIRED" just as all STRUCT-type keyword subkeys are required unless stated otherwise. Even if required, many keywords, like STRUCT subkeys, will have default values that satisfy the requirements.  <br /></td></tr>
<tr class="separator:a7cf89676273af57c20c32f3ed0317c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96196fa41e0d810abb4b80c89c07f428" id="r_a96196fa41e0d810abb4b80c89c07f428"><td class="memItemLeft" align="right" valign="top"><a id="a96196fa41e0d810abb4b80c89c07f428" name="a96196fa41e0d810abb4b80c89c07f428"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setImperative</b> (const std::vector&lt; std::string &gt; &amp;directives)</td></tr>
<tr class="separator:a96196fa41e0d810abb4b80c89c07f428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea58637b8ad403529d3546c8b486ce10" id="r_aea58637b8ad403529d3546c8b486ce10"><td class="memItemLeft" align="right" valign="top"><a id="aea58637b8ad403529d3546c8b486ce10" name="aea58637b8ad403529d3546c8b486ce10"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setImperative</b> (const std::string &amp;key, const std::vector&lt; std::string &gt; &amp;directives)</td></tr>
<tr class="separator:aea58637b8ad403529d3546c8b486ce10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a93bde3070e1a7fa03b5c57d75f7d69d5" id="r_a93bde3070e1a7fa03b5c57d75f7d69d5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93bde3070e1a7fa03b5c57d75f7d69d5">printContents</a> (int file_width=default_output_file_width, int max_entry_counts=4, NamelistIntroduction print_decor=NamelistIntroduction::HEADER) const</td></tr>
<tr class="memdesc:a93bde3070e1a7fa03b5c57d75f7d69d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a complete table of the values for all parameters in this namelist, starting including their sources (input statuses, i.e. DEFAULT, MISSING, or USER-SPECIFIED).  <br /></td></tr>
<tr class="separator:a93bde3070e1a7fa03b5c57d75f7d69d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0364d0bfe4e305c63ddf43a5be722c92" id="r_a0364d0bfe4e305c63ddf43a5be722c92"><td class="memItemLeft" align="right" valign="top"><a id="a0364d0bfe4e305c63ddf43a5be722c92" name="a0364d0bfe4e305c63ddf43a5be722c92"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>printContents</b> (std::ostream *foutp, int file_width=default_output_file_width, int max_entry_counts=4, NamelistIntroduction print_decor=NamelistIntroduction::HEADER) const</td></tr>
<tr class="separator:a0364d0bfe4e305c63ddf43a5be722c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2e07373650e9934f8fafde266914c7" id="r_abf2e07373650e9934f8fafde266914c7"><td class="memItemLeft" align="right" valign="top"><a id="abf2e07373650e9934f8fafde266914c7" name="abf2e07373650e9934f8fafde266914c7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>printContents</b> (std::ofstream *foutp, int file_width=default_output_file_width, int max_entry_counts=4, NamelistIntroduction print_decor=NamelistIntroduction::HEADER) const</td></tr>
<tr class="separator:abf2e07373650e9934f8fafde266914c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a89aec3317b49472560e07b323f4581" id="r_a9a89aec3317b49472560e07b323f4581"><td class="memItemLeft" align="right" valign="top"><a id="a9a89aec3317b49472560e07b323f4581" name="a9a89aec3317b49472560e07b323f4581"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>printContents</b> (const std::string &amp;file_name, PrintSituation expectation, int file_width=default_output_file_width, int max_entry_counts=4, NamelistIntroduction print_decor=NamelistIntroduction::HEADER) const</td></tr>
<tr class="separator:a9a89aec3317b49472560e07b323f4581"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Collection of variables to transcribe information contained within a namelist. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a495ac253a5f50a3d6d1b425932b93c3a" name="a495ac253a5f50a3d6d1b425932b93c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a495ac253a5f50a3d6d1b425932b93c3a">&#9670;&#160;</a></span>NamelistEmulator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">stormm::namelist::NamelistEmulator::NamelistEmulator </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>title_in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CaseSensitivity</td>          <td class="paramname"><span class="paramname"><em>casing_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">CaseSensitivity::AUTOMATIC</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExceptionResponse</td>          <td class="paramname"><span class="paramname"><em>unknown_keyword_policy</em></span><span class="paramdefsep"> = </span><span class="paramdefval">ExceptionResponse::WARN</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>help_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::string(&quot;No&#160;description&#160;provided&quot;)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>cli_content_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an object to emulate Fortran namelist functionality, with improvements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">title_in</td><td>The title of the namelist </td></tr>
    <tr><td class="paramname">casing_in</td><td>Case sensitivity to abide (default "AUTOMATIC", which in this context means that namelist titles and keywords are case insensitive but values are case sensitive) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac73a22f79f1e41cc2239def750001fc0" name="ac73a22f79f1e41cc2239def750001fc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac73a22f79f1e41cc2239def750001fc0">&#9670;&#160;</a></span>activateBool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::namelist::NamelistEmulator::activateBool </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Activate a BOOL-type keyword, or a BOOL-type member of a STRUCT-type keyword. These functions are analogous to <a class="el" href="classstormm_1_1namelist_1_1NamelistEmulator.html#a8d87d6fbc81500e936d5c5825e98e39f" title="Assign values to elements of each particular NamelistType. These overloaded functions can be called f...">assignElement()</a> below, but because BOOL-type keywords do not take distinct values the functions that set BOOL-type variables to ON are named differently. </p>
<p>Overloaded:</p><ul>
<li>Activate the named BOOL keyword</li>
<li>Activate a BOOL sub-key within the named STRUCT</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The keyword of interest </td></tr>
    <tr><td class="paramname">sub_key</td><td>The sub-key of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab15f3238efce5b3a7380644f46b93d8d" name="ab15f3238efce5b3a7380644f46b93d8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab15f3238efce5b3a7380644f46b93d8d">&#9670;&#160;</a></span>addCategory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::namelist::NamelistEmulator::addCategory </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>new_category</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a category to a namelist to group its keywords for user documentation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_category</td><td>The name of the new keyword category </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59f3af172a3966e79b72609bc516398a" name="a59f3af172a3966e79b72609bc516398a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59f3af172a3966e79b72609bc516398a">&#9670;&#160;</a></span>addDefaultValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::namelist::NamelistEmulator::addDefaultValue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>next_default</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a value to one keyword's default settings. This enables a single keyword to have a collection of default values. The keyword will be checked to ensure that it permits multiple values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The keyword of interest </td></tr>
    <tr><td class="paramname">next_default</td><td>The new value to include, as a string, to be re-interpreted as necessary </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae653509cde8737e737437f9d89a5575" name="aae653509cde8737e737437f9d89a5575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae653509cde8737e737437f9d89a5575">&#9670;&#160;</a></span>addHelp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::namelist::NamelistEmulator::addHelp </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>blurb</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attach a help message to the namelist itself, to a keyword within the namelist, or even to a member variable of a STRUCT-associated keyword in the namelist. This is provided so that developers do not have to include help messages at the initialization of each namelist keyword. This will overwrite existing help messages. </p>
<p>Overloaded:</p><ul>
<li>Attach a help message to the namelist as a whole</li>
<li>Attach a help message to any keyword (including STRUCTs) within the namelist</li>
<li>Attach a help message to a sub-key within a STRUCT keyword in the namelist</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blurb</td><td>The help message to attach </td></tr>
    <tr><td class="paramname">key</td><td>Label of the namelist keyword to which the help message gets attached </td></tr>
    <tr><td class="paramname">sub_key</td><td>Label of the member variable of the STRUCT namelist keyword to which the help message gets attached </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e25028d157c5d45afccb1802676c038" name="a3e25028d157c5d45afccb1802676c038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e25028d157c5d45afccb1802676c038">&#9670;&#160;</a></span>addKeyword()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::namelist::NamelistEmulator::addKeyword </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; NamelistElement &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>new_keys</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a keyword to the namelist. </p>
<p>Overloaded:</p><ul>
<li>Add a single keyword (be it a INTEGER, REAL, STRING, or STRUCT namelist element)</li>
<li>Add multiple keywords</li>
<li>Provide a <a class="el" href="classstormm_1_1namelist_1_1NamelistElement.html" title="One keyword found in a namelist, ready to store the namelist variable moniker, the type,...">NamelistElement</a> object</li>
<li>Provide input parameters with one-to-one correspondence to NameListElement objects (this can save space and make the API cleaner)</li>
<li>Import a named keyword from another <a class="el" href="classstormm_1_1testing_1_1NamelistEmulator.html" title="Collection of variables to transcribe information contained within a namelist.">NamelistEmulator</a> object (the other object will be checked to see that it has the keyword of interest)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_keys</td><td>The keywords to add </td></tr>
    <tr><td class="paramname">new_key</td><td>The keyword to add </td></tr>
    <tr><td class="paramname">other</td><td>Another <a class="el" href="classstormm_1_1testing_1_1NamelistEmulator.html" title="Collection of variables to transcribe information contained within a namelist.">NamelistEmulator</a> from which to import a keyword </td></tr>
    <tr><td class="paramname">query</td><td>Name of the keyword to copy from another <a class="el" href="classstormm_1_1testing_1_1NamelistEmulator.html" title="Collection of variables to transcribe information contained within a namelist.">NamelistEmulator</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d87d6fbc81500e936d5c5825e98e39f" name="a8d87d6fbc81500e936d5c5825e98e39f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d87d6fbc81500e936d5c5825e98e39f">&#9670;&#160;</a></span>assignElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stormm::namelist::NamelistEmulator::assignElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign values to elements of each particular NamelistType. These overloaded functions can be called from anywhere, but constructors making control objects for programs using the STORMM libraries are the ideal place to use them. They in turn call the set(...)Value member functions of the target <a class="el" href="classstormm_1_1namelist_1_1NamelistElement.html" title="One keyword found in a namelist, ready to store the namelist variable moniker, the type,...">NamelistElement</a> object in the <a class="el" href="classstormm_1_1testing_1_1NamelistEmulator.html" title="Collection of variables to transcribe information contained within a namelist.">NamelistEmulator</a>. Returns 1 if the given value was successfully assigned to the label or 0 if not. </p>
<p>Overloaded:</p><ul>
<li>Assign a single integer, real, or string value to an INTEGER, REAL, or STRING namelist element, respectively</li>
<li>Assign a single integer, real, or string value to the INTEGER, REAL, or STRING member of a STRUCT namelist element</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The keyword of interest </td></tr>
    <tr><td class="paramname">sub_key</td><td>The sub-key of interest </td></tr>
    <tr><td class="paramname">sub_key</td><td>The value to assign to the keyword or STRUCT sub-key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5fd4cc934ef346b4b5009af0161e5b7e" name="a5fd4cc934ef346b4b5009af0161e5b7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fd4cc934ef346b4b5009af0161e5b7e">&#9670;&#160;</a></span>assignVariable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stormm::namelist::NamelistEmulator::assignVariable </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>mult</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>keyword_query</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign a value, external to the object, based on the content inside of it. This will first check whether the appropriate keyword is not missing (that is has a default value, or has been specified by the user). If the associated keyword is indeed missing, there will be no effect on the external variable. </p>
<p>Overloaded:</p><ul>
<li>Assign other integers</li>
<li>Assign other real values</li>
<li>Assign other strings</li>
<li>Assign triplets of other numerical variables (useful for cases where a generic keyword can assign settings for all three dimensions of an object)</li>
<li>Provide a multiplier to scale the units of user input into internal units (a common case is degrees to radians)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>The integer, real, or string ariable to assign </td></tr>
    <tr><td class="paramname">mult</td><td>Multiplication factor to apply to any value extracted from the &amp;namelist. This factor is only available for scalar results (or triplicate input extractions) and will be cast to the data type of var for integral types. </td></tr>
    <tr><td class="paramname">keyword_query</td><td>The keyword associated with the input data of interest </td></tr>
    <tr><td class="paramname">sub_key</td><td>The sub-key within a STRUCT associated with the input data of interest </td></tr>
    <tr><td class="paramname">index</td><td>Index of the keyword repeat to retrieve </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b4ae4d0f8e881dd1f478ad976a1c322" name="a0b4ae4d0f8e881dd1f478ad976a1c322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b4ae4d0f8e881dd1f478ad976a1c322">&#9670;&#160;</a></span>categorizeKeyword()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::namelist::NamelistEmulator::categorizeKeyword </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>category_label</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Place a namelist keyword into one of a list of arbitrary categories defined by the developer. This is for organizing the user documentation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The namelist keyword to find and categorize </td></tr>
    <tr><td class="paramname">category_label</td><td>The category to put it in </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab523a9cccc0e693035b7351b9ec17711" name="ab523a9cccc0e693035b7351b9ec17711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab523a9cccc0e693035b7351b9ec17711">&#9670;&#160;</a></span>convertDefaultToString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string stormm::namelist::NamelistEmulator::convertDefaultToString </td>
          <td>(</td>
          <td class="paramtype">const NamelistElement &amp;</td>          <td class="paramname"><span class="paramname"><em>tkw</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the default value of a keyword to a string for output in a formatted table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tkw</td><td>The keyword of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90542974cfe83a4ef361fffb7b2b98b0" name="a90542974cfe83a4ef361fffb7b2b98b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90542974cfe83a4ef361fffb7b2b98b0">&#9670;&#160;</a></span>getAllBoolValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; bool &gt; stormm::namelist::NamelistEmulator::getAllBoolValues </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>keyword_query</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>sub_key</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all boolen values assigned to a particular keyword. The keyword must have STRUCT type, as the only other option for a BOOL keyword is a single value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyword_query</td><td>Identifier of the keyword of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a097dcffc28b4c3bdaf8bf9086716aef3" name="a097dcffc28b4c3bdaf8bf9086716aef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a097dcffc28b4c3bdaf8bf9086716aef3">&#9670;&#160;</a></span>getAllIntValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; stormm::namelist::NamelistEmulator::getAllIntValues </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>keyword_query</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>sub_key</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::string(&quot;&quot;)</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all integer values assigned to a particular keyword. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyword_query</td><td>Identifier of the keyword of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add056415bf0acf12a71e4f515e2778d4" name="add056415bf0acf12a71e4f515e2778d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add056415bf0acf12a71e4f515e2778d4">&#9670;&#160;</a></span>getAllRealValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; stormm::namelist::NamelistEmulator::getAllRealValues </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>keyword_query</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>sub_key</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::string(&quot;&quot;)</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all real values assigned to a particular keyword. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyword_query</td><td>Identifier of the keyword of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7143f4e7ed3e0ec0307d602af95cf20b" name="a7143f4e7ed3e0ec0307d602af95cf20b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7143f4e7ed3e0ec0307d602af95cf20b">&#9670;&#160;</a></span>getAllStringValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; stormm::namelist::NamelistEmulator::getAllStringValues </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>keyword_query</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>sub_key</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::string(&quot;&quot;)</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all string values assigned to a particular keyword. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyword_query</td><td>Identifier of the keyword of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a5b12ae8a69f2c20cd38eaca7174200" name="a3a5b12ae8a69f2c20cd38eaca7174200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a5b12ae8a69f2c20cd38eaca7174200">&#9670;&#160;</a></span>getBoolValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stormm::namelist::NamelistEmulator::getBoolValue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>keyword_query</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a boolean keyword from the within the namelist. </p>
<p>Overloaded:</p><ul>
<li>Get a BOOL value for a non-STRUCT keyword</li>
<li>Get a BOOL value from within a STRUCT keyword</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyword_query</td><td>Identifier of the keyword of interest </td></tr>
    <tr><td class="paramname">sub_key</td><td>Identifier for the member variable within the STRUCT of interest </td></tr>
    <tr><td class="paramname">index</td><td>For keywords that store multiple values, retrieve this value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af56f5ac16dc7b67b2d744fd1b27511ac" name="af56f5ac16dc7b67b2d744fd1b27511ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af56f5ac16dc7b67b2d744fd1b27511ac">&#9670;&#160;</a></span>getHelp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; stormm::namelist::NamelistEmulator::getHelp </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Report the help message associated with a keyword or sub-key. This can be useful for developers who wish to alert users to erroneous input. </p>
<p>Overloaded:</p><ul>
<li>Report user documentation for the namelist as a whole</li>
<li>Report user documentation for any keyword (including STRUCTs) within the namelist</li>
<li>Report user documentation for a sub-key within a STRUCT keyword in the namelist</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyword_query</td><td>Identifier of the keyword of interest </td></tr>
    <tr><td class="paramname">sub_key</td><td>Identifier for the member variable within the STRUCT of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49f1923801b7a4979df49d1614214702" name="a49f1923801b7a4979df49d1614214702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49f1923801b7a4979df49d1614214702">&#9670;&#160;</a></span>getIntValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stormm::namelist::NamelistEmulator::getIntValue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>keyword_query</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a labeled integer value from within the namelist. </p>
<p>Overloaded:</p><ul>
<li>Get an INTEGER value for a non-STRUCT keyword</li>
<li>Get an INTEGER value from within a STRUCT keyword</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyword_query</td><td>Identifier of the keyword of interest </td></tr>
    <tr><td class="paramname">sub_key</td><td>Identifier for the member variable within the STRUCT of interest </td></tr>
    <tr><td class="paramname">index</td><td>For keywords that store multiple values, retrieve this value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af79ba492a62c286c9d0fb6a11bfc75da" name="af79ba492a62c286c9d0fb6a11bfc75da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af79ba492a62c286c9d0fb6a11bfc75da">&#9670;&#160;</a></span>getKeyword()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; stormm::namelist::NamelistEmulator::getKeyword </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a keyword from this namelist based on an index. This is for retrieving the keyword itself, not a value associated with a keyword. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the keyword in the list held by this namelist. In fact, this is best used to step through the list of keywords in the order they were added, not much more. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a223c0d51042cdede19e03c329529e5e6" name="a223c0d51042cdede19e03c329529e5e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a223c0d51042cdede19e03c329529e5e6">&#9670;&#160;</a></span>getKeywordEntries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stormm::namelist::NamelistEmulator::getKeywordEntries </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>keyword_query</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of entries associated with a specific keyword. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyword_query</td><td>The keyword of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b2788cdf61c64c5f60a94d149c87246" name="a9b2788cdf61c64c5f60a94d149c87246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b2788cdf61c64c5f60a94d149c87246">&#9670;&#160;</a></span>getKeywordKind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NamelistType stormm::namelist::NamelistEmulator::getKeywordKind </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>keyword_query</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the type of a specific keyword within this namelist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyword_query</td><td>The keyword of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f5f377d74fc16e5ced33a3e018f21ed" name="a3f5f377d74fc16e5ced33a3e018f21ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f5f377d74fc16e5ced33a3e018f21ed">&#9670;&#160;</a></span>getKeywordStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InputStatus stormm::namelist::NamelistEmulator::getKeywordStatus </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>keyword_query</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether a keyword has been set, be that by default or user input. </p>
<p>Overloaded:</p><ul>
<li>Get the status of the first instance of a keyword</li>
<li>Get the status of a sub-key within a keyword</li>
<li>Get the status of a specific, repeated specification of a keyword</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyword_query</td><td>The keyword of interest </td></tr>
    <tr><td class="paramname">sub_key</td><td>The keyword of interest </td></tr>
    <tr><td class="paramname">repeat_no</td><td>The number of the repetition to check for its status. This is needed only in the case of STRUCT-type keywords, as a plain INTEGER, REAL, or STRING keyword will be "established" if there is but one default or user-specified value given&ndash;subsequent applications of such a keyword are, by construction, established (status cannot be missing). In contrast, a STRUCT keyword can be specified many times, but the status of its individual members may still be inquestion if not all components of the STRUCT are given in each application. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30b7cc5b1797f8d73d651bfb402c00a0" name="a30b7cc5b1797f8d73d651bfb402c00a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30b7cc5b1797f8d73d651bfb402c00a0">&#9670;&#160;</a></span>getRealValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stormm::namelist::NamelistEmulator::getRealValue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>keyword_query</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a labeled real number value from within the namelist. </p>
<p>Overloaded:</p><ul>
<li>Get a REAL value associated with a non-STRUCT keyword</li>
<li>Get a REAL value from within a STRUCT keyword</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyword_query</td><td>Identifier of the keyword of interest </td></tr>
    <tr><td class="paramname">sub_key</td><td>Identifier for the member variable within the STRUCT of interest </td></tr>
    <tr><td class="paramname">index</td><td>For keywords that store multiple values, retrieve this value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0db9faab27fbdbe80101765d51019bb6" name="a0db9faab27fbdbe80101765d51019bb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0db9faab27fbdbe80101765d51019bb6">&#9670;&#160;</a></span>getStringValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; stormm::namelist::NamelistEmulator::getStringValue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>keyword_query</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a labeled string value from within the namelist. </p>
<p>Overloaded:</p><ul>
<li>Get a STRING value associated with a non-STRUCT keyword</li>
<li>Get a STRING value from within a STRUCT keyword</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyword_query</td><td>Identifier of the keyword of interest </td></tr>
    <tr><td class="paramname">sub_key</td><td>Identifier for the member variable within the STRUCT of interest </td></tr>
    <tr><td class="paramname">index</td><td>For keywords that store multiple values, retrieve this value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2b0d89154b2086ad2d69ba20d9f7c66" name="ab2b0d89154b2086ad2d69ba20d9f7c66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2b0d89154b2086ad2d69ba20d9f7c66">&#9670;&#160;</a></span>hasKeyword()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stormm::namelist::NamelistEmulator::hasKeyword </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>query</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether a namelist contains a particular keyword at all. </p>
<p>Overloaded:</p><ul>
<li>Test for a keyword by name only</li>
<li>Test for a named keyword of a specific type</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>The keyword to search for </td></tr>
    <tr><td class="paramname">query_kind</td><td>The type that the keyword must have if it is present </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a93bde3070e1a7fa03b5c57d75f7d69d5" name="a93bde3070e1a7fa03b5c57d75f7d69d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93bde3070e1a7fa03b5c57d75f7d69d5">&#9670;&#160;</a></span>printContents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string stormm::namelist::NamelistEmulator::printContents </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>file_width</em></span><span class="paramdefsep"> = </span><span class="paramdefval">default_output_file_width</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>max_entry_counts</em></span><span class="paramdefsep"> = </span><span class="paramdefval">4</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NamelistIntroduction</td>          <td class="paramname"><span class="paramname"><em>print_decor</em></span><span class="paramdefsep"> = </span><span class="paramdefval">NamelistIntroduction::HEADER</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a complete table of the values for all parameters in this namelist, starting including their sources (input statuses, i.e. DEFAULT, MISSING, or USER-SPECIFIED). </p>
<p>Overloaded:</p><ul>
<li>Write to a string for further processing</li>
<li>Write directly to an output file stream</li>
<li>Write to a named output file, given a state that it must be found in</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">foutp</td><td>File to which information should be printed, defaulting to the terminal </td></tr>
    <tr><td class="paramname">file_width</td><td>The width at which to print results (this parameter will be ignored and replaced with the terminal width if the output goes to the terminal) </td></tr>
    <tr><td class="paramname">max_entry_reports</td><td>The maximum number of entries to report from any given keyword </td></tr>
    <tr><td class="paramname">print_decor</td><td>Indicate whether to introduce the namelist or rely on some previous iteration writing to the same file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeefb9d69cb2fc28fa398fea35a57901e" name="aeefb9d69cb2fc28fa398fea35a57901e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeefb9d69cb2fc28fa398fea35a57901e">&#9670;&#160;</a></span>printKeywordDocumentation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::namelist::NamelistEmulator::printKeywordDocumentation </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>p_idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>name_width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>kw_kind_width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>kw_dflt</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print the documentation for a specific keyword. The format is fixed in the sense that it will have a set indentation, a dash for a bullet point, and the keyword printed in a space large enough for a series of related keywords in a column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_idx</td><td>Index of the keyword within the namelist emulator </td></tr>
    <tr><td class="paramname">name_width</td><td>Width at which to print keyword names </td></tr>
    <tr><td class="paramname">kw_kind_width</td><td>Width at which to print keyword kinds </td></tr>
    <tr><td class="paramname">kw_dflt</td><td>Default value of the parameter, pre-converted to a string and pre-pended with white space for alignment </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9026fe7e7d04c210bc6fc455dab8076a" name="a9026fe7e7d04c210bc6fc455dab8076a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9026fe7e7d04c210bc6fc455dab8076a">&#9670;&#160;</a></span>setCommandLineContent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::namelist::NamelistEmulator::setCommandLineContent </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>cli_content_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set whether the namelist actually serves command line input for a whole program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cli_content_in</td><td>Set to TRUE to indicate that the namelist does command line parsing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1370da85b55a1f96e99ced5e3e0e8e46" name="a1370da85b55a1f96e99ced5e3e0e8e46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1370da85b55a1f96e99ced5e3e0e8e46">&#9670;&#160;</a></span>setDefaultValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::namelist::NamelistEmulator::setDefaultValue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>modified_default</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>default_idx</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a default value for one of the namelist's keywords. Like <a class="el" href="classstormm_1_1namelist_1_1NamelistEmulator.html#a59f3af172a3966e79b72609bc516398a" title="Add a value to one keyword&#39;s default settings. This enables a single keyword to have a collection of ...">addDefaultValue()</a> and other functions below, the effect will be to pass through the <a class="el" href="classstormm_1_1testing_1_1NamelistEmulator.html" title="Collection of variables to transcribe information contained within a namelist.">NamelistEmulator</a> to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The name of the keyword within the namelist </td></tr>
    <tr><td class="paramname">modified_default</td><td>The new default setting to apply to the keyword </td></tr>
    <tr><td class="paramname">default_idx</td><td>The index of the default to set, in the event that there are already multiple default values </td></tr>
    <tr><td class="paramname">modified_defaults</td><td>The list of modified default values </td></tr>
    <tr><td class="paramname">sub_key_specs</td><td>The list of sub-keys to which each default corresponds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7cf89676273af57c20c32f3ed0317c87" name="a7cf89676273af57c20c32f3ed0317c87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cf89676273af57c20c32f3ed0317c87">&#9670;&#160;</a></span>setImperative()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::namelist::NamelistEmulator::setImperative </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyRequirement</td>          <td class="paramname"><span class="paramname"><em>req</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the requirement associated with a keyword. By default, all keywords are set to "REQUIRED" just as all STRUCT-type keyword subkeys are required unless stated otherwise. Even if required, many keywords, like STRUCT subkeys, will have default values that satisfy the requirements. </p>
<p>Overloaded:</p><ul>
<li>Set the criticality of a keyword</li>
<li>Set the criticality of a subkey within a STRUCT keyword</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The namelist keyword to find and alter </td></tr>
    <tr><td class="paramname">sub_key_query</td><td>Name of the sub-key to search if the namelist element is a STRUCT </td></tr>
    <tr><td class="paramname">req</td><td>The requirement level to impose </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17d56cf390a43fc124ebaedf6f8aba4b" name="a17d56cf390a43fc124ebaedf6f8aba4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17d56cf390a43fc124ebaedf6f8aba4b">&#9670;&#160;</a></span>setTitle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::namelist::NamelistEmulator::setTitle </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>title_in</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the title of the namelist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">title_in</td><td>The title to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a339eb144680793a06bc32ba5607d16d7" name="a339eb144680793a06bc32ba5607d16d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a339eb144680793a06bc32ba5607d16d7">&#9670;&#160;</a></span>triggerResizeBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::namelist::NamelistEmulator::triggerResizeBuffer </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When loading data for STRUCT-type keywords, the decision to increment the number of entries on file cannot be made with the first sub-key assignment. Instead, the entire struct must be read from input before the number of entries can be incremented. Because a function (readNamelist(), see <a class="el" href="input_8h_source.html">input.h</a>) that manages a <a class="el" href="classstormm_1_1testing_1_1NamelistEmulator.html" title="Collection of variables to transcribe information contained within a namelist.">NamelistEmulator</a> loops over the input that can be associated with each list of subk-eys for a given STRUCT, that function must go through the <a class="el" href="classstormm_1_1testing_1_1NamelistEmulator.html" title="Collection of variables to transcribe information contained within a namelist.">NamelistEmulator</a> in order to increment the keyword's entry count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The STRUCT-type keyword of interest (its membership in the namelist will be verified) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/Namelists/<a class="el" href="namelist__emulator_8h_source.html">namelist_emulator.h</a></li>
<li>src/Namelists/<b>namelist_emulator.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2
</small></address>
</div><!-- doc-content -->
</body>
</html>
