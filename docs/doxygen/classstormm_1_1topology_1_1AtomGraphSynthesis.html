<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>STORMM Source Documentation: stormm::topology::AtomGraphSynthesis Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">STORMM Source Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>stormm</b></li><li class="navelem"><b>topology</b></li><li class="navelem"><a class="el" href="classstormm_1_1topology_1_1AtomGraphSynthesis.html">AtomGraphSynthesis</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classstormm_1_1topology_1_1AtomGraphSynthesis-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">stormm::topology::AtomGraphSynthesis Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A collection of one or more <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html" title="A struct to hold information relating to an Amber topology. This struct&#39;s member functions are limite...">AtomGraph</a> objects, with similar components arranged in contiguous arrays (often padded by the GPU warp size to prevent one system from flowing into another). Work units covering all systems are laid out in additional, contiguous arrays. While individual topologies (AtomGraphs) have <a class="el" href="classstormm_1_1topology_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> POINTER-kind objects for details such as charges and atom type indices and all of the POINTER-kind objects targeted a single ARRAY-kind object of the correct memory type, the synthesis, which may have many topologies and a great deal more overall information, stores most of its data in a series of ARRAY-kind objects, one for each member variable.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="atomgraph__synthesis_8h_source.html">atomgraph_synthesis.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4a4633c2f22aeff8976069ffee2c2f49" id="r_a4a4633c2f22aeff8976069ffee2c2f49"><td class="memItemLeft" align="right" valign="top"><a id="a4a4633c2f22aeff8976069ffee2c2f49" name="a4a4633c2f22aeff8976069ffee2c2f49"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getUniqueTopologyCount</b> () const</td></tr>
<tr class="memdesc:a4a4633c2f22aeff8976069ffee2c2f49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of unique topologies described by the synthesis. <br /></td></tr>
<tr class="separator:a4a4633c2f22aeff8976069ffee2c2f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8a1888eb2bb0dbf66c7c2a1f81fdc8" id="r_a2c8a1888eb2bb0dbf66c7c2a1f81fdc8"><td class="memItemLeft" align="right" valign="top"><a id="a2c8a1888eb2bb0dbf66c7c2a1f81fdc8" name="a2c8a1888eb2bb0dbf66c7c2a1f81fdc8"></a>
const std::vector&lt; <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getUniqueTopologies</b> () const</td></tr>
<tr class="memdesc:a2c8a1888eb2bb0dbf66c7c2a1f81fdc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reference to the list of all pointers for unique topologies making up this synthesis. <br /></td></tr>
<tr class="separator:a2c8a1888eb2bb0dbf66c7c2a1f81fdc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0431679c33272a09c7ea282d1b90b5b7" id="r_a0431679c33272a09c7ea282d1b90b5b7"><td class="memItemLeft" align="right" valign="top"><a id="a0431679c33272a09c7ea282d1b90b5b7" name="a0431679c33272a09c7ea282d1b90b5b7"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getTopologyIndices</b> () const</td></tr>
<tr class="memdesc:a0431679c33272a09c7ea282d1b90b5b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reference to the list of all topology indices, indicating the topologies describing each systems contained within this synthesis. <br /></td></tr>
<tr class="separator:a0431679c33272a09c7ea282d1b90b5b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa47ba93c544998ca27df5963db48da5c" id="r_aa47ba93c544998ca27df5963db48da5c"><td class="memItemLeft" align="right" valign="top">RestraintApparatus *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa47ba93c544998ca27df5963db48da5c">getSystemRestraintPointer</a> (int system_index) const</td></tr>
<tr class="memdesc:aa47ba93c544998ca27df5963db48da5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a restraint apparatus pointer for a sepcific system contained within the synthesis.  <br /></td></tr>
<tr class="separator:aa47ba93c544998ca27df5963db48da5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca313f84036eb74fe79654d8d37bb2b" id="r_a9ca313f84036eb74fe79654d8d37bb2b"><td class="memItemLeft" align="right" valign="top"><a id="a9ca313f84036eb74fe79654d8d37bb2b" name="a9ca313f84036eb74fe79654d8d37bb2b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getSystemCount</b> () const</td></tr>
<tr class="memdesc:a9ca313f84036eb74fe79654d8d37bb2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of systems that this synthesis describes. <br /></td></tr>
<tr class="separator:a9ca313f84036eb74fe79654d8d37bb2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95adbd6cd34c6558ada99e276ec1926d" id="r_a95adbd6cd34c6558ada99e276ec1926d"><td class="memItemLeft" align="right" valign="top"><a id="a95adbd6cd34c6558ada99e276ec1926d" name="a95adbd6cd34c6558ada99e276ec1926d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getPaddedAtomCount</b> () const</td></tr>
<tr class="memdesc:a95adbd6cd34c6558ada99e276ec1926d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the entire padded number of atoms covering all systems. <br /></td></tr>
<tr class="separator:a95adbd6cd34c6558ada99e276ec1926d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d392d284f3f623944da8338973ba4fa" id="r_a4d392d284f3f623944da8338973ba4fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d392d284f3f623944da8338973ba4fa">getAtomOffset</a> (int system_index) const</td></tr>
<tr class="memdesc:a4d392d284f3f623944da8338973ba4fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the starting point for atoms of a specific system in the lineup of all topologies.  <br /></td></tr>
<tr class="separator:a4d392d284f3f623944da8338973ba4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f96a9f596147133580fa3a973a621a" id="r_ad7f96a9f596147133580fa3a973a621a"><td class="memItemLeft" align="right" valign="top"><a id="ad7f96a9f596147133580fa3a973a621a" name="ad7f96a9f596147133580fa3a973a621a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getVirtualSiteCount</b> () const</td></tr>
<tr class="memdesc:ad7f96a9f596147133580fa3a973a621a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of virtual sites across all systems, including replicas. <br /></td></tr>
<tr class="separator:ad7f96a9f596147133580fa3a973a621a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03eb954aa3211ab03f8941d5548a237f" id="r_a03eb954aa3211ab03f8941d5548a237f"><td class="memItemLeft" align="right" valign="top"><a id="a03eb954aa3211ab03f8941d5548a237f" name="a03eb954aa3211ab03f8941d5548a237f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getBondTermCount</b> () const</td></tr>
<tr class="memdesc:a03eb954aa3211ab03f8941d5548a237f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of bond terms across all systems, including replicas. <br /></td></tr>
<tr class="separator:a03eb954aa3211ab03f8941d5548a237f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae81acfc13c3bc276a27fc401a7bb0db4" id="r_ae81acfc13c3bc276a27fc401a7bb0db4"><td class="memItemLeft" align="right" valign="top"><a id="ae81acfc13c3bc276a27fc401a7bb0db4" name="ae81acfc13c3bc276a27fc401a7bb0db4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getAngleTermCount</b> () const</td></tr>
<tr class="memdesc:ae81acfc13c3bc276a27fc401a7bb0db4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of bond angle terms across all systems, including replicas. <br /></td></tr>
<tr class="separator:ae81acfc13c3bc276a27fc401a7bb0db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c8e89b8593f3885efced2ac65d73bc8" id="r_a5c8e89b8593f3885efced2ac65d73bc8"><td class="memItemLeft" align="right" valign="top"><a id="a5c8e89b8593f3885efced2ac65d73bc8" name="a5c8e89b8593f3885efced2ac65d73bc8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getDihedralTermCount</b> () const</td></tr>
<tr class="memdesc:a5c8e89b8593f3885efced2ac65d73bc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of cosine-based dihedral terms across all systems and replicas. <br /></td></tr>
<tr class="separator:a5c8e89b8593f3885efced2ac65d73bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81532655a847c1728e7191251f8f2372" id="r_a81532655a847c1728e7191251f8f2372"><td class="memItemLeft" align="right" valign="top"><a id="a81532655a847c1728e7191251f8f2372" name="a81532655a847c1728e7191251f8f2372"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getUreyBradleyTermCount</b> () const</td></tr>
<tr class="memdesc:a81532655a847c1728e7191251f8f2372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of Urey-Bradley terms across all systems and replicas. <br /></td></tr>
<tr class="separator:a81532655a847c1728e7191251f8f2372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafbf6ee370995b748f26b035913343e1" id="r_aafbf6ee370995b748f26b035913343e1"><td class="memItemLeft" align="right" valign="top"><a id="aafbf6ee370995b748f26b035913343e1" name="aafbf6ee370995b748f26b035913343e1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getCharmmImproperTermCount</b> () const</td></tr>
<tr class="memdesc:aafbf6ee370995b748f26b035913343e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of CHARMM improper terms across all systems and replicas. <br /></td></tr>
<tr class="separator:aafbf6ee370995b748f26b035913343e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace62e8342dbc9b330fcf3e82dffaaf60" id="r_ace62e8342dbc9b330fcf3e82dffaaf60"><td class="memItemLeft" align="right" valign="top"><a id="ace62e8342dbc9b330fcf3e82dffaaf60" name="ace62e8342dbc9b330fcf3e82dffaaf60"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getCmapTermCount</b> () const</td></tr>
<tr class="memdesc:ace62e8342dbc9b330fcf3e82dffaaf60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of CMAP terms across all systems and replicas. <br /></td></tr>
<tr class="separator:ace62e8342dbc9b330fcf3e82dffaaf60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a069f45a0130ba16f92562dec7b936624" id="r_a069f45a0130ba16f92562dec7b936624"><td class="memItemLeft" align="right" valign="top"><a id="a069f45a0130ba16f92562dec7b936624" name="a069f45a0130ba16f92562dec7b936624"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getLJTypeCount</b> () const</td></tr>
<tr class="memdesc:a069f45a0130ba16f92562dec7b936624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of unique atom types (a parameter, not an extensive quantity dependent on the number of systems). <br /></td></tr>
<tr class="separator:a069f45a0130ba16f92562dec7b936624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723c7ca984d34880a7fe374b9ccc051e" id="r_a723c7ca984d34880a7fe374b9ccc051e"><td class="memItemLeft" align="right" valign="top"><a id="a723c7ca984d34880a7fe374b9ccc051e" name="a723c7ca984d34880a7fe374b9ccc051e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getChargeTypeCount</b> () const</td></tr>
<tr class="memdesc:a723c7ca984d34880a7fe374b9ccc051e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of unique charge parameters. <br /></td></tr>
<tr class="separator:a723c7ca984d34880a7fe374b9ccc051e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01e299ec26cb339b2510b014d5cd7536" id="r_a01e299ec26cb339b2510b014d5cd7536"><td class="memItemLeft" align="right" valign="top"><a id="a01e299ec26cb339b2510b014d5cd7536" name="a01e299ec26cb339b2510b014d5cd7536"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getBondParameterCount</b> () const</td></tr>
<tr class="memdesc:a01e299ec26cb339b2510b014d5cd7536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of unique harmonic bond parameter sets. <br /></td></tr>
<tr class="separator:a01e299ec26cb339b2510b014d5cd7536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aace71d343ccd95eceaf1914409e9cdba" id="r_aace71d343ccd95eceaf1914409e9cdba"><td class="memItemLeft" align="right" valign="top"><a id="aace71d343ccd95eceaf1914409e9cdba" name="aace71d343ccd95eceaf1914409e9cdba"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getAngleParameterCount</b> () const</td></tr>
<tr class="memdesc:aace71d343ccd95eceaf1914409e9cdba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of unique harmonic bond angle parameter sets. <br /></td></tr>
<tr class="separator:aace71d343ccd95eceaf1914409e9cdba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4169ced33eecdb8814803c1eda3b653e" id="r_a4169ced33eecdb8814803c1eda3b653e"><td class="memItemLeft" align="right" valign="top"><a id="a4169ced33eecdb8814803c1eda3b653e" name="a4169ced33eecdb8814803c1eda3b653e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getDihedralParameterCount</b> () const</td></tr>
<tr class="memdesc:a4169ced33eecdb8814803c1eda3b653e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of unique cosine-based dihedral parameter sets. <br /></td></tr>
<tr class="separator:a4169ced33eecdb8814803c1eda3b653e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9829c989ce866946dca29d6c5eacda2" id="r_ab9829c989ce866946dca29d6c5eacda2"><td class="memItemLeft" align="right" valign="top"><a id="ab9829c989ce866946dca29d6c5eacda2" name="ab9829c989ce866946dca29d6c5eacda2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getUreyBradleyParameterCount</b> () const</td></tr>
<tr class="memdesc:ab9829c989ce866946dca29d6c5eacda2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of unique Urey-Bradley harmonic angle parameter sets. <br /></td></tr>
<tr class="separator:ab9829c989ce866946dca29d6c5eacda2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57bfaf04f2f746de8ae47c8558c8320" id="r_ab57bfaf04f2f746de8ae47c8558c8320"><td class="memItemLeft" align="right" valign="top"><a id="ab57bfaf04f2f746de8ae47c8558c8320" name="ab57bfaf04f2f746de8ae47c8558c8320"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getCharmmImproperParameterCount</b> () const</td></tr>
<tr class="memdesc:ab57bfaf04f2f746de8ae47c8558c8320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of unique CHARMM improper parameter sets. <br /></td></tr>
<tr class="separator:ab57bfaf04f2f746de8ae47c8558c8320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69a051722155edb0d58710e5a4567731" id="r_a69a051722155edb0d58710e5a4567731"><td class="memItemLeft" align="right" valign="top"><a id="a69a051722155edb0d58710e5a4567731" name="a69a051722155edb0d58710e5a4567731"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getCmapSurfaceCount</b> () const</td></tr>
<tr class="memdesc:a69a051722155edb0d58710e5a4567731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of unique CMAP surfaces. <br /></td></tr>
<tr class="separator:a69a051722155edb0d58710e5a4567731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3726d291474236dbad82a7553c05f993" id="r_a3726d291474236dbad82a7553c05f993"><td class="memItemLeft" align="right" valign="top"><a id="a3726d291474236dbad82a7553c05f993" name="a3726d291474236dbad82a7553c05f993"></a>
const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getSystemAtomCounts</b> () const</td></tr>
<tr class="memdesc:a3726d291474236dbad82a7553c05f993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sizes of all individual systems as a const reference to the <a class="el" href="classstormm_1_1topology_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> array member variable. <br /></td></tr>
<tr class="separator:a3726d291474236dbad82a7553c05f993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77fb3d7081baec7ef751d2e3aaca678e" id="r_a77fb3d7081baec7ef751d2e3aaca678e"><td class="memItemLeft" align="right" valign="top"><a id="a77fb3d7081baec7ef751d2e3aaca678e" name="a77fb3d7081baec7ef751d2e3aaca678e"></a>
const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getSystemAtomOffsets</b> () const</td></tr>
<tr class="memdesc:a77fb3d7081baec7ef751d2e3aaca678e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the starting locations of all individual systems as a const reference to the <a class="el" href="classstormm_1_1topology_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> array member variable. <br /></td></tr>
<tr class="separator:a77fb3d7081baec7ef751d2e3aaca678e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7ed7408dc055186c46477a493842de" id="r_aaa7ed7408dc055186c46477a493842de"><td class="memItemLeft" align="right" valign="top"><a id="aaa7ed7408dc055186c46477a493842de" name="aaa7ed7408dc055186c46477a493842de"></a>
const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getDegreesOfFreedom</b> () const</td></tr>
<tr class="memdesc:aaa7ed7408dc055186c46477a493842de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the numbers of unconstrained degrees of freedom for all individual systems in the. <br /></td></tr>
<tr class="separator:aaa7ed7408dc055186c46477a493842de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a499040b02b296e4e2ada7e068a458c04" id="r_a499040b02b296e4e2ada7e068a458c04"><td class="memItemLeft" align="right" valign="top"><a id="a499040b02b296e4e2ada7e068a458c04" name="a499040b02b296e4e2ada7e068a458c04"></a>
const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getConstrainedDegreesOfFreedom</b> () const</td></tr>
<tr class="memdesc:a499040b02b296e4e2ada7e068a458c04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the numbers of constrained degrees of freedom for all individual systems in the. <br /></td></tr>
<tr class="separator:a499040b02b296e4e2ada7e068a458c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14765e7b70fa0e23001996eaf8ee1e27" id="r_a14765e7b70fa0e23001996eaf8ee1e27"><td class="memItemLeft" align="right" valign="top"><a id="a14765e7b70fa0e23001996eaf8ee1e27" name="a14765e7b70fa0e23001996eaf8ee1e27"></a>
UnitCellType&#160;</td><td class="memItemRight" valign="bottom"><b>getUnitCellType</b> () const</td></tr>
<tr class="memdesc:a14765e7b70fa0e23001996eaf8ee1e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unit cell type that will be taken for all systems (TRICLINIC subsumes ORTHORHOMBIC in a sort of type promotion). <br /></td></tr>
<tr class="separator:a14765e7b70fa0e23001996eaf8ee1e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb0924747ca29fab8ae0e967b9b8a37" id="r_a4cb0924747ca29fab8ae0e967b9b8a37"><td class="memItemLeft" align="right" valign="top"><a id="a4cb0924747ca29fab8ae0e967b9b8a37" name="a4cb0924747ca29fab8ae0e967b9b8a37"></a>
ImplicitSolventModel&#160;</td><td class="memItemRight" valign="bottom"><b>getImplicitSolventModel</b> () const</td></tr>
<tr class="memdesc:a4cb0924747ca29fab8ae0e967b9b8a37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the implicit solvent model in use across all systems. <br /></td></tr>
<tr class="separator:a4cb0924747ca29fab8ae0e967b9b8a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa94b217f3c0cc083691334b7181a8bfd" id="r_aa94b217f3c0cc083691334b7181a8bfd"><td class="memItemLeft" align="right" valign="top"><a id="aa94b217f3c0cc083691334b7181a8bfd" name="aa94b217f3c0cc083691334b7181a8bfd"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getDielectricConstant</b> () const</td></tr>
<tr class="memdesc:aa94b217f3c0cc083691334b7181a8bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dielectric constant (supporting the implicit solvent model) for all systems. <br /></td></tr>
<tr class="separator:aa94b217f3c0cc083691334b7181a8bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a4dcc54a4bb9789b05869a2452e3fd4" id="r_a2a4dcc54a4bb9789b05869a2452e3fd4"><td class="memItemLeft" align="right" valign="top"><a id="a2a4dcc54a4bb9789b05869a2452e3fd4" name="a2a4dcc54a4bb9789b05869a2452e3fd4"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getSaltConcentration</b> () const</td></tr>
<tr class="memdesc:a2a4dcc54a4bb9789b05869a2452e3fd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the salt concentration (supporting the implicit solvent model) for all systems. <br /></td></tr>
<tr class="separator:a2a4dcc54a4bb9789b05869a2452e3fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72fce8914926162ca79911ff8db47128" id="r_a72fce8914926162ca79911ff8db47128"><td class="memItemLeft" align="right" valign="top"><a id="a72fce8914926162ca79911ff8db47128" name="a72fce8914926162ca79911ff8db47128"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getCoulombConstant</b> () const</td></tr>
<tr class="memdesc:a72fce8914926162ca79911ff8db47128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the fundamental Coulomb constant defining the electrostatics of all systems. <br /></td></tr>
<tr class="separator:a72fce8914926162ca79911ff8db47128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35be6e55d6186ce3d627759975cb35d3" id="r_a35be6e55d6186ce3d627759975cb35d3"><td class="memItemLeft" align="right" valign="top"><a id="a35be6e55d6186ce3d627759975cb35d3" name="a35be6e55d6186ce3d627759975cb35d3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getValenceWorkUnitCount</b> () const</td></tr>
<tr class="memdesc:a35be6e55d6186ce3d627759975cb35d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the overall number of valence work units needed to account for interactions in all systems. <br /></td></tr>
<tr class="separator:a35be6e55d6186ce3d627759975cb35d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b22a49d9a32b1e86e06579d1779629" id="r_ad5b22a49d9a32b1e86e06579d1779629"><td class="memItemLeft" align="right" valign="top"><a id="ad5b22a49d9a32b1e86e06579d1779629" name="ad5b22a49d9a32b1e86e06579d1779629"></a>
<a class="el" href="structstormm_1_1data__types_1_1int2.html">int2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getValenceWorkUnitSize</b> () const</td></tr>
<tr class="memdesc:ad5b22a49d9a32b1e86e06579d1779629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum size of valence work units, whether for organic molecules or solvent (rigid water) residues. This will have been either set by the user or tailored by the automated heuristics to produce the best saturation. <br /></td></tr>
<tr class="separator:ad5b22a49d9a32b1e86e06579d1779629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c5e5820fd2973f662394581aecfcbc" id="r_ab3c5e5820fd2973f662394581aecfcbc"><td class="memItemLeft" align="right" valign="top"><a id="ab3c5e5820fd2973f662394581aecfcbc" name="ab3c5e5820fd2973f662394581aecfcbc"></a>
ValenceKernelSize&#160;</td><td class="memItemRight" valign="bottom"><b>getValenceThreadBlockSize</b> () const</td></tr>
<tr class="memdesc:ab3c5e5820fd2973f662394581aecfcbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the necessary thread block size for evaluating the valence work units. <br /></td></tr>
<tr class="separator:ab3c5e5820fd2973f662394581aecfcbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf4ab339900554ffd08fcbf6428b6912" id="r_adf4ab339900554ffd08fcbf6428b6912"><td class="memItemLeft" align="right" valign="top"><a id="adf4ab339900554ffd08fcbf6428b6912" name="adf4ab339900554ffd08fcbf6428b6912"></a>
const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; <a class="el" href="structstormm_1_1data__types_1_1int2.html">int2</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getValenceWorkUnitAbstracts</b> () const</td></tr>
<tr class="memdesc:adf4ab339900554ffd08fcbf6428b6912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the abstracts (condensed lists of import and instruction set limits) for the valence work units spanning all systems in this synthesis. <br /></td></tr>
<tr class="separator:adf4ab339900554ffd08fcbf6428b6912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a6bea67edfcfd216c5e10009af8493" id="r_a56a6bea67edfcfd216c5e10009af8493"><td class="memItemLeft" align="right" valign="top"><a id="a56a6bea67edfcfd216c5e10009af8493" name="a56a6bea67edfcfd216c5e10009af8493"></a>
NbwuKind&#160;</td><td class="memItemRight" valign="bottom"><b>getNonbondedWorkType</b> () const</td></tr>
<tr class="memdesc:a56a6bea67edfcfd216c5e10009af8493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of non-bonded work required by systems in this synthesis. <br /></td></tr>
<tr class="separator:a56a6bea67edfcfd216c5e10009af8493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815e6677e4b402a9ba4c410784f26cb8" id="r_a815e6677e4b402a9ba4c410784f26cb8"><td class="memItemLeft" align="right" valign="top"><a id="a815e6677e4b402a9ba4c410784f26cb8" name="a815e6677e4b402a9ba4c410784f26cb8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getNonbondedWorkUnitCount</b> () const</td></tr>
<tr class="memdesc:a815e6677e4b402a9ba4c410784f26cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of non-bonded work units serving systems in this synthesis. <br /></td></tr>
<tr class="separator:a815e6677e4b402a9ba4c410784f26cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b4f3653f4768f3eb8c95ebdcd90d16" id="r_a24b4f3653f4768f3eb8c95ebdcd90d16"><td class="memItemLeft" align="right" valign="top"><a id="a24b4f3653f4768f3eb8c95ebdcd90d16" name="a24b4f3653f4768f3eb8c95ebdcd90d16"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getRandomCacheDepth</b> () const</td></tr>
<tr class="memdesc:a24b4f3653f4768f3eb8c95ebdcd90d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the depth of the random numbers cache that the non-bonded work units of this topology synthesis will try to fill. This will raise a warning and return zero if no cache depth has yet been set. <br /></td></tr>
<tr class="separator:a24b4f3653f4768f3eb8c95ebdcd90d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc6b402c91c5faa5e4240b4b2606f1c5" id="r_adc6b402c91c5faa5e4240b4b2606f1c5"><td class="memItemLeft" align="right" valign="top"><a id="adc6b402c91c5faa5e4240b4b2606f1c5" name="adc6b402c91c5faa5e4240b4b2606f1c5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getReductionWorkUnitCount</b> () const</td></tr>
<tr class="memdesc:adc6b402c91c5faa5e4240b4b2606f1c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of reduction work units spanning all systems. <br /></td></tr>
<tr class="separator:adc6b402c91c5faa5e4240b4b2606f1c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad18d6351087368520003636958381fdf" id="r_ad18d6351087368520003636958381fdf"><td class="memItemLeft" align="right" valign="top"><a id="ad18d6351087368520003636958381fdf" name="ad18d6351087368520003636958381fdf"></a>
RdwuPerSystem&#160;</td><td class="memItemRight" valign="bottom"><b>getRdwuPerSystem</b> () const</td></tr>
<tr class="memdesc:ad18d6351087368520003636958381fdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a qualitative assessment of the number of reduction work units assigned to any one system. <br /></td></tr>
<tr class="separator:ad18d6351087368520003636958381fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd340851327930aaf54d6c7344c009ea" id="r_abd340851327930aaf54d6c7344c009ea"><td class="memItemLeft" align="right" valign="top"><a id="abd340851327930aaf54d6c7344c009ea" name="abd340851327930aaf54d6c7344c009ea"></a>
const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getReductionWorkUnitAbstracts</b> () const</td></tr>
<tr class="memdesc:abd340851327930aaf54d6c7344c009ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the reduction work unit abstracts (this is not required for valence or non-bonded work units as the abstracts needed for implementing these work units are produced by member functions of this class (see below). The reduction work, however, is managed by an abstract splicing together elements of this class, <a class="el" href="classstormm_1_1synthesis_1_1PhaseSpaceSynthesis.html" title="A fixed-precision representation of coordinates, velocities, and forces to manage a set of simulation...">PhaseSpaceSynthesis</a>, and a small class allocating temporary storage space. <br /></td></tr>
<tr class="separator:abd340851327930aaf54d6c7344c009ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a7d03cb157bafa5e7292a78b2481e6" id="r_ac3a7d03cb157bafa5e7292a78b2481e6"><td class="memItemLeft" align="right" valign="top">SyValenceKit&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3a7d03cb157bafa5e7292a78b2481e6">getDoublePrecisionValenceKit</a> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:ac3a7d03cb157bafa5e7292a78b2481e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a minimal kit with double-precision parameter detail for computing valence interactions for all systems based on the work units stored in this object.  <br /></td></tr>
<tr class="separator:ac3a7d03cb157bafa5e7292a78b2481e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f99e256440f87f8d25be1c76937446" id="r_a58f99e256440f87f8d25be1c76937446"><td class="memItemLeft" align="right" valign="top">SyValenceKit&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58f99e256440f87f8d25be1c76937446">getSinglePrecisionValenceKit</a> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:a58f99e256440f87f8d25be1c76937446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a minimal kit with single-precision parameter detail for computing valence interactions for all systems based on the work units stored in this object.  <br /></td></tr>
<tr class="separator:a58f99e256440f87f8d25be1c76937446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a118050bd464ad1a1d0de5daf5e385633" id="r_a118050bd464ad1a1d0de5daf5e385633"><td class="memItemLeft" align="right" valign="top">SyRestraintKit&lt; double, <a class="el" href="structstormm_1_1data__types_1_1double2.html">double2</a>, <a class="el" href="structstormm_1_1data__types_1_1double4.html">double4</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a118050bd464ad1a1d0de5daf5e385633">getDoublePrecisionRestraintKit</a> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:a118050bd464ad1a1d0de5daf5e385633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a minimal kit with double-precision parameter detail for computing valence interactions for all systems based on the work units stored in this object.  <br /></td></tr>
<tr class="separator:a118050bd464ad1a1d0de5daf5e385633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac416b7fde97df6d28f123bc6b7696eec" id="r_ac416b7fde97df6d28f123bc6b7696eec"><td class="memItemLeft" align="right" valign="top">SyRestraintKit&lt; float, <a class="el" href="structstormm_1_1data__types_1_1float2.html">float2</a>, <a class="el" href="structstormm_1_1data__types_1_1float4.html">float4</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac416b7fde97df6d28f123bc6b7696eec">getSinglePrecisionRestraintKit</a> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:ac416b7fde97df6d28f123bc6b7696eec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a minimal kit with single-precision parameter detail for computing valence interactions for all systems based on the work units stored in this object.  <br /></td></tr>
<tr class="separator:ac416b7fde97df6d28f123bc6b7696eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a7201cb38537842ef60b7f25684799" id="r_a28a7201cb38537842ef60b7f25684799"><td class="memItemLeft" align="right" valign="top">SyNonbondedKit&lt; double, <a class="el" href="structstormm_1_1data__types_1_1double2.html">double2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28a7201cb38537842ef60b7f25684799">getDoublePrecisionNonbondedKit</a> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:a28a7201cb38537842ef60b7f25684799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a minimal kit with double-precision real numbers for computing non-bonded interactions for all systems based on work units stored in this object.  <br /></td></tr>
<tr class="separator:a28a7201cb38537842ef60b7f25684799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b6f4b16ae53cdd5ba1153fe24a35dc6" id="r_a8b6f4b16ae53cdd5ba1153fe24a35dc6"><td class="memItemLeft" align="right" valign="top">SyNonbondedKit&lt; float, <a class="el" href="structstormm_1_1data__types_1_1float2.html">float2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b6f4b16ae53cdd5ba1153fe24a35dc6">getSinglePrecisionNonbondedKit</a> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:a8b6f4b16ae53cdd5ba1153fe24a35dc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a minimal kit with single-precision real numbers for computing non-bonded interactions for all systems based on work units stored in this object.  <br /></td></tr>
<tr class="separator:a8b6f4b16ae53cdd5ba1153fe24a35dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d69caedec16b88165738a75ba1ee56e" id="r_a6d69caedec16b88165738a75ba1ee56e"><td class="memItemLeft" align="right" valign="top">SyAtomUpdateKit&lt; double, <a class="el" href="structstormm_1_1data__types_1_1double2.html">double2</a>, <a class="el" href="structstormm_1_1data__types_1_1double4.html">double4</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d69caedec16b88165738a75ba1ee56e">getDoublePrecisionAtomUpdateKit</a> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:a6d69caedec16b88165738a75ba1ee56e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a minimal kit with double-precision real numbers for updating atom and virtual site positions based on work units stored in this object.  <br /></td></tr>
<tr class="separator:a6d69caedec16b88165738a75ba1ee56e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da6c022fbb95678dcfd8d4d5a68766e" id="r_a9da6c022fbb95678dcfd8d4d5a68766e"><td class="memItemLeft" align="right" valign="top">SyAtomUpdateKit&lt; float, <a class="el" href="structstormm_1_1data__types_1_1float2.html">float2</a>, <a class="el" href="structstormm_1_1data__types_1_1float4.html">float4</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9da6c022fbb95678dcfd8d4d5a68766e">getSinglePrecisionAtomUpdateKit</a> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:a9da6c022fbb95678dcfd8d4d5a68766e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a minimal kit with single-precision real numbers for updating atom and virtual site positions based on work units stored in this object.  <br /></td></tr>
<tr class="separator:a9da6c022fbb95678dcfd8d4d5a68766e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b63ba1b0ed598342cf9a4a7c1941d0e" id="r_a5b63ba1b0ed598342cf9a4a7c1941d0e"><td class="memItemLeft" align="right" valign="top"><a id="a5b63ba1b0ed598342cf9a4a7c1941d0e" name="a5b63ba1b0ed598342cf9a4a7c1941d0e"></a>
const <a class="el" href="classstormm_1_1synthesis_1_1AtomGraphSynthesis.html">AtomGraphSynthesis</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getSelfPointer</b> () const</td></tr>
<tr class="memdesc:a5b63ba1b0ed598342cf9a4a7c1941d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const pointer to the object itself, useful for retrieving a valid pointer when the object is available as a const reference. <br /></td></tr>
<tr class="separator:a5b63ba1b0ed598342cf9a4a7c1941d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc5f4e8678a70f4ca0ff4aa820c2402" id="r_accc5f4e8678a70f4ca0ff4aa820c2402"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#accc5f4e8678a70f4ca0ff4aa820c2402">loadNonbondedWorkUnits</a> (const StaticExclusionMaskSynthesis &amp;poly_se, InitializationTask init_request=InitializationTask::NONE, int random_cache_depth=0, const GpuDetails &amp;gpu=null_gpu)</td></tr>
<tr class="memdesc:accc5f4e8678a70f4ca0ff4aa820c2402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct non-bonded work units for all unique topologies (there are no restraints for non-bonded interactions that might distinguish systems with the same topology, as was a consideration when developing the valence work units). Load the instructions into the topology synthesis for availability on the GPU.  <br /></td></tr>
<tr class="separator:accc5f4e8678a70f4ca0ff4aa820c2402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a489c320f4ee879fc5b6aff5b0f9a9bce" id="r_a489c320f4ee879fc5b6aff5b0f9a9bce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a489c320f4ee879fc5b6aff5b0f9a9bce">AtomGraphSynthesis</a> (const std::vector&lt; <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> * &gt; &amp;topologies_in, const std::vector&lt; RestraintApparatus * &gt; &amp;restraints_in, const std::vector&lt; int &gt; &amp;topology_indices_in, const std::vector&lt; int &gt; &amp;restraint_indices_in, ExceptionResponse policy_in=ExceptionResponse::WARN, const GpuDetails &amp;gpu=null_gpu, StopWatch *timer_in=nullptr)</td></tr>
<tr class="memdesc:a489c320f4ee879fc5b6aff5b0f9a9bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructor takes a series of topologies and NMR restraints. The NMR restraints point to specific topologies and thereby apply to any coordinate sets that also point to those topologies.  <br /></td></tr>
<tr class="separator:a489c320f4ee879fc5b6aff5b0f9a9bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d9cda87003f7547a4d1e2b211329da3" id="r_a9d9cda87003f7547a4d1e2b211329da3"><td class="memItemLeft" align="right" valign="top"><a id="a9d9cda87003f7547a4d1e2b211329da3" name="a9d9cda87003f7547a4d1e2b211329da3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AtomGraphSynthesis</b> (const std::vector&lt; <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> * &gt; &amp;topologies_in, const std::vector&lt; RestraintApparatus * &gt; &amp;restraints_in, ExceptionResponse policy_in=ExceptionResponse::WARN, const GpuDetails &amp;gpu=null_gpu, StopWatch *timer_in=nullptr)</td></tr>
<tr class="separator:a9d9cda87003f7547a4d1e2b211329da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8b721d1fc9f44364a91458cba2c8fa" id="r_afa8b721d1fc9f44364a91458cba2c8fa"><td class="memItemLeft" align="right" valign="top"><a id="afa8b721d1fc9f44364a91458cba2c8fa" name="afa8b721d1fc9f44364a91458cba2c8fa"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AtomGraphSynthesis</b> (const std::vector&lt; <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> * &gt; &amp;topologies_in, const std::vector&lt; int &gt; &amp;topology_indices_in, ExceptionResponse policy_in=ExceptionResponse::WARN, const GpuDetails &amp;gpu=null_gpu, StopWatch *timer_in=nullptr)</td></tr>
<tr class="separator:afa8b721d1fc9f44364a91458cba2c8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40d5b6f59a286e532ca479f87ff4a36b" id="r_a40d5b6f59a286e532ca479f87ff4a36b"><td class="memItemLeft" align="right" valign="top"><a id="a40d5b6f59a286e532ca479f87ff4a36b" name="a40d5b6f59a286e532ca479f87ff4a36b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AtomGraphSynthesis</b> (const std::vector&lt; <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> * &gt; &amp;topologies_in, ExceptionResponse policy_in=ExceptionResponse::WARN, const GpuDetails &amp;gpu=null_gpu, StopWatch *timer_in=nullptr)</td></tr>
<tr class="separator:a40d5b6f59a286e532ca479f87ff4a36b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a02aa078a924bfbdefcce4dd0dd917c02" id="r_a02aa078a924bfbdefcce4dd0dd917c02"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02aa078a924bfbdefcce4dd0dd917c02">AtomGraphSynthesis</a> (const <a class="el" href="classstormm_1_1synthesis_1_1AtomGraphSynthesis.html">AtomGraphSynthesis</a> &amp;original)</td></tr>
<tr class="memdesc:a02aa078a924bfbdefcce4dd0dd917c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">The presence of POINTER-kind <a class="el" href="classstormm_1_1topology_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> objects necessitates manually written copy and move constructors as well as copy and move assignment operators, but all are valid.  <br /></td></tr>
<tr class="separator:a02aa078a924bfbdefcce4dd0dd917c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4201d14e1c5c0e9f89fec8a2f82a6cb0" id="r_a4201d14e1c5c0e9f89fec8a2f82a6cb0"><td class="memItemLeft" align="right" valign="top"><a id="a4201d14e1c5c0e9f89fec8a2f82a6cb0" name="a4201d14e1c5c0e9f89fec8a2f82a6cb0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AtomGraphSynthesis</b> (<a class="el" href="classstormm_1_1synthesis_1_1AtomGraphSynthesis.html">AtomGraphSynthesis</a> &amp;&amp;original)</td></tr>
<tr class="separator:a4201d14e1c5c0e9f89fec8a2f82a6cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef9d65f2a5e2b45fa9dada76dce1fe72" id="r_aef9d65f2a5e2b45fa9dada76dce1fe72"><td class="memItemLeft" align="right" valign="top"><a id="aef9d65f2a5e2b45fa9dada76dce1fe72" name="aef9d65f2a5e2b45fa9dada76dce1fe72"></a>
<a class="el" href="classstormm_1_1synthesis_1_1AtomGraphSynthesis.html">AtomGraphSynthesis</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classstormm_1_1synthesis_1_1AtomGraphSynthesis.html">AtomGraphSynthesis</a> &amp;original)</td></tr>
<tr class="separator:aef9d65f2a5e2b45fa9dada76dce1fe72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94e6aaac9e03dc829560094325cf889" id="r_af94e6aaac9e03dc829560094325cf889"><td class="memItemLeft" align="right" valign="top"><a id="af94e6aaac9e03dc829560094325cf889" name="af94e6aaac9e03dc829560094325cf889"></a>
<a class="el" href="classstormm_1_1synthesis_1_1AtomGraphSynthesis.html">AtomGraphSynthesis</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classstormm_1_1synthesis_1_1AtomGraphSynthesis.html">AtomGraphSynthesis</a> &amp;&amp;original)</td></tr>
<tr class="separator:af94e6aaac9e03dc829560094325cf889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac9da34c22530dbbfdaebe6be32e146fa" id="r_ac9da34c22530dbbfdaebe6be32e146fa"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9da34c22530dbbfdaebe6be32e146fa">getSystemTopologyPointer</a> (int system_index) const</td></tr>
<tr class="memdesc:ac9da34c22530dbbfdaebe6be32e146fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a topology pointer for a specific system contained within the synthesis.  <br /></td></tr>
<tr class="separator:ac9da34c22530dbbfdaebe6be32e146fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d01e4adf4f5e5c3d634e6ee458a02f" id="r_a63d01e4adf4f5e5c3d634e6ee458a02f"><td class="memItemLeft" align="right" valign="top"><a id="a63d01e4adf4f5e5c3d634e6ee458a02f" name="a63d01e4adf4f5e5c3d634e6ee458a02f"></a>
const std::vector&lt; <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getSystemTopologyPointer</b> () const</td></tr>
<tr class="separator:a63d01e4adf4f5e5c3d634e6ee458a02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a2af3d568eb0ffb4a91f204f40f0041e1" id="r_a2af3d568eb0ffb4a91f204f40f0041e1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2af3d568eb0ffb4a91f204f40f0041e1">getAtomCount</a> () const</td></tr>
<tr class="memdesc:a2af3d568eb0ffb4a91f204f40f0041e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of atoms in one or more systems.  <br /></td></tr>
<tr class="separator:a2af3d568eb0ffb4a91f204f40f0041e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed47b38dc7548e0415da22f8a60220f" id="r_a9ed47b38dc7548e0415da22f8a60220f"><td class="memItemLeft" align="right" valign="top"><a id="a9ed47b38dc7548e0415da22f8a60220f" name="a9ed47b38dc7548e0415da22f8a60220f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getAtomCount</b> (int system_index) const</td></tr>
<tr class="separator:a9ed47b38dc7548e0415da22f8a60220f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a09cc22d64c6af0681343d0c6fed45550" id="r_a09cc22d64c6af0681343d0c6fed45550"><td class="memItemLeft" align="right" valign="top">std::vector&lt; AtomicRadiusSet &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09cc22d64c6af0681343d0c6fed45550">getPBRadiiSet</a> () const</td></tr>
<tr class="memdesc:a09cc22d64c6af0681343d0c6fed45550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the PB radii set for one or more systems.  <br /></td></tr>
<tr class="separator:a09cc22d64c6af0681343d0c6fed45550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540eea6395ad756ff8191338d6c637e9" id="r_a540eea6395ad756ff8191338d6c637e9"><td class="memItemLeft" align="right" valign="top"><a id="a540eea6395ad756ff8191338d6c637e9" name="a540eea6395ad756ff8191338d6c637e9"></a>
std::vector&lt; AtomicRadiusSet &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getPBRadiiSet</b> (int low_limit, int high_limit) const</td></tr>
<tr class="separator:a540eea6395ad756ff8191338d6c637e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f308047498eea85cb1e5da3404be8d6" id="r_a6f308047498eea85cb1e5da3404be8d6"><td class="memItemLeft" align="right" valign="top"><a id="a6f308047498eea85cb1e5da3404be8d6" name="a6f308047498eea85cb1e5da3404be8d6"></a>
AtomicRadiusSet&#160;</td><td class="memItemRight" valign="bottom"><b>getPBRadiiSet</b> (int index) const</td></tr>
<tr class="separator:a6f308047498eea85cb1e5da3404be8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a7f4e15d4dd87969d86f67781631bf235" id="r_a7f4e15d4dd87969d86f67781631bf235"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a7f4e15d4dd87969d86f67781631bf235"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7f4e15d4dd87969d86f67781631bf235">getPartialCharges</a> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:a7f4e15d4dd87969d86f67781631bf235"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get partial charges stored within the synthesis.  <br /></td></tr>
<tr class="separator:a7f4e15d4dd87969d86f67781631bf235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21384d2c5cd877f913abddcb1b45603c" id="r_a21384d2c5cd877f913abddcb1b45603c"><td class="memTemplParams" colspan="2"><a id="a21384d2c5cd877f913abddcb1b45603c" name="a21384d2c5cd877f913abddcb1b45603c"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:a21384d2c5cd877f913abddcb1b45603c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getPartialCharges</b> (int system_index, HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="separator:a21384d2c5cd877f913abddcb1b45603c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08182096e0594bb19301a3e327247c96" id="r_a08182096e0594bb19301a3e327247c96"><td class="memTemplParams" colspan="2"><a id="a08182096e0594bb19301a3e327247c96" name="a08182096e0594bb19301a3e327247c96"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:a08182096e0594bb19301a3e327247c96"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getPartialCharges</b> (int system_index, int low_index, int high_index, HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="separator:a08182096e0594bb19301a3e327247c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a7bdfc70cbc2157d19f074502933a99a4" id="r_a7bdfc70cbc2157d19f074502933a99a4"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a7bdfc70cbc2157d19f074502933a99a4"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7bdfc70cbc2157d19f074502933a99a4">getAtomicMasses</a> (HybridTargetLevel tier) const</td></tr>
<tr class="memdesc:a7bdfc70cbc2157d19f074502933a99a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the masses (or inverse masses) of atoms in the synthesis.  <br /></td></tr>
<tr class="separator:a7bdfc70cbc2157d19f074502933a99a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5cd5192da61ed79cbab3ad8e249a0c" id="r_adc5cd5192da61ed79cbab3ad8e249a0c"><td class="memTemplParams" colspan="2"><a id="adc5cd5192da61ed79cbab3ad8e249a0c" name="adc5cd5192da61ed79cbab3ad8e249a0c"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:adc5cd5192da61ed79cbab3ad8e249a0c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getAtomicMasses</b> (HybridTargetLevel tier, int system_index) const</td></tr>
<tr class="separator:adc5cd5192da61ed79cbab3ad8e249a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29376921465f891676714f5032cc26a" id="r_ae29376921465f891676714f5032cc26a"><td class="memTemplParams" colspan="2"><a id="ae29376921465f891676714f5032cc26a" name="ae29376921465f891676714f5032cc26a"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:ae29376921465f891676714f5032cc26a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getAtomicMasses</b> (HybridTargetLevel tier, int system_index, int low_index, int high_index) const</td></tr>
<tr class="separator:ae29376921465f891676714f5032cc26a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a45a3c113fc24a33c7585f7ef13b82bfa" id="r_a45a3c113fc24a33c7585f7ef13b82bfa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45a3c113fc24a33c7585f7ef13b82bfa">setImplicitSolventModel</a> ()</td></tr>
<tr class="memdesc:a45a3c113fc24a33c7585f7ef13b82bfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply an implicit solvent model to the synthesis. Any mode of operation other than taking the original topologies' parameters as is (calling this member function with no arguments) will cause changes ot the underlying topologies.  <br /></td></tr>
<tr class="separator:a45a3c113fc24a33c7585f7ef13b82bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3067192752f732e051bc8b43c92ad42" id="r_aa3067192752f732e051bc8b43c92ad42"><td class="memItemLeft" align="right" valign="top"><a id="aa3067192752f732e051bc8b43c92ad42" name="aa3067192752f732e051bc8b43c92ad42"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setImplicitSolventModel</b> (ImplicitSolventModel igb_in, const <a class="el" href="structstormm_1_1generalized__born__defaults_1_1NeckGeneralizedBornKit.html">NeckGeneralizedBornKit</a>&lt; double &gt; &amp;ngbk, const std::vector&lt; AtomicRadiusSet &gt; &amp;radii_sets_in, double dielectric_in=80.0, double saltcon_in=0.0, ExceptionResponse policy=ExceptionResponse::WARN)</td></tr>
<tr class="separator:aa3067192752f732e051bc8b43c92ad42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63aaceac95e86d1e2794e3aa66fd7823" id="r_a63aaceac95e86d1e2794e3aa66fd7823"><td class="memItemLeft" align="right" valign="top"><a id="a63aaceac95e86d1e2794e3aa66fd7823" name="a63aaceac95e86d1e2794e3aa66fd7823"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setImplicitSolventModel</b> (ImplicitSolventModel igb_in, const <a class="el" href="structstormm_1_1generalized__born__defaults_1_1NeckGeneralizedBornKit.html">NeckGeneralizedBornKit</a>&lt; double &gt; &amp;ngbk, AtomicRadiusSet radii_set=AtomicRadiusSet::NONE, double dielectric_in=80.0, double saltcon_in=0.0, ExceptionResponse policy=ExceptionResponse::WARN)</td></tr>
<tr class="separator:a63aaceac95e86d1e2794e3aa66fd7823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bcf984c994c666ae393e707a6ebf610" id="r_a8bcf984c994c666ae393e707a6ebf610"><td class="memItemLeft" align="right" valign="top"><a id="a8bcf984c994c666ae393e707a6ebf610" name="a8bcf984c994c666ae393e707a6ebf610"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setImplicitSolventModel</b> (ImplicitSolventModel igb_in, const <a class="el" href="classstormm_1_1generalized__born__defaults_1_1NeckGeneralizedBornTable.html">NeckGeneralizedBornTable</a> &amp;ngb_tab, const std::vector&lt; AtomicRadiusSet &gt; &amp;radii_sets_in, double dielectric_in=80.0, double saltcon_in=0.0, ExceptionResponse policy=ExceptionResponse::WARN)</td></tr>
<tr class="separator:a8bcf984c994c666ae393e707a6ebf610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e15ea17a960e66eb2a9daba03c32ef0" id="r_a5e15ea17a960e66eb2a9daba03c32ef0"><td class="memItemLeft" align="right" valign="top"><a id="a5e15ea17a960e66eb2a9daba03c32ef0" name="a5e15ea17a960e66eb2a9daba03c32ef0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setImplicitSolventModel</b> (ImplicitSolventModel igb_in, const <a class="el" href="classstormm_1_1generalized__born__defaults_1_1NeckGeneralizedBornTable.html">NeckGeneralizedBornTable</a> &amp;ngb_tab, AtomicRadiusSet radii_set=AtomicRadiusSet::NONE, double dielectric_in=80.0, double saltcon_in=0.0, ExceptionResponse policy=ExceptionResponse::WARN)</td></tr>
<tr class="separator:a5e15ea17a960e66eb2a9daba03c32ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A collection of one or more <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html" title="A struct to hold information relating to an Amber topology. This struct&#39;s member functions are limite...">AtomGraph</a> objects, with similar components arranged in contiguous arrays (often padded by the GPU warp size to prevent one system from flowing into another). Work units covering all systems are laid out in additional, contiguous arrays. While individual topologies (AtomGraphs) have <a class="el" href="classstormm_1_1topology_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> POINTER-kind objects for details such as charges and atom type indices and all of the POINTER-kind objects targeted a single ARRAY-kind object of the correct memory type, the synthesis, which may have many topologies and a great deal more overall information, stores most of its data in a series of ARRAY-kind objects, one for each member variable. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a489c320f4ee879fc5b6aff5b0f9a9bce" name="a489c320f4ee879fc5b6aff5b0f9a9bce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a489c320f4ee879fc5b6aff5b0f9a9bce">&#9670;&#160;</a></span>AtomGraphSynthesis() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">stormm::synthesis::AtomGraphSynthesis::AtomGraphSynthesis </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>topologies_in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; RestraintApparatus * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>restraints_in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>topology_indices_in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>restraint_indices_in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExceptionResponse</td>          <td class="paramname"><span class="paramname"><em>policy_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">ExceptionResponse::WARN</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GpuDetails &amp;</td>          <td class="paramname"><span class="paramname"><em>gpu</em></span><span class="paramdefsep"> = </span><span class="paramdefval">null_gpu</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StopWatch *</td>          <td class="paramname"><span class="paramname"><em>timer_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The constructor takes a series of topologies and NMR restraints. The NMR restraints point to specific topologies and thereby apply to any coordinate sets that also point to those topologies. </p>
<p>Overloaded:</p><ul>
<li>Prepare the energy surface with or without restraints</li>
<li>Accept lists of unique topologies and restraints with auxiliary lists of indices for replicating them, or accept explicit lists of topologies and restraints with one index for each system.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topologies_in</td><td>List of input topology pointers </td></tr>
    <tr><td class="paramname">restraints_in</td><td>List of input restraint collections </td></tr>
    <tr><td class="paramname">topology_indices_in</td><td>Indicators of which topologies describe each system in this synthesis. This allows a synthesis to describe many copies of each system in its work units while storing relatively small amounts of data. </td></tr>
    <tr><td class="paramname">restraint_indices_in</td><td>Indicators of which collections of restraints supplement the energy surfaces of each system within this synthesis. Different sets of restraints allow many systems referencing the same topology to evolve on different energy surfaces. </td></tr>
    <tr><td class="paramname">policy</td><td>Instruction on what to do if questionable input is encountered </td></tr>
    <tr><td class="paramname">vwu_atom_limit</td><td>Maximum number of atoms to include in each valence work unit, taken from user input or a pre-computed value based on known launch bounds of the kernel that will evaluate the work units </td></tr>
    <tr><td class="paramname">timer_in</td><td>Timer to track the wall time of this setup </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a02aa078a924bfbdefcce4dd0dd917c02" name="a02aa078a924bfbdefcce4dd0dd917c02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02aa078a924bfbdefcce4dd0dd917c02">&#9670;&#160;</a></span>AtomGraphSynthesis() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">stormm::synthesis::AtomGraphSynthesis::AtomGraphSynthesis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstormm_1_1synthesis_1_1AtomGraphSynthesis.html">AtomGraphSynthesis</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>original</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The presence of POINTER-kind <a class="el" href="classstormm_1_1topology_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> objects necessitates manually written copy and move constructors as well as copy and move assignment operators, but all are valid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">original</td><td>The original object to copy or move </td></tr>
    <tr><td class="paramname">other</td><td>Another object placed on the right hand side of the assignment statement </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2af3d568eb0ffb4a91f204f40f0041e1" name="a2af3d568eb0ffb4a91f204f40f0041e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2af3d568eb0ffb4a91f204f40f0041e1">&#9670;&#160;</a></span>getAtomCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stormm::synthesis::AtomGraphSynthesis::getAtomCount </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of atoms in one or more systems. </p>
<p>Overloaded:</p><ul>
<li>Get the total number of atoms, summed over all systems, including replicas. This does not include padding.</li>
<li>Get the total number of atoms in a specific sytem, without padding.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">system_index</td><td>index of the system of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7bdfc70cbc2157d19f074502933a99a4" name="a7bdfc70cbc2157d19f074502933a99a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bdfc70cbc2157d19f074502933a99a4">&#9670;&#160;</a></span>getAtomicMasses()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; stormm::synthesis::AtomGraphSynthesis::getAtomicMasses </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the masses (or inverse masses) of atoms in the synthesis. </p>
<p>Overloaded:</p><ul>
<li>Get masses for all systems, padded by the warp size between systems</li>
<li>Get masses for a single system</li>
<li>Get masses for a specific range of atoms in a single system</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tier</td><td>Obtain the data from arrays on the host or the device </td></tr>
    <tr><td class="paramname">system_index</td><td>Index of the specific system to query </td></tr>
    <tr><td class="paramname">low_index</td><td>Lower limit of atoms in the system to query (will be validated) </td></tr>
    <tr><td class="paramname">high_index</td><td>Upper limit of atoms in the system to query (will be validated) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d392d284f3f623944da8338973ba4fa" name="a4d392d284f3f623944da8338973ba4fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d392d284f3f623944da8338973ba4fa">&#9670;&#160;</a></span>getAtomOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stormm::synthesis::AtomGraphSynthesis::getAtomOffset </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>system_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the starting point for atoms of a specific system in the lineup of all topologies. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">system_index</td><td>index of the system of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6d69caedec16b88165738a75ba1ee56e" name="a6d69caedec16b88165738a75ba1ee56e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d69caedec16b88165738a75ba1ee56e">&#9670;&#160;</a></span>getDoublePrecisionAtomUpdateKit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SyAtomUpdateKit&lt; double, <a class="el" href="structstormm_1_1data__types_1_1double2.html">double2</a>, <a class="el" href="structstormm_1_1data__types_1_1double4.html">double4</a> &gt; stormm::synthesis::AtomGraphSynthesis::getDoublePrecisionAtomUpdateKit </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a minimal kit with double-precision real numbers for updating atom and virtual site positions based on work units stored in this object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tier</td><td>Level at which to obtain pointers for the abstract </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28a7201cb38537842ef60b7f25684799" name="a28a7201cb38537842ef60b7f25684799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28a7201cb38537842ef60b7f25684799">&#9670;&#160;</a></span>getDoublePrecisionNonbondedKit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SyNonbondedKit&lt; double, <a class="el" href="structstormm_1_1data__types_1_1double2.html">double2</a> &gt; stormm::synthesis::AtomGraphSynthesis::getDoublePrecisionNonbondedKit </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a minimal kit with double-precision real numbers for computing non-bonded interactions for all systems based on work units stored in this object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tier</td><td>Level at which to obtain pointers for the abstract </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a118050bd464ad1a1d0de5daf5e385633" name="a118050bd464ad1a1d0de5daf5e385633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a118050bd464ad1a1d0de5daf5e385633">&#9670;&#160;</a></span>getDoublePrecisionRestraintKit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SyRestraintKit&lt; double, <a class="el" href="structstormm_1_1data__types_1_1double2.html">double2</a>, <a class="el" href="structstormm_1_1data__types_1_1double4.html">double4</a> &gt; stormm::synthesis::AtomGraphSynthesis::getDoublePrecisionRestraintKit </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a minimal kit with double-precision parameter detail for computing valence interactions for all systems based on the work units stored in this object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tier</td><td>Level at which to obtain pointers for the abstract </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3a7d03cb157bafa5e7292a78b2481e6" name="ac3a7d03cb157bafa5e7292a78b2481e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3a7d03cb157bafa5e7292a78b2481e6">&#9670;&#160;</a></span>getDoublePrecisionValenceKit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SyValenceKit&lt; double &gt; stormm::synthesis::AtomGraphSynthesis::getDoublePrecisionValenceKit </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a minimal kit with double-precision parameter detail for computing valence interactions for all systems based on the work units stored in this object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tier</td><td>Level at which to obtain pointers for the abstract </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f4e15d4dd87969d86f67781631bf235" name="a7f4e15d4dd87969d86f67781631bf235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f4e15d4dd87969d86f67781631bf235">&#9670;&#160;</a></span>getPartialCharges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; stormm::synthesis::AtomGraphSynthesis::getPartialCharges </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get partial charges stored within the synthesis. </p>
<p>Overloaded:</p><ul>
<li>Get partial charges for all systems, padded by the warp size between systems</li>
<li>Get partial charges for a single system</li>
<li>Get partial charges for a specific range of atoms in a single system</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tier</td><td>Obtain the data from arrays on the host or the device </td></tr>
    <tr><td class="paramname">system_index</td><td>Index of the specific system to query </td></tr>
    <tr><td class="paramname">low_index</td><td>Lower limit of atoms in the system to query (will be validated) </td></tr>
    <tr><td class="paramname">high_index</td><td>Upper limit of atoms in the system to query (will be validated) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09cc22d64c6af0681343d0c6fed45550" name="a09cc22d64c6af0681343d0c6fed45550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09cc22d64c6af0681343d0c6fed45550">&#9670;&#160;</a></span>getPBRadiiSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; AtomicRadiusSet &gt; stormm::synthesis::AtomGraphSynthesis::getPBRadiiSet </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of the PB radii set for one or more systems. </p>
<p>Overloaded:</p><ul>
<li>Get the PB radii set for all systems</li>
<li>Get the PB radii set for a series of systems between low and high limits</li>
<li>Get the PB radii set for a specific system </li>
</ul>

</div>
</div>
<a id="a9da6c022fbb95678dcfd8d4d5a68766e" name="a9da6c022fbb95678dcfd8d4d5a68766e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9da6c022fbb95678dcfd8d4d5a68766e">&#9670;&#160;</a></span>getSinglePrecisionAtomUpdateKit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SyAtomUpdateKit&lt; float, <a class="el" href="structstormm_1_1data__types_1_1float2.html">float2</a>, <a class="el" href="structstormm_1_1data__types_1_1float4.html">float4</a> &gt; stormm::synthesis::AtomGraphSynthesis::getSinglePrecisionAtomUpdateKit </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a minimal kit with single-precision real numbers for updating atom and virtual site positions based on work units stored in this object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tier</td><td>Level at which to obtain pointers for the abstract </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b6f4b16ae53cdd5ba1153fe24a35dc6" name="a8b6f4b16ae53cdd5ba1153fe24a35dc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b6f4b16ae53cdd5ba1153fe24a35dc6">&#9670;&#160;</a></span>getSinglePrecisionNonbondedKit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SyNonbondedKit&lt; float, <a class="el" href="structstormm_1_1data__types_1_1float2.html">float2</a> &gt; stormm::synthesis::AtomGraphSynthesis::getSinglePrecisionNonbondedKit </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a minimal kit with single-precision real numbers for computing non-bonded interactions for all systems based on work units stored in this object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tier</td><td>Level at which to obtain pointers for the abstract </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac416b7fde97df6d28f123bc6b7696eec" name="ac416b7fde97df6d28f123bc6b7696eec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac416b7fde97df6d28f123bc6b7696eec">&#9670;&#160;</a></span>getSinglePrecisionRestraintKit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SyRestraintKit&lt; float, <a class="el" href="structstormm_1_1data__types_1_1float2.html">float2</a>, <a class="el" href="structstormm_1_1data__types_1_1float4.html">float4</a> &gt; stormm::synthesis::AtomGraphSynthesis::getSinglePrecisionRestraintKit </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a minimal kit with single-precision parameter detail for computing valence interactions for all systems based on the work units stored in this object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tier</td><td>Level at which to obtain pointers for the abstract </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58f99e256440f87f8d25be1c76937446" name="a58f99e256440f87f8d25be1c76937446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58f99e256440f87f8d25be1c76937446">&#9670;&#160;</a></span>getSinglePrecisionValenceKit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SyValenceKit&lt; float &gt; stormm::synthesis::AtomGraphSynthesis::getSinglePrecisionValenceKit </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a minimal kit with single-precision parameter detail for computing valence interactions for all systems based on the work units stored in this object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tier</td><td>Level at which to obtain pointers for the abstract </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa47ba93c544998ca27df5963db48da5c" name="aa47ba93c544998ca27df5963db48da5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa47ba93c544998ca27df5963db48da5c">&#9670;&#160;</a></span>getSystemRestraintPointer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RestraintApparatus * stormm::synthesis::AtomGraphSynthesis::getSystemRestraintPointer </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>system_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a restraint apparatus pointer for a sepcific system contained within the synthesis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">system_index</td><td>Index of the system of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9da34c22530dbbfdaebe6be32e146fa" name="ac9da34c22530dbbfdaebe6be32e146fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9da34c22530dbbfdaebe6be32e146fa">&#9670;&#160;</a></span>getSystemTopologyPointer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> * stormm::synthesis::AtomGraphSynthesis::getSystemTopologyPointer </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>system_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a topology pointer for a specific system contained within the synthesis. </p>
<p>Overloaded:</p><ul>
<li>Get the topology pointer for a specific system</li>
<li>Get topology pointers for all systems</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">system_index</td><td>Index of the system of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="accc5f4e8678a70f4ca0ff4aa820c2402" name="accc5f4e8678a70f4ca0ff4aa820c2402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accc5f4e8678a70f4ca0ff4aa820c2402">&#9670;&#160;</a></span>loadNonbondedWorkUnits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::synthesis::AtomGraphSynthesis::loadNonbondedWorkUnits </td>
          <td>(</td>
          <td class="paramtype">const StaticExclusionMaskSynthesis &amp;</td>          <td class="paramname"><span class="paramname"><em>poly_se</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InitializationTask</td>          <td class="paramname"><span class="paramname"><em>init_request</em></span><span class="paramdefsep"> = </span><span class="paramdefval">InitializationTask::NONE</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>random_cache_depth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GpuDetails &amp;</td>          <td class="paramname"><span class="paramname"><em>gpu</em></span><span class="paramdefsep"> = </span><span class="paramdefval">null_gpu</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct non-bonded work units for all unique topologies (there are no restraints for non-bonded interactions that might distinguish systems with the same topology, as was a consideration when developing the valence work units). Load the instructions into the topology synthesis for availability on the GPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly_se</td><td>Synthesis of static exclusion masks for a compilation of systems in isolated boundary conditions. </td></tr>
    <tr><td class="paramname">init_request</td><td>Indicate a pattern for the non-bonded work units to initialize accumulators for subsequent force and energy calculations. </td></tr>
    <tr><td class="paramname">random_cache_depth</td><td>Number of random values to store for each atom in the synthesis (the actual number of values stored is multiplied by three, for Cartesian X, Y, and Z contributions) </td></tr>
    <tr><td class="paramname">gpu</td><td>Details of the GPU in use (this may change the profile of the workload) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45a3c113fc24a33c7585f7ef13b82bfa" name="a45a3c113fc24a33c7585f7ef13b82bfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45a3c113fc24a33c7585f7ef13b82bfa">&#9670;&#160;</a></span>setImplicitSolventModel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::synthesis::AtomGraphSynthesis::setImplicitSolventModel </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply an implicit solvent model to the synthesis. Any mode of operation other than taking the original topologies' parameters as is (calling this member function with no arguments) will cause changes ot the underlying topologies. </p>
<p>Overloaded:</p><ul>
<li>Take the implicit solvent models as described in the original topologies</li>
<li>Apply specific atomic radius sets to each system</li>
<li>Apply a common atomic radius set ot all systems</li>
<li>Accept a GB neck model, its double-precision abstract, or no such model</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">igb_in</td><td>A specific, established implicit solvent model (from literature and hard-coded into STORMM) to apply </td></tr>
    <tr><td class="paramname">dielectric_in</td><td>The desired dielectric constant </td></tr>
    <tr><td class="paramname">saltcon_in</td><td>The intended salt concentration (affects the GB decay parameter Kappa) </td></tr>
    <tr><td class="paramname">radii_sets_in</td><td>Radii to impart to the topology (this is often coupled to the choice of implicit solvent model, but for purposes of experimentation or new model development might be flexible) </td></tr>
    <tr><td class="paramname">policy</td><td>Indicator of what to do if the topology's PB radii to not meet the implicit solvent model requirements, or there is some other problem </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/Synthesis/<a class="el" href="atomgraph__synthesis_8h_source.html">atomgraph_synthesis.h</a></li>
<li>src/Synthesis/<b>ag_synthesis_constructors.cpp</b></li>
<li>src/Synthesis/<b>ag_synthesis_mechanics.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2
</small></address>
</div><!-- doc-content -->
</body>
</html>
