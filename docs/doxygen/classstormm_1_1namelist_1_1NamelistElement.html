<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>STORMM Source Documentation: stormm::namelist::NamelistElement Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">STORMM Source Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>stormm</b></li><li class="navelem"><b>namelist</b></li><li class="navelem"><a class="el" href="classstormm_1_1namelist_1_1NamelistElement.html">NamelistElement</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classstormm_1_1namelist_1_1NamelistElement-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">stormm::namelist::NamelistElement Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>One keyword found in a namelist, ready to store the namelist variable moniker, the type, and the value read from the input file.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="namelist__element_8h_source.html">namelist_element.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3f2c3b59341ef6b7c5ce5b6bf46ad58a" id="r_a3f2c3b59341ef6b7c5ce5b6bf46ad58a"><td class="memItemLeft" align="right" valign="top"><a id="a3f2c3b59341ef6b7c5ce5b6bf46ad58a" name="a3f2c3b59341ef6b7c5ce5b6bf46ad58a"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getLabel</b> () const</td></tr>
<tr class="memdesc:a3f2c3b59341ef6b7c5ce5b6bf46ad58a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the keyword for a namelist element, i.e. nstlim in Amber &amp;ctrl. <br /></td></tr>
<tr class="separator:a3f2c3b59341ef6b7c5ce5b6bf46ad58a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a972b65ff1b5321dfa43c615594dc3af3" id="r_a972b65ff1b5321dfa43c615594dc3af3"><td class="memItemLeft" align="right" valign="top"><a id="a972b65ff1b5321dfa43c615594dc3af3" name="a972b65ff1b5321dfa43c615594dc3af3"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getSubLabel</b> (size_t index) const</td></tr>
<tr class="memdesc:a972b65ff1b5321dfa43c615594dc3af3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a sub-key for this element. <br /></td></tr>
<tr class="separator:a972b65ff1b5321dfa43c615594dc3af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c274f25d66a89482d20318d812f514" id="r_a15c274f25d66a89482d20318d812f514"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15c274f25d66a89482d20318d812f514">setPolicy</a> (ExceptionResponse policy_in)</td></tr>
<tr class="memdesc:a15c274f25d66a89482d20318d812f514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the way that this Namelist element will respond if it encounters bad input. The member variable associated with this function is not passed down as part of the constructor argument list, and would be tedious for the developer to enter over and over, so it is passed down based on the <a class="el" href="classstormm_1_1namelist_1_1NamelistEmulator.html" title="Collection of variables to transcribe information contained within a namelist.">NamelistEmulator</a>'s own setting by calling this function.  <br /></td></tr>
<tr class="separator:a15c274f25d66a89482d20318d812f514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48041a4e56a02c009c2994928b2fddc9" id="r_a48041a4e56a02c009c2994928b2fddc9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48041a4e56a02c009c2994928b2fddc9">reportNamelistTypeProblem</a> (const std::string &amp;caller, const std::string &amp;data_type) const</td></tr>
<tr class="memdesc:a48041a4e56a02c009c2994928b2fddc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report an error based on an incorrect namelist element data type request. This is an assertion that debugs a program when a developer makes a mistake, not something that an end user should encounter, but it's helpful to have a more detailed description than assert() can provide. This always ends by throwing a runtime error and so is an acceptable way to fill a switch case.  <br /></td></tr>
<tr class="separator:a48041a4e56a02c009c2994928b2fddc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a9763e80fea6bb29f656379742d567" id="r_af3a9763e80fea6bb29f656379742d567"><td class="memItemLeft" align="right" valign="top"><a id="af3a9763e80fea6bb29f656379742d567" name="af3a9763e80fea6bb29f656379742d567"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getEntryCount</b> () const</td></tr>
<tr class="memdesc:af3a9763e80fea6bb29f656379742d567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the depth of the namelist element, the number of values that it stores. <br /></td></tr>
<tr class="separator:af3a9763e80fea6bb29f656379742d567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a361afa7ce982b8742bd11527e0a909f3" id="r_a361afa7ce982b8742bd11527e0a909f3"><td class="memItemLeft" align="right" valign="top">InputStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a361afa7ce982b8742bd11527e0a909f3">getEstablishment</a> (const std::string &amp;member_key=std::string(&quot;&quot;), int repeat_no=0) const</td></tr>
<tr class="memdesc:a361afa7ce982b8742bd11527e0a909f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report whether a value has been assigned, read from input, to this namelist element.  <br /></td></tr>
<tr class="separator:a361afa7ce982b8742bd11527e0a909f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187ea5a19f30a13bdc68d2bde72fa555" id="r_a187ea5a19f30a13bdc68d2bde72fa555"><td class="memItemLeft" align="right" valign="top"><a id="a187ea5a19f30a13bdc68d2bde72fa555" name="a187ea5a19f30a13bdc68d2bde72fa555"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>getRepeatableValueState</b> () const</td></tr>
<tr class="memdesc:a187ea5a19f30a13bdc68d2bde72fa555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report whether an element accepts multiple values. <br /></td></tr>
<tr class="separator:a187ea5a19f30a13bdc68d2bde72fa555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b9d10a11f88ee72f79ec76458a56db" id="r_a90b9d10a11f88ee72f79ec76458a56db"><td class="memItemLeft" align="right" valign="top"><a id="a90b9d10a11f88ee72f79ec76458a56db" name="a90b9d10a11f88ee72f79ec76458a56db"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getTemplateSize</b> () const</td></tr>
<tr class="memdesc:a90b9d10a11f88ee72f79ec76458a56db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the size of this namelist element's template (if it is a STRUCT) <br /></td></tr>
<tr class="separator:a90b9d10a11f88ee72f79ec76458a56db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4faac15910b08233e38dfc676ac47230" id="r_a4faac15910b08233e38dfc676ac47230"><td class="memItemLeft" align="right" valign="top"><a id="a4faac15910b08233e38dfc676ac47230" name="a4faac15910b08233e38dfc676ac47230"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>badInputResponse</b> (const std::string &amp;errmsg, const char *caller)</td></tr>
<tr class="memdesc:a4faac15910b08233e38dfc676ac47230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Respond to bad user input at the <a class="el" href="classstormm_1_1namelist_1_1NamelistElement.html" title="One keyword found in a namelist, ready to store the namelist variable moniker, the type,...">NamelistElement</a> level, based on a policy handed down from a <a class="el" href="classstormm_1_1namelist_1_1NamelistEmulator.html" title="Collection of variables to transcribe information contained within a namelist.">NamelistEmulator</a>. This does not apply to developer-level mistakes, which always throw runtime errors. <br /></td></tr>
<tr class="separator:a4faac15910b08233e38dfc676ac47230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110dd7d5cba5e1bbb17757d53627428d" id="r_a110dd7d5cba5e1bbb17757d53627428d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a110dd7d5cba5e1bbb17757d53627428d">addDefaultValue</a> (const std::string &amp;next_default)</td></tr>
<tr class="memdesc:a110dd7d5cba5e1bbb17757d53627428d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Include an additional value as a default setting for a particular keyword. This enables a single keyword to have a default series of values. The supplied value will be interpreted according to the type of the element.  <br /></td></tr>
<tr class="separator:a110dd7d5cba5e1bbb17757d53627428d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a330ed83d4ddcaa56856352914218a244" id="r_a330ed83d4ddcaa56856352914218a244"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a330ed83d4ddcaa56856352914218a244">NamelistElement</a> (const std::string &amp;keyword_in, NamelistType kind_in, const std::string &amp;default_in=std::string(&quot;&quot;), DefaultIsObligatory obligate=DefaultIsObligatory::NO, InputRepeats rep_in=InputRepeats::NO, const std::string &amp;help_in=std::string(&quot;No description provided&quot;))</td></tr>
<tr class="memdesc:a330ed83d4ddcaa56856352914218a244"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for a non-STRUCT <a class="el" href="classstormm_1_1namelist_1_1NamelistElement.html" title="One keyword found in a namelist, ready to store the namelist variable moniker, the type,...">NamelistElement</a>.  <br /></td></tr>
<tr class="separator:a330ed83d4ddcaa56856352914218a244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f9d231b11c931537876c2d0c5a45fa" id="r_a70f9d231b11c931537876c2d0c5a45fa"><td class="memItemLeft" align="right" valign="top"><a id="a70f9d231b11c931537876c2d0c5a45fa" name="a70f9d231b11c931537876c2d0c5a45fa"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NamelistElement</b> (const std::string keyword_in, const std::vector&lt; std::string &gt; &amp;sub_keys_in, const std::vector&lt; NamelistType &gt; &amp;sub_kinds_in, const std::vector&lt; std::string &gt; &amp;default_list, DefaultIsObligatory obligate_list=DefaultIsObligatory::NO, InputRepeats rep_in=InputRepeats::NO, const std::string &amp;help_in=std::string(&quot;No description provided&quot;), const std::vector&lt; std::string &gt; &amp;sub_help_in=std::vector&lt; std::string &gt;(1, &quot;No description provided&quot;), const std::vector&lt; KeyRequirement &gt; &amp;template_requirements_in={})</td></tr>
<tr class="separator:a70f9d231b11c931537876c2d0c5a45fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa339479aeaffe44677ddd9ad72f6b047" id="r_aa339479aeaffe44677ddd9ad72f6b047"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa339479aeaffe44677ddd9ad72f6b047">NamelistElement</a> (const <a class="el" href="classstormm_1_1namelist_1_1NamelistElement.html">NamelistElement</a> &amp;original)=default</td></tr>
<tr class="memdesc:aa339479aeaffe44677ddd9ad72f6b047"><td class="mdescLeft">&#160;</td><td class="mdescRight">With no const members and only Standard Template Library components, the default copy and move constructors, as well as the copy and move assignment operators, are valid.  <br /></td></tr>
<tr class="separator:aa339479aeaffe44677ddd9ad72f6b047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34745ed6fa70b6fbc6dd192fd2b5d2d5" id="r_a34745ed6fa70b6fbc6dd192fd2b5d2d5"><td class="memItemLeft" align="right" valign="top"><a id="a34745ed6fa70b6fbc6dd192fd2b5d2d5" name="a34745ed6fa70b6fbc6dd192fd2b5d2d5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NamelistElement</b> (<a class="el" href="classstormm_1_1namelist_1_1NamelistElement.html">NamelistElement</a> &amp;&amp;original)=default</td></tr>
<tr class="separator:a34745ed6fa70b6fbc6dd192fd2b5d2d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5586069d0a5d8b601a867c9634e3208e" id="r_a5586069d0a5d8b601a867c9634e3208e"><td class="memItemLeft" align="right" valign="top"><a id="a5586069d0a5d8b601a867c9634e3208e" name="a5586069d0a5d8b601a867c9634e3208e"></a>
<a class="el" href="classstormm_1_1namelist_1_1NamelistElement.html">NamelistElement</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classstormm_1_1namelist_1_1NamelistElement.html">NamelistElement</a> &amp;original)=default</td></tr>
<tr class="separator:a5586069d0a5d8b601a867c9634e3208e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1652c98eac9815e046c934d8fdfe149" id="r_ab1652c98eac9815e046c934d8fdfe149"><td class="memItemLeft" align="right" valign="top"><a id="ab1652c98eac9815e046c934d8fdfe149" name="ab1652c98eac9815e046c934d8fdfe149"></a>
<a class="el" href="classstormm_1_1namelist_1_1NamelistElement.html">NamelistElement</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classstormm_1_1namelist_1_1NamelistElement.html">NamelistElement</a> &amp;&amp;original)=default</td></tr>
<tr class="separator:ab1652c98eac9815e046c934d8fdfe149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a96e9f86da0e688a5d96093deb710fb8b" id="r_a96e9f86da0e688a5d96093deb710fb8b"><td class="memItemLeft" align="right" valign="top">NamelistType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96e9f86da0e688a5d96093deb710fb8b">getKind</a> () const</td></tr>
<tr class="memdesc:a96e9f86da0e688a5d96093deb710fb8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the kind associated with a namelist element, i.e. nstlim is an INTEGER in Amber &amp;ctrl.  <br /></td></tr>
<tr class="separator:a96e9f86da0e688a5d96093deb710fb8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d9e79d054e2dfd3eeac217be406cd1" id="r_af4d9e79d054e2dfd3eeac217be406cd1"><td class="memItemLeft" align="right" valign="top"><a id="af4d9e79d054e2dfd3eeac217be406cd1" name="af4d9e79d054e2dfd3eeac217be406cd1"></a>
NamelistType&#160;</td><td class="memItemRight" valign="bottom"><b>getKind</b> (const std::string &amp;sub_key_query) const</td></tr>
<tr class="separator:af4d9e79d054e2dfd3eeac217be406cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a21efbcdfee8dcdbccd2ebfcd26597273" id="r_a21efbcdfee8dcdbccd2ebfcd26597273"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21efbcdfee8dcdbccd2ebfcd26597273">getBoolValue</a> (const std::string &amp;member_key, int index) const</td></tr>
<tr class="memdesc:a21efbcdfee8dcdbccd2ebfcd26597273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the boolean value to which a namelist element has been set (this value is set to TRUE if the keyword was found in the namelist or collection of STRUCT sub-keys, FALSE if not).  <br /></td></tr>
<tr class="separator:a21efbcdfee8dcdbccd2ebfcd26597273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0737d0894b4925e212eed2afbaca36c9" id="r_a0737d0894b4925e212eed2afbaca36c9"><td class="memItemLeft" align="right" valign="top"><a id="a0737d0894b4925e212eed2afbaca36c9" name="a0737d0894b4925e212eed2afbaca36c9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>getBoolValue</b> () const</td></tr>
<tr class="separator:a0737d0894b4925e212eed2afbaca36c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4f57b3e2c520f38de0350746a370fe" id="r_abe4f57b3e2c520f38de0350746a370fe"><td class="memItemLeft" align="right" valign="top"><a id="abe4f57b3e2c520f38de0350746a370fe" name="abe4f57b3e2c520f38de0350746a370fe"></a>
std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getBoolValue</b> (const std::string &amp;member_key) const</td></tr>
<tr class="separator:abe4f57b3e2c520f38de0350746a370fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a8e79fde975856507b78e75e090312c7c" id="r_a8e79fde975856507b78e75e090312c7c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e79fde975856507b78e75e090312c7c">getIntValue</a> (const std::string &amp;member_key, int index) const</td></tr>
<tr class="memdesc:a8e79fde975856507b78e75e090312c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the integer value to which a namelist element has been set (this value is read from the namelist input file, i.e. mdin). Descriptions of input parameters follow from <a class="el" href="#a21efbcdfee8dcdbccd2ebfcd26597273" title="Get the boolean value to which a namelist element has been set (this value is set to TRUE if the keyw...">getBoolValue()</a>, above.  <br /></td></tr>
<tr class="separator:a8e79fde975856507b78e75e090312c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae33664c4995255682885face438b8c" id="r_a0ae33664c4995255682885face438b8c"><td class="memItemLeft" align="right" valign="top"><a id="a0ae33664c4995255682885face438b8c" name="a0ae33664c4995255682885face438b8c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getIntValue</b> (int index) const</td></tr>
<tr class="separator:a0ae33664c4995255682885face438b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a024e2c66a55d3a6c2b6344954b5079db" id="r_a024e2c66a55d3a6c2b6344954b5079db"><td class="memItemLeft" align="right" valign="top"><a id="a024e2c66a55d3a6c2b6344954b5079db" name="a024e2c66a55d3a6c2b6344954b5079db"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getIntValue</b> (const std::string &amp;member_key=std::string(&quot;&quot;)) const</td></tr>
<tr class="separator:a024e2c66a55d3a6c2b6344954b5079db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:afc4a966a795a6cf859890e25b8bded9c" id="r_afc4a966a795a6cf859890e25b8bded9c"><td class="memItemLeft" align="right" valign="top"><a id="afc4a966a795a6cf859890e25b8bded9c" name="afc4a966a795a6cf859890e25b8bded9c"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getRealValue</b> (const std::string &amp;member_key, int index) const</td></tr>
<tr class="memdesc:afc4a966a795a6cf859890e25b8bded9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the real value to which a namelist element has been set (this value is read from the namelist input file, i.e. mdin). Overloading and descriptions of input parameters follow from getIntegerValue() <br /></td></tr>
<tr class="separator:afc4a966a795a6cf859890e25b8bded9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb231818b60c90f49624806f5ad9d70" id="r_aacb231818b60c90f49624806f5ad9d70"><td class="memItemLeft" align="right" valign="top"><a id="aacb231818b60c90f49624806f5ad9d70" name="aacb231818b60c90f49624806f5ad9d70"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getRealValue</b> (int index) const</td></tr>
<tr class="separator:aacb231818b60c90f49624806f5ad9d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b3d4cc6be5f17e05855bc7c7669315" id="r_a65b3d4cc6be5f17e05855bc7c7669315"><td class="memItemLeft" align="right" valign="top"><a id="a65b3d4cc6be5f17e05855bc7c7669315" name="a65b3d4cc6be5f17e05855bc7c7669315"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getRealValue</b> (const std::string &amp;member_key=std::string(&quot;&quot;)) const</td></tr>
<tr class="separator:a65b3d4cc6be5f17e05855bc7c7669315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5f92b5cce6c1c3ad69ae55411efdc410" id="r_a5f92b5cce6c1c3ad69ae55411efdc410"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f92b5cce6c1c3ad69ae55411efdc410">getStringValue</a> (const std::string &amp;member_key, int index) const</td></tr>
<tr class="memdesc:a5f92b5cce6c1c3ad69ae55411efdc410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the string value to which a namelist element has been set (this value is read from the namelist input file, i.e. mdin)  <br /></td></tr>
<tr class="separator:a5f92b5cce6c1c3ad69ae55411efdc410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0494b297073a94e3f4aedbd26cef36f9" id="r_a0494b297073a94e3f4aedbd26cef36f9"><td class="memItemLeft" align="right" valign="top"><a id="a0494b297073a94e3f4aedbd26cef36f9" name="a0494b297073a94e3f4aedbd26cef36f9"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getStringValue</b> (int index) const</td></tr>
<tr class="separator:a0494b297073a94e3f4aedbd26cef36f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a5ce0784cd1cabb51e9d3be564790a" id="r_a52a5ce0784cd1cabb51e9d3be564790a"><td class="memItemLeft" align="right" valign="top"><a id="a52a5ce0784cd1cabb51e9d3be564790a" name="a52a5ce0784cd1cabb51e9d3be564790a"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getStringValue</b> (const std::string &amp;member_key=std::string(&quot;&quot;)) const</td></tr>
<tr class="separator:a52a5ce0784cd1cabb51e9d3be564790a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a750bcdf4412ccd121158d42af57e71a4" id="r_a750bcdf4412ccd121158d42af57e71a4"><td class="memItemLeft" align="right" valign="top">KeyRequirement&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a750bcdf4412ccd121158d42af57e71a4">getImperative</a> () const</td></tr>
<tr class="memdesc:a750bcdf4412ccd121158d42af57e71a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report whether a keyword has been deemed essential, optional, or bogus in a particular context. This enables the same namelist to take on different profiles in different applications, and to report only that data which is relevant in the program output.  <br /></td></tr>
<tr class="separator:a750bcdf4412ccd121158d42af57e71a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad773a4f4f3170b2bbae1742c9cf64aaf" id="r_ad773a4f4f3170b2bbae1742c9cf64aaf"><td class="memItemLeft" align="right" valign="top"><a id="ad773a4f4f3170b2bbae1742c9cf64aaf" name="ad773a4f4f3170b2bbae1742c9cf64aaf"></a>
KeyRequirement&#160;</td><td class="memItemRight" valign="bottom"><b>getImperative</b> (const std::string &amp;sub_key_query) const</td></tr>
<tr class="separator:ad773a4f4f3170b2bbae1742c9cf64aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a59f23e05566771e7b48696fcfedcc07d" id="r_a59f23e05566771e7b48696fcfedcc07d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59f23e05566771e7b48696fcfedcc07d">setDefaultValue</a> (const std::string &amp;modified_default, int default_idx=0)</td></tr>
<tr class="memdesc:a59f23e05566771e7b48696fcfedcc07d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the default value for a particular keyword, overriding anything that might have been set beforehand. This can be useful when applying common keyword loading functions, to adapt the namelist elements for a specific program or context.  <br /></td></tr>
<tr class="separator:a59f23e05566771e7b48696fcfedcc07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87752b7503d6bbb74061d4460818343f" id="r_a87752b7503d6bbb74061d4460818343f"><td class="memItemLeft" align="right" valign="top"><a id="a87752b7503d6bbb74061d4460818343f" name="a87752b7503d6bbb74061d4460818343f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setDefaultValue</b> (const std::vector&lt; std::string &gt; &amp;modified_defaults, const std::vector&lt; std::string &gt; &amp;sub_key_specs)</td></tr>
<tr class="separator:a87752b7503d6bbb74061d4460818343f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a36a4f04f87edd939ce1b099ec16db126" id="r_a36a4f04f87edd939ce1b099ec16db126"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36a4f04f87edd939ce1b099ec16db126">activateBool</a> ()</td></tr>
<tr class="memdesc:a36a4f04f87edd939ce1b099ec16db126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate a boolean value based on the mere presence of a keyword in the namelist. This function will check to verify that the keyword is a boolean.  <br /></td></tr>
<tr class="separator:a36a4f04f87edd939ce1b099ec16db126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b3db3315c4141c32236226fbe2f3fe4" id="r_a0b3db3315c4141c32236226fbe2f3fe4"><td class="memItemLeft" align="right" valign="top"><a id="a0b3db3315c4141c32236226fbe2f3fe4" name="a0b3db3315c4141c32236226fbe2f3fe4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>activateBool</b> (const std::string &amp;su_key_query)</td></tr>
<tr class="separator:a0b3db3315c4141c32236226fbe2f3fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa3f2311dd4f3a8e291bcc206af87213f" id="r_aa3f2311dd4f3a8e291bcc206af87213f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3f2311dd4f3a8e291bcc206af87213f">setIntValue</a> (int value)</td></tr>
<tr class="memdesc:aa3f2311dd4f3a8e291bcc206af87213f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an integer value within this namelist element. This function will check to ensure that the element expects an int.  <br /></td></tr>
<tr class="separator:aa3f2311dd4f3a8e291bcc206af87213f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a119ffdf13392b8479b594c09b506147a" id="r_a119ffdf13392b8479b594c09b506147a"><td class="memItemLeft" align="right" valign="top"><a id="a119ffdf13392b8479b594c09b506147a" name="a119ffdf13392b8479b594c09b506147a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setIntValue</b> (const std::string &amp;member_key, int value)</td></tr>
<tr class="separator:a119ffdf13392b8479b594c09b506147a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0ca02db69a0bfba7520453b94549f4b6" id="r_a0ca02db69a0bfba7520453b94549f4b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ca02db69a0bfba7520453b94549f4b6">setRealValue</a> (double value)</td></tr>
<tr class="memdesc:a0ca02db69a0bfba7520453b94549f4b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a real value within this namelist element. This function will check to ensure that the element expects a real number.  <br /></td></tr>
<tr class="separator:a0ca02db69a0bfba7520453b94549f4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71bcfdbbb52f1723e4e1158a26597b27" id="r_a71bcfdbbb52f1723e4e1158a26597b27"><td class="memItemLeft" align="right" valign="top"><a id="a71bcfdbbb52f1723e4e1158a26597b27" name="a71bcfdbbb52f1723e4e1158a26597b27"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setRealValue</b> (const std::string &amp;member_key, double value)</td></tr>
<tr class="separator:a71bcfdbbb52f1723e4e1158a26597b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6a90a3f680de3bd820f6dc80dd590fc7" id="r_a6a90a3f680de3bd820f6dc80dd590fc7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a90a3f680de3bd820f6dc80dd590fc7">setStringValue</a> (const std::string &amp;value)</td></tr>
<tr class="memdesc:a6a90a3f680de3bd820f6dc80dd590fc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a string value within this namelist element. This function will check to ensure that the element expects a string value.  <br /></td></tr>
<tr class="separator:a6a90a3f680de3bd820f6dc80dd590fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ccc91faabfa44635589b9551d609622" id="r_a5ccc91faabfa44635589b9551d609622"><td class="memItemLeft" align="right" valign="top"><a id="a5ccc91faabfa44635589b9551d609622" name="a5ccc91faabfa44635589b9551d609622"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setStringValue</b> (const std::string &amp;member_key, const std::string &amp;value)</td></tr>
<tr class="separator:a5ccc91faabfa44635589b9551d609622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a13adf9c54d18f2135abcda602c241826" id="r_a13adf9c54d18f2135abcda602c241826"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13adf9c54d18f2135abcda602c241826">setImperative</a> (const KeyRequirement imperative_in)</td></tr>
<tr class="memdesc:a13adf9c54d18f2135abcda602c241826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the requirement associated with a keyword.  <br /></td></tr>
<tr class="separator:a13adf9c54d18f2135abcda602c241826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dca616087eeff44387894d2b4c1dd9f" id="r_a9dca616087eeff44387894d2b4c1dd9f"><td class="memItemLeft" align="right" valign="top"><a id="a9dca616087eeff44387894d2b4c1dd9f" name="a9dca616087eeff44387894d2b4c1dd9f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setImperative</b> (const std::string &amp;sub_key_query, const KeyRequirement imperative_in)</td></tr>
<tr class="separator:a9dca616087eeff44387894d2b4c1dd9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:acb22a815caba5d311da6eb80da29362d" id="r_acb22a815caba5d311da6eb80da29362d"><td class="memItemLeft" align="right" valign="top"><a id="acb22a815caba5d311da6eb80da29362d" name="acb22a815caba5d311da6eb80da29362d"></a>
struct&#160;</td><td class="memItemRight" valign="bottom"><b>NamelistEmulator</b></td></tr>
<tr class="separator:acb22a815caba5d311da6eb80da29362d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>One keyword found in a namelist, ready to store the namelist variable moniker, the type, and the value read from the input file. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a330ed83d4ddcaa56856352914218a244" name="a330ed83d4ddcaa56856352914218a244"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a330ed83d4ddcaa56856352914218a244">&#9670;&#160;</a></span>NamelistElement() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">stormm::namelist::NamelistElement::NamelistElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>keyword_in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NamelistType</td>          <td class="paramname"><span class="paramname"><em>kind_in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>default_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::string(&quot;&quot;)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DefaultIsObligatory</td>          <td class="paramname"><span class="paramname"><em>obligate</em></span><span class="paramdefsep"> = </span><span class="paramdefval">DefaultIsObligatory::NO</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputRepeats</td>          <td class="paramname"><span class="paramname"><em>rep_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">InputRepeats::NO</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>help_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::string(&quot;No&#160;description&#160;provided&quot;)</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for a non-STRUCT <a class="el" href="classstormm_1_1namelist_1_1NamelistElement.html" title="One keyword found in a namelist, ready to store the namelist variable moniker, the type,...">NamelistElement</a>. </p>
<p>Overloaded:</p><ul>
<li>Constructor for INTEGER, REAL, and STRING keywords (not STRUCTs)</li>
<li>Constructor for STRUCT keywords</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyword_in</td><td>The name of the namelist variable </td></tr>
    <tr><td class="paramname">sub_keys_in</td><td>The name of STRUCT members within the namelist variable </td></tr>
    <tr><td class="paramname">kind_in</td><td>The kind of the namelist element (it will be checked to ensure that it is not STRUCT) </td></tr>
    <tr><td class="paramname">sub_kinds_in</td><td>The kinds of STRUCT members (the namelist variable itself is a STRUCT if this input argument is a vector) </td></tr>
    <tr><td class="paramname">rep_in</td><td>Flag to indicate whether the namelist input can repeat for additional values </td></tr>
    <tr><td class="paramname">help_in</td><td>User documentation for the keyword </td></tr>
    <tr><td class="paramname">sub_help_in</td><td>User documentation for sub-keys </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa339479aeaffe44677ddd9ad72f6b047" name="aa339479aeaffe44677ddd9ad72f6b047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa339479aeaffe44677ddd9ad72f6b047">&#9670;&#160;</a></span>NamelistElement() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">stormm::namelist::NamelistElement::NamelistElement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstormm_1_1namelist_1_1NamelistElement.html">NamelistElement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>original</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>With no const members and only Standard Template Library components, the default copy and move constructors, as well as the copy and move assignment operators, are valid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">original</td><td>The pre-existing object to copy or move </td></tr>
    <tr><td class="paramname">other</td><td>A pre-existing object to fulfill the right hand side of an assignment statement </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a36a4f04f87edd939ce1b099ec16db126" name="a36a4f04f87edd939ce1b099ec16db126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36a4f04f87edd939ce1b099ec16db126">&#9670;&#160;</a></span>activateBool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::namelist::NamelistElement::activateBool </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Activate a boolean value based on the mere presence of a keyword in the namelist. This function will check to verify that the keyword is a boolean. </p>
<p>Overloaded:</p><ul>
<li>Take a the keyword name</li>
<li>Take a sub-keyword and a value to fill in a BOOL member of a STRUCT kind element </li>
</ul>

</div>
</div>
<a id="a110dd7d5cba5e1bbb17757d53627428d" name="a110dd7d5cba5e1bbb17757d53627428d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a110dd7d5cba5e1bbb17757d53627428d">&#9670;&#160;</a></span>addDefaultValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::namelist::NamelistElement::addDefaultValue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>next_default</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Include an additional value as a default setting for a particular keyword. This enables a single keyword to have a default series of values. The supplied value will be interpreted according to the type of the element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_default</td><td>The extra default value to include </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a21efbcdfee8dcdbccd2ebfcd26597273" name="a21efbcdfee8dcdbccd2ebfcd26597273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21efbcdfee8dcdbccd2ebfcd26597273">&#9670;&#160;</a></span>getBoolValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stormm::namelist::NamelistElement::getBoolValue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>member_key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the boolean value to which a namelist element has been set (this value is set to TRUE if the keyword was found in the namelist or collection of STRUCT sub-keys, FALSE if not). </p>
<p>Overloaded:</p><ul>
<li>Take a STRUCT member variable name and the index of the particular STRUCT entry</li>
<li>Return the boolean value of the one and only valid entry of a non-STRUCT keyword</li>
<li>Return all BOOL values associated with a boolean member of a STRUCT keyword, which could have multiple entries</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">member_key</td><td>The (optional) name of a STRUCT member to access (an empty string indicates that the keyword is associated with INTEGER, REAL, or STRING data) </td></tr>
    <tr><td class="paramname">index</td><td>The entry to access </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a361afa7ce982b8742bd11527e0a909f3" name="a361afa7ce982b8742bd11527e0a909f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a361afa7ce982b8742bd11527e0a909f3">&#9670;&#160;</a></span>getEstablishment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InputStatus stormm::namelist::NamelistElement::getEstablishment </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>member_key</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::string(&quot;&quot;)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>repeat_no</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Report whether a value has been assigned, read from input, to this namelist element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">member_key</td><td>Name of the sub-key to search if the namelist element is a STRUCT </td></tr>
    <tr><td class="paramname">repeat_no</td><td>Index number of the repeated keyword application, if applicable. The establishment of a member keyword in the fourth application of a repeatable STRUCT keyword will be found in element 4 * (template_size) + member_idx of the input status array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a750bcdf4412ccd121158d42af57e71a4" name="a750bcdf4412ccd121158d42af57e71a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a750bcdf4412ccd121158d42af57e71a4">&#9670;&#160;</a></span>getImperative()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KeyRequirement stormm::namelist::NamelistElement::getImperative </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Report whether a keyword has been deemed essential, optional, or bogus in a particular context. This enables the same namelist to take on different profiles in different applications, and to report only that data which is relevant in the program output. </p>
<p>Overloaded:</p><ul>
<li>Get the criticality of the keyword</li>
<li>Get the criticality of a subkey within a STRUCT keyword</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sub_key_query</td><td>Name of the sub-key to search if the namelist element is a STRUCT </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e79fde975856507b78e75e090312c7c" name="a8e79fde975856507b78e75e090312c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e79fde975856507b78e75e090312c7c">&#9670;&#160;</a></span>getIntValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stormm::namelist::NamelistElement::getIntValue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>member_key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the integer value to which a namelist element has been set (this value is read from the namelist input file, i.e. mdin). Descriptions of input parameters follow from <a class="el" href="#a21efbcdfee8dcdbccd2ebfcd26597273" title="Get the boolean value to which a namelist element has been set (this value is set to TRUE if the keyw...">getBoolValue()</a>, above. </p>
<p>Overloaded:</p><ul>
<li>Take a STRUCT member variable name and the index of the particular STRUCT entry</li>
<li>Take an index only and return the integer value (the namelist element must be a non-STRUCT)</li>
<li>Return all INTEGER values associated with this keyword </li>
</ul>

</div>
</div>
<a id="a96e9f86da0e688a5d96093deb710fb8b" name="a96e9f86da0e688a5d96093deb710fb8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96e9f86da0e688a5d96093deb710fb8b">&#9670;&#160;</a></span>getKind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NamelistType stormm::namelist::NamelistElement::getKind </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the kind associated with a namelist element, i.e. nstlim is an INTEGER in Amber &amp;ctrl. </p>
<p>Overloaded:</p><ul>
<li>Get the kind of the element itself</li>
<li>Take the name of a sub-key to retrieve the kind of a member variable from a STRUCT </li>
</ul>

</div>
</div>
<a id="a5f92b5cce6c1c3ad69ae55411efdc410" name="a5f92b5cce6c1c3ad69ae55411efdc410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f92b5cce6c1c3ad69ae55411efdc410">&#9670;&#160;</a></span>getStringValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; stormm::namelist::NamelistElement::getStringValue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>member_key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the string value to which a namelist element has been set (this value is read from the namelist input file, i.e. mdin) </p>
<p>Overloaded:</p><ul>
<li>Take a STRUCT member variable name and the index of the particular STRUCT entry</li>
<li>Take an index only and return the string value (the namelist element must be a non-STRUCT)</li>
<li>Return all STRING values associated with this keyword</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">member_key</td><td>The (optional) name of a STRUCT member to access </td></tr>
    <tr><td class="paramname">index</td><td>The entry to access </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48041a4e56a02c009c2994928b2fddc9" name="a48041a4e56a02c009c2994928b2fddc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48041a4e56a02c009c2994928b2fddc9">&#9670;&#160;</a></span>reportNamelistTypeProblem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::namelist::NamelistElement::reportNamelistTypeProblem </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>caller</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>data_type</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Report an error based on an incorrect namelist element data type request. This is an assertion that debugs a program when a developer makes a mistake, not something that an end user should encounter, but it's helpful to have a more detailed description than assert() can provide. This always ends by throwing a runtime error and so is an acceptable way to fill a switch case. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">caller</td><td>The name of the member function of <a class="el" href="classstormm_1_1namelist_1_1NamelistElement.html" title="One keyword found in a namelist, ready to store the namelist variable moniker, the type,...">NamelistElement</a> calling this error </td></tr>
    <tr><td class="paramname">data_type</td><td>The name of the (erroneously) requested data type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59f23e05566771e7b48696fcfedcc07d" name="a59f23e05566771e7b48696fcfedcc07d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59f23e05566771e7b48696fcfedcc07d">&#9670;&#160;</a></span>setDefaultValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::namelist::NamelistElement::setDefaultValue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>modified_default</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>default_idx</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the default value for a particular keyword, overriding anything that might have been set beforehand. This can be useful when applying common keyword loading functions, to adapt the namelist elements for a specific program or context. </p>
<p>Overloaded:</p><ul>
<li>Set the default value for a non-STRUCT keyword</li>
<li>Set the default values for various sub-keys of a STRUCT keyword</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">modified_default</td><td>The new default setting to apply to the keyword </td></tr>
    <tr><td class="paramname">default_idx</td><td>The index of the default to set, in the event that there are already multiple default values </td></tr>
    <tr><td class="paramname">modified_defaults</td><td>The list of modified default values </td></tr>
    <tr><td class="paramname">sub_key_specs</td><td>The list of sub-keys to which each default corresponds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13adf9c54d18f2135abcda602c241826" name="a13adf9c54d18f2135abcda602c241826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13adf9c54d18f2135abcda602c241826">&#9670;&#160;</a></span>setImperative()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::namelist::NamelistElement::setImperative </td>
          <td>(</td>
          <td class="paramtype">const KeyRequirement</td>          <td class="paramname"><span class="paramname"><em>imperative_in</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the requirement associated with a keyword. </p>
<p>Overloaded:</p><ul>
<li>Set the criticality of a keyword</li>
<li>Set the criticality of a subkey within a STRUCT-type keyword</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">imperative_in</td><td>The criticality level of the keyword to set. Is it required, optional, or bogus in some context? </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3f2311dd4f3a8e291bcc206af87213f" name="aa3f2311dd4f3a8e291bcc206af87213f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3f2311dd4f3a8e291bcc206af87213f">&#9670;&#160;</a></span>setIntValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::namelist::NamelistElement::setIntValue </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an integer value within this namelist element. This function will check to ensure that the element expects an int. </p>
<p>Overloaded:</p><ul>
<li>Take a sub-keyword and a value to fill in an INTEGER member of a STRUCT kind element</li>
<li>Take a value only</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">member_key</td><td>If given, implies that the namelist element is a struct, and triggers a search through its members to find a match and finally place the int. </td></tr>
    <tr><td class="paramname">value</td><td>The value of the keyword or sub-key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a15c274f25d66a89482d20318d812f514" name="a15c274f25d66a89482d20318d812f514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15c274f25d66a89482d20318d812f514">&#9670;&#160;</a></span>setPolicy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::namelist::NamelistElement::setPolicy </td>
          <td>(</td>
          <td class="paramtype">ExceptionResponse</td>          <td class="paramname"><span class="paramname"><em>policy_in</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the way that this Namelist element will respond if it encounters bad input. The member variable associated with this function is not passed down as part of the constructor argument list, and would be tedious for the developer to enter over and over, so it is passed down based on the <a class="el" href="classstormm_1_1namelist_1_1NamelistEmulator.html" title="Collection of variables to transcribe information contained within a namelist.">NamelistEmulator</a>'s own setting by calling this function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">policy_in</td><td>The policy to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ca02db69a0bfba7520453b94549f4b6" name="a0ca02db69a0bfba7520453b94549f4b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ca02db69a0bfba7520453b94549f4b6">&#9670;&#160;</a></span>setRealValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::namelist::NamelistElement::setRealValue </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a real value within this namelist element. This function will check to ensure that the element expects a real number. </p>
<p>Overloaded:</p><ul>
<li>Take a sub-keyword and a value to fill in a REAL member of a STRUCT kind element</li>
<li>Take a value only</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">member_key</td><td>If given, implies that the namelist element is a struct, and triggers a search through its members to find a match and finally place the real number. </td></tr>
    <tr><td class="paramname">value</td><td>The value of the keyword or sub-key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a90a3f680de3bd820f6dc80dd590fc7" name="a6a90a3f680de3bd820f6dc80dd590fc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a90a3f680de3bd820f6dc80dd590fc7">&#9670;&#160;</a></span>setStringValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::namelist::NamelistElement::setStringValue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a string value within this namelist element. This function will check to ensure that the element expects a string value. </p>
<p>Overloaded:</p><ul>
<li>Take a sub-keyword and a value to fill in a STRING member of a STRUCT kind element</li>
<li>Take a value only</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">member_key</td><td>If given, implies that the namelist element is a struct, and triggers a search through its members to find a match and finally place the string. </td></tr>
    <tr><td class="paramname">value</td><td>The value of the keyword or sub-key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/Namelists/<a class="el" href="namelist__element_8h_source.html">namelist_element.h</a></li>
<li>src/Namelists/<b>namelist_element.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2
</small></address>
</div><!-- doc-content -->
</body>
</html>
