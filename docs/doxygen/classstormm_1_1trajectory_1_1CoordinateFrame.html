<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>STORMM Source Documentation: stormm::trajectory::CoordinateFrame Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">STORMM Source Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>stormm</b></li><li class="navelem"><b>trajectory</b></li><li class="navelem"><a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classstormm_1_1trajectory_1_1CoordinateFrame-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">stormm::trajectory::CoordinateFrame Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Store the coordinates and box information for a frame, only. This abridged struct can serve when the full <a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html" title="An object to complement a topology and hold positions, velocities, and forces of all particles in a s...">PhaseSpace</a> object would allocate too much memory. It also comes with its own POINTER mode, such that it allocates no memory of its own and merely points to another <a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html" title="Store the coordinates and box information for a frame, only. This abridged struct can serve when the ...">CoordinateFrame</a> object or <a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html" title="An object to complement a topology and hold positions, velocities, and forces of all particles in a s...">PhaseSpace</a> object that does have memory allocated.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="coordinateframe_8h_source.html">coordinateframe.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a78b7d667075db0e4596eab7df2ce7d1f" id="r_a78b7d667075db0e4596eab7df2ce7d1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78b7d667075db0e4596eab7df2ce7d1f">operator=</a> (const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> &amp;other)</td></tr>
<tr class="memdesc:a78b7d667075db0e4596eab7df2ce7d1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator likewise handles reassignment of internal POINTER-kind <a class="el" href="classstormm_1_1trajectory_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> objects.  <br /></td></tr>
<tr class="separator:a78b7d667075db0e4596eab7df2ce7d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a207799ec825202b462b6b8262e0aa036" id="r_a207799ec825202b462b6b8262e0aa036"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a207799ec825202b462b6b8262e0aa036">CoordinateFrame</a> (<a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> &amp;&amp;original)</td></tr>
<tr class="memdesc:a207799ec825202b462b6b8262e0aa036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor works in similar fashion to the <a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html" title="An object to complement a topology and hold positions, velocities, and forces of all particles in a s...">PhaseSpace</a> move constructor, with std::move and no need for reassignment of the underlying POINTER-kind <a class="el" href="classstormm_1_1trajectory_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> objects.  <br /></td></tr>
<tr class="separator:a207799ec825202b462b6b8262e0aa036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f47f9ffbe6623e745740fc83bc6899" id="r_a96f47f9ffbe6623e745740fc83bc6899"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96f47f9ffbe6623e745740fc83bc6899">operator=</a> (<a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a96f47f9ffbe6623e745740fc83bc6899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <br /></td></tr>
<tr class="separator:a96f47f9ffbe6623e745740fc83bc6899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7e483ce4e57d603db9bff28528ba26" id="r_a0d7e483ce4e57d603db9bff28528ba26"><td class="memItemLeft" align="right" valign="top"><a id="a0d7e483ce4e57d603db9bff28528ba26" name="a0d7e483ce4e57d603db9bff28528ba26"></a>
HybridFormat&#160;</td><td class="memItemRight" valign="bottom"><b>getFormat</b> () const</td></tr>
<tr class="memdesc:a0d7e483ce4e57d603db9bff28528ba26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the format of the object. <br /></td></tr>
<tr class="separator:a0d7e483ce4e57d603db9bff28528ba26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f5cd46d73c4c0a1830e20ea6bb08263" id="r_a9f5cd46d73c4c0a1830e20ea6bb08263"><td class="memItemLeft" align="right" valign="top"><a id="a9f5cd46d73c4c0a1830e20ea6bb08263" name="a9f5cd46d73c4c0a1830e20ea6bb08263"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getFileName</b> () const</td></tr>
<tr class="memdesc:a9f5cd46d73c4c0a1830e20ea6bb08263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the file name that originated this coordinate set. <br /></td></tr>
<tr class="separator:a9f5cd46d73c4c0a1830e20ea6bb08263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a44c37dc6f038a0a750caaebf2fc1dd" id="r_a2a44c37dc6f038a0a750caaebf2fc1dd"><td class="memItemLeft" align="right" valign="top"><a id="a2a44c37dc6f038a0a750caaebf2fc1dd" name="a2a44c37dc6f038a0a750caaebf2fc1dd"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getFrameNumber</b> () const</td></tr>
<tr class="memdesc:a2a44c37dc6f038a0a750caaebf2fc1dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the frame number, if this coordinate set originated in a trajectory. <br /></td></tr>
<tr class="separator:a2a44c37dc6f038a0a750caaebf2fc1dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365199e08acf05b1da9b75f0d63d86e6" id="r_a365199e08acf05b1da9b75f0d63d86e6"><td class="memItemLeft" align="right" valign="top"><a id="a365199e08acf05b1da9b75f0d63d86e6" name="a365199e08acf05b1da9b75f0d63d86e6"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getAtomCount</b> () const</td></tr>
<tr class="memdesc:a365199e08acf05b1da9b75f0d63d86e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of atoms in the frame. <br /></td></tr>
<tr class="separator:a365199e08acf05b1da9b75f0d63d86e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad10c784a2437b14fa67503def5d07d" id="r_a7ad10c784a2437b14fa67503def5d07d"><td class="memItemLeft" align="right" valign="top"><a id="a7ad10c784a2437b14fa67503def5d07d" name="a7ad10c784a2437b14fa67503def5d07d"></a>
UnitCellType&#160;</td><td class="memItemRight" valign="bottom"><b>getUnitCellType</b> () const</td></tr>
<tr class="memdesc:a7ad10c784a2437b14fa67503def5d07d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unit cell type of the coordinate system. <br /></td></tr>
<tr class="separator:a7ad10c784a2437b14fa67503def5d07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab5d470d1827e5ac7b6dfe205141773" id="r_a9ab5d470d1827e5ac7b6dfe205141773"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ab5d470d1827e5ac7b6dfe205141773">getBoxSpaceTransform</a> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:a9ab5d470d1827e5ac7b6dfe205141773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the transformation matrix to take coordinates into box (fractional) space. The result should be interpreted as a 3x3 matrix in column-major format.  <br /></td></tr>
<tr class="separator:a9ab5d470d1827e5ac7b6dfe205141773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739d66cb965300d5dde9101e26be3d89" id="r_a739d66cb965300d5dde9101e26be3d89"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a739d66cb965300d5dde9101e26be3d89">getInverseTransform</a> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:a739d66cb965300d5dde9101e26be3d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the transformation matrix to take coordinates from fractional space back into real space. The result should be interpreted as a 3x3 matrix in column-major format.  <br /></td></tr>
<tr class="separator:a739d66cb965300d5dde9101e26be3d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7337fd87e8373f8f463115f5cd6562d5" id="r_a7337fd87e8373f8f463115f5cd6562d5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7337fd87e8373f8f463115f5cd6562d5">getBoxDimensions</a> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:a7337fd87e8373f8f463115f5cd6562d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the box dimensions in their pure form. Holding the box dimensions and the transformation matrices they imply in separate member variables represents a liability, that they might at some point become inconsistent, but it also prevents having to continuously extract box dimensions from transformation matrices each time the box needs to be resized (beyond isotropic scaling, this is not a trivial process).  <br /></td></tr>
<tr class="separator:a7337fd87e8373f8f463115f5cd6562d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a979c27d731fc503f9c50a6fc38afba70" id="r_a979c27d731fc503f9c50a6fc38afba70"><td class="memItemLeft" align="right" valign="top"><a id="a979c27d731fc503f9c50a6fc38afba70" name="a979c27d731fc503f9c50a6fc38afba70"></a>
const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getSelfPointer</b> () const</td></tr>
<tr class="memdesc:a979c27d731fc503f9c50a6fc38afba70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the object itself, useful when working with a const reference. <br /></td></tr>
<tr class="separator:a979c27d731fc503f9c50a6fc38afba70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b3469ccca3887778ed602f13642a82" id="r_a32b3469ccca3887778ed602f13642a82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32b3469ccca3887778ed602f13642a82">exportToFile</a> (const std::string &amp;file_name, CoordinateFileKind output_kind=CoordinateFileKind::AMBER_CRD, PrintSituation expectation=PrintSituation::UNKNOWN, HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:a32b3469ccca3887778ed602f13642a82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export the contents of this coordinate series to a trajectory, restart, or input coordinates file.  <br /></td></tr>
<tr class="separator:a32b3469ccca3887778ed602f13642a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3615bb97bc79c209943dab182a6ebe" id="r_a5d3615bb97bc79c209943dab182a6ebe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d3615bb97bc79c209943dab182a6ebe">setFrameNumber</a> (int frame_number_in)</td></tr>
<tr class="memdesc:a5d3615bb97bc79c209943dab182a6ebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the frame number, for bookkeeping purposes. This function exists that the frame number does not become a necessary argument in one of the overloaded constructors.  <br /></td></tr>
<tr class="separator:a5d3615bb97bc79c209943dab182a6ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a235797902d134d9b974b10e57fa14a1e" id="r_a235797902d134d9b974b10e57fa14a1e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a235797902d134d9b974b10e57fa14a1e">CoordinateFrame</a> (int natom_in=0, UnitCellType unit_cell_in=UnitCellType::NONE, HybridFormat format_in=default_hpc_format)</td></tr>
<tr class="memdesc:a235797902d134d9b974b10e57fa14a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">There are several options for construction of this abridged, coordinate-only object.  <br /></td></tr>
<tr class="separator:a235797902d134d9b974b10e57fa14a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94b755a774e53a2a63714756539b1d0e" id="r_a94b755a774e53a2a63714756539b1d0e"><td class="memItemLeft" align="right" valign="top"><a id="a94b755a774e53a2a63714756539b1d0e" name="a94b755a774e53a2a63714756539b1d0e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CoordinateFrame</b> (int natom_in, UnitCellType unit_cell_in, const double *xcrd_in, const double *ycrd_in, const double *zcrd_in, const double *umat_in=nullptr, const double *invu_in=nullptr, const double *boxdim_in=nullptr, HybridFormat format_in=default_hpc_format)</td></tr>
<tr class="separator:a94b755a774e53a2a63714756539b1d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92cca6b2378929317ebc746f45d7dcff" id="r_a92cca6b2378929317ebc746f45d7dcff"><td class="memItemLeft" align="right" valign="top"><a id="a92cca6b2378929317ebc746f45d7dcff" name="a92cca6b2378929317ebc746f45d7dcff"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CoordinateFrame</b> (const std::string &amp;file_name_in, CoordinateFileKind file_kind=CoordinateFileKind::UNKNOWN, int frame_number_in=0, HybridFormat format_in=default_hpc_format)</td></tr>
<tr class="separator:a92cca6b2378929317ebc746f45d7dcff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e3c8a9320c112184aa108e62f5271d" id="r_ac0e3c8a9320c112184aa108e62f5271d"><td class="memItemLeft" align="right" valign="top"><a id="ac0e3c8a9320c112184aa108e62f5271d" name="ac0e3c8a9320c112184aa108e62f5271d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CoordinateFrame</b> (const <a class="el" href="classstormm_1_1parse_1_1TextFile.html">TextFile</a> &amp;tf, CoordinateFileKind file_kind=CoordinateFileKind::UNKNOWN, int frame_number_in=0, HybridFormat format_in=default_hpc_format)</td></tr>
<tr class="separator:ac0e3c8a9320c112184aa108e62f5271d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c825a9b9f72209aca2f5dae5cad48c2" id="r_a2c825a9b9f72209aca2f5dae5cad48c2"><td class="memItemLeft" align="right" valign="top"><a id="a2c825a9b9f72209aca2f5dae5cad48c2" name="a2c825a9b9f72209aca2f5dae5cad48c2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CoordinateFrame</b> (const <a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html">PhaseSpace</a> *ps)</td></tr>
<tr class="separator:a2c825a9b9f72209aca2f5dae5cad48c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5035c9a92e7beb17b529524869345a80" id="r_a5035c9a92e7beb17b529524869345a80"><td class="memItemLeft" align="right" valign="top"><a id="a5035c9a92e7beb17b529524869345a80" name="a5035c9a92e7beb17b529524869345a80"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CoordinateFrame</b> (const <a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html">PhaseSpace</a> &amp;ps)</td></tr>
<tr class="separator:a5035c9a92e7beb17b529524869345a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9f36b9d631991a7af6d4150b55974aae" id="r_a9f36b9d631991a7af6d4150b55974aae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f36b9d631991a7af6d4150b55974aae">CoordinateFrame</a> (const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> &amp;original)</td></tr>
<tr class="memdesc:a9f36b9d631991a7af6d4150b55974aae"><td class="mdescLeft">&#160;</td><td class="mdescRight">The copy constructor handles assignment of internal POINTER-kind <a class="el" href="classstormm_1_1trajectory_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> objects.  <br /></td></tr>
<tr class="separator:a9f36b9d631991a7af6d4150b55974aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a3dcfed6df82a7f0fe025f965edbbb" id="r_a53a3dcfed6df82a7f0fe025f965edbbb"><td class="memItemLeft" align="right" valign="top"><a id="a53a3dcfed6df82a7f0fe025f965edbbb" name="a53a3dcfed6df82a7f0fe025f965edbbb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CoordinateFrame</b> (const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> &amp;original, HybridFormat format_in)</td></tr>
<tr class="separator:a53a3dcfed6df82a7f0fe025f965edbbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac0a744c88d1fb224643fa204cfe1c7db" id="r_ac0a744c88d1fb224643fa204cfe1c7db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0a744c88d1fb224643fa204cfe1c7db">buildFromFile</a> (const std::string &amp;file_name_in, const CoordinateFileKind file_kind, int frame_number=0)</td></tr>
<tr class="memdesc:ac0a744c88d1fb224643fa204cfe1c7db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the object from information some coordinate, restart, or trajectory file.  <br /></td></tr>
<tr class="separator:ac0a744c88d1fb224643fa204cfe1c7db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845ad15b4386a78718f254ba55a49323" id="r_a845ad15b4386a78718f254ba55a49323"><td class="memItemLeft" align="right" valign="top"><a id="a845ad15b4386a78718f254ba55a49323" name="a845ad15b4386a78718f254ba55a49323"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>buildFromFile</b> (const <a class="el" href="classstormm_1_1parse_1_1TextFile.html">TextFile</a> &amp;tf, const CoordinateFileKind file_kind, int frame_number=0)</td></tr>
<tr class="separator:a845ad15b4386a78718f254ba55a49323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a93fc71dac7333f4ec300cf48d6ed0f1e" id="r_a93fc71dac7333f4ec300cf48d6ed0f1e"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a93fc71dac7333f4ec300cf48d6ed0f1e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a93fc71dac7333f4ec300cf48d6ed0f1e">fill</a> (const T *xcrd, const T *ycrd, const T *zcrd, int scale_bits=0, const double *box_dims=nullptr)</td></tr>
<tr class="memdesc:a93fc71dac7333f4ec300cf48d6ed0f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the object from information in three arrays.  <br /></td></tr>
<tr class="separator:a93fc71dac7333f4ec300cf48d6ed0f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3abba97373f11f01297b42663fd8272d" id="r_a3abba97373f11f01297b42663fd8272d"><td class="memTemplParams" colspan="2"><a id="a3abba97373f11f01297b42663fd8272d" name="a3abba97373f11f01297b42663fd8272d"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:a3abba97373f11f01297b42663fd8272d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fill</b> (const std::vector&lt; T &gt; &amp;xcrd, const std::vector&lt; T &gt; &amp;ycrd, const std::vector&lt; T &gt; &amp;zcrd, int scale_bits=0, const std::vector&lt; double &gt; &amp;box_dims={})</td></tr>
<tr class="separator:a3abba97373f11f01297b42663fd8272d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a349d5cc1642e050e6f028ff156be5618" id="r_a349d5cc1642e050e6f028ff156be5618"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a349d5cc1642e050e6f028ff156be5618">getInterlacedCoordinates</a> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:a349d5cc1642e050e6f028ff156be5618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the coordinates returned in an X/Y/Z interlaced manner.  <br /></td></tr>
<tr class="separator:a349d5cc1642e050e6f028ff156be5618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e25d82bfca07062db4653101db7fec" id="r_a16e25d82bfca07062db4653101db7fec"><td class="memItemLeft" align="right" valign="top"><a id="a16e25d82bfca07062db4653101db7fec" name="a16e25d82bfca07062db4653101db7fec"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getInterlacedCoordinates</b> (int low_index, int high_index, HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="separator:a16e25d82bfca07062db4653101db7fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9ed8785d414097b193e4c1c44677da27" id="r_a9ed8785d414097b193e4c1c44677da27"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; double &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ed8785d414097b193e4c1c44677da27">getCoordinateHandle</a> (CartesianDimension dim) const</td></tr>
<tr class="memdesc:a9ed8785d414097b193e4c1c44677da27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to one of the coordinate arrays.  <br /></td></tr>
<tr class="separator:a9ed8785d414097b193e4c1c44677da27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e56395b0c1f8e01542aefb04bdc1d08" id="r_a3e56395b0c1f8e01542aefb04bdc1d08"><td class="memItemLeft" align="right" valign="top"><a id="a3e56395b0c1f8e01542aefb04bdc1d08" name="a3e56395b0c1f8e01542aefb04bdc1d08"></a>
<a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; double &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>getCoordinateHandle</b> (CartesianDimension dim)</td></tr>
<tr class="separator:a3e56395b0c1f8e01542aefb04bdc1d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae0123749a3b7c4bff2856e21cc9410ab" id="r_ae0123749a3b7c4bff2856e21cc9410ab"><td class="memItemLeft" align="right" valign="top"><a id="ae0123749a3b7c4bff2856e21cc9410ab" name="ae0123749a3b7c4bff2856e21cc9410ab"></a>
const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; double &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>getBoxTransformHandle</b> () const</td></tr>
<tr class="memdesc:ae0123749a3b7c4bff2856e21cc9410ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the box space transform. Overloading follows from <a class="el" href="#a9ed8785d414097b193e4c1c44677da27" title="Get a pointer to one of the coordinate arrays.">getCoordinateHandle()</a>, above. <br /></td></tr>
<tr class="separator:ae0123749a3b7c4bff2856e21cc9410ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f96935857d5c3b060d5a38ea197131" id="r_a03f96935857d5c3b060d5a38ea197131"><td class="memItemLeft" align="right" valign="top"><a id="a03f96935857d5c3b060d5a38ea197131" name="a03f96935857d5c3b060d5a38ea197131"></a>
<a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; double &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>getBoxTransformHandle</b> ()</td></tr>
<tr class="separator:a03f96935857d5c3b060d5a38ea197131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a79b7b6e216b201bc98aba46004db3d58" id="r_a79b7b6e216b201bc98aba46004db3d58"><td class="memItemLeft" align="right" valign="top"><a id="a79b7b6e216b201bc98aba46004db3d58" name="a79b7b6e216b201bc98aba46004db3d58"></a>
const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; double &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>getInverseTransformHandle</b> () const</td></tr>
<tr class="memdesc:a79b7b6e216b201bc98aba46004db3d58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the inverse transform that takes coordinates back into real space. Overloading follows from <a class="el" href="#a9ed8785d414097b193e4c1c44677da27" title="Get a pointer to one of the coordinate arrays.">getCoordinateHandle()</a>, above. <br /></td></tr>
<tr class="separator:a79b7b6e216b201bc98aba46004db3d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a008e4025dd5430e5ab31b1b04f8171b6" id="r_a008e4025dd5430e5ab31b1b04f8171b6"><td class="memItemLeft" align="right" valign="top"><a id="a008e4025dd5430e5ab31b1b04f8171b6" name="a008e4025dd5430e5ab31b1b04f8171b6"></a>
<a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; double &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>getInverseTransformHandle</b> ()</td></tr>
<tr class="separator:a008e4025dd5430e5ab31b1b04f8171b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a426107821bcbb657e8e092d401e79bf2" id="r_a426107821bcbb657e8e092d401e79bf2"><td class="memItemLeft" align="right" valign="top"><a id="a426107821bcbb657e8e092d401e79bf2" name="a426107821bcbb657e8e092d401e79bf2"></a>
const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; double &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>getBoxDimensionsHandle</b> () const</td></tr>
<tr class="memdesc:a426107821bcbb657e8e092d401e79bf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the transform that takes coordinates back into real space. Overloading follows from <a class="el" href="#a9ed8785d414097b193e4c1c44677da27" title="Get a pointer to one of the coordinate arrays.">getCoordinateHandle()</a>, above. <br /></td></tr>
<tr class="separator:a426107821bcbb657e8e092d401e79bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa64f36dc7a5a22eb0ee088681cf1b2de" id="r_aa64f36dc7a5a22eb0ee088681cf1b2de"><td class="memItemLeft" align="right" valign="top"><a id="aa64f36dc7a5a22eb0ee088681cf1b2de" name="aa64f36dc7a5a22eb0ee088681cf1b2de"></a>
<a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; double &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>getBoxDimensionsHandle</b> ()</td></tr>
<tr class="separator:aa64f36dc7a5a22eb0ee088681cf1b2de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a02b7ee847df6bf4429bbf236bf1bf8a5" id="r_a02b7ee847df6bf4429bbf236bf1bf8a5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; double &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02b7ee847df6bf4429bbf236bf1bf8a5">getStorageHandle</a> () const</td></tr>
<tr class="memdesc:a02b7ee847df6bf4429bbf236bf1bf8a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the storage array accessible outside the object.  <br /></td></tr>
<tr class="separator:a02b7ee847df6bf4429bbf236bf1bf8a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5abddb9635ebb2baf2f792dca8a402dd" id="r_a5abddb9635ebb2baf2f792dca8a402dd"><td class="memItemLeft" align="right" valign="top"><a id="a5abddb9635ebb2baf2f792dca8a402dd" name="a5abddb9635ebb2baf2f792dca8a402dd"></a>
<a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; double &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>getStorageHandle</b> ()</td></tr>
<tr class="separator:a5abddb9635ebb2baf2f792dca8a402dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3706f964d2c70d04cbb85be41fdbed79" id="r_a3706f964d2c70d04cbb85be41fdbed79"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structstormm_1_1trajectory_1_1CoordinateFrameReader.html">CoordinateFrameReader</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3706f964d2c70d04cbb85be41fdbed79">data</a> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:a3706f964d2c70d04cbb85be41fdbed79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the abstract for this object, containing C-style pointers for the most rapid access to any of its member variables.  <br /></td></tr>
<tr class="separator:a3706f964d2c70d04cbb85be41fdbed79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d6c8c6e19bd72bee512f7f28eb25a9" id="r_ab3d6c8c6e19bd72bee512f7f28eb25a9"><td class="memItemLeft" align="right" valign="top"><a id="ab3d6c8c6e19bd72bee512f7f28eb25a9" name="ab3d6c8c6e19bd72bee512f7f28eb25a9"></a>
<a class="el" href="structstormm_1_1trajectory_1_1CoordinateFrameWriter.html">CoordinateFrameWriter</a>&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> (HybridTargetLevel tier=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:ab3d6c8c6e19bd72bee512f7f28eb25a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Store the coordinates and box information for a frame, only. This abridged struct can serve when the full <a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html" title="An object to complement a topology and hold positions, velocities, and forces of all particles in a s...">PhaseSpace</a> object would allocate too much memory. It also comes with its own POINTER mode, such that it allocates no memory of its own and merely points to another <a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html" title="Store the coordinates and box information for a frame, only. This abridged struct can serve when the ...">CoordinateFrame</a> object or <a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html" title="An object to complement a topology and hold positions, velocities, and forces of all particles in a s...">PhaseSpace</a> object that does have memory allocated. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a235797902d134d9b974b10e57fa14a1e" name="a235797902d134d9b974b10e57fa14a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a235797902d134d9b974b10e57fa14a1e">&#9670;&#160;</a></span>CoordinateFrame() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">stormm::trajectory::CoordinateFrame::CoordinateFrame </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>natom_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnitCellType</td>          <td class="paramname"><span class="paramname"><em>unit_cell_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">UnitCellType::NONE</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HybridFormat</td>          <td class="paramname"><span class="paramname"><em>format_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">default_hpc_format</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>There are several options for construction of this abridged, coordinate-only object. </p>
<p>Overloaded:</p><ul>
<li>Allocate to hold a given number of atoms</li>
<li>From an atom count and a set of double-precision C-style arrays, including coordinates and box dimensions</li>
<li>Create from any of the coordinate file formats (velocities will not be read, even if they are available)</li>
<li>From an existing <a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html" title="An object to complement a topology and hold positions, velocities, and forces of all particles in a s...">PhaseSpace</a> object (as a pointer or a copy if the <a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html" title="An object to complement a topology and hold positions, velocities, and forces of all particles in a s...">PhaseSpace</a> object is non-const, otherwise only as a copy)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">natom_in</td><td>The number of atoms expected </td></tr>
    <tr><td class="paramname">xcrd_in</td><td>Cartesian X coordinates of all particles </td></tr>
    <tr><td class="paramname">ycrd_in</td><td>Cartesian Y coordinates of all particles </td></tr>
    <tr><td class="paramname">zcrd_in</td><td>Cartesian Z coordinates of all particles </td></tr>
    <tr><td class="paramname">umat_in</td><td>Matrix to transform coordinates into box space (3 x 3) </td></tr>
    <tr><td class="paramname">invu_in</td><td>Matrix to transform coordinates into real space (3 x 3) </td></tr>
    <tr><td class="paramname">file_name_in</td><td>File to read from </td></tr>
    <tr><td class="paramname">file_kind</td><td>The type of coordinate file to expect </td></tr>
    <tr><td class="paramname">frame_number_in</td><td>Frame number of the file to read (default 0, the first frame) </td></tr>
    <tr><td class="paramname">ps</td><td>Pre-existing object with complete description of the system state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f36b9d631991a7af6d4150b55974aae" name="a9f36b9d631991a7af6d4150b55974aae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f36b9d631991a7af6d4150b55974aae">&#9670;&#160;</a></span>CoordinateFrame() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">stormm::trajectory::CoordinateFrame::CoordinateFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>original</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The copy constructor handles assignment of internal POINTER-kind <a class="el" href="classstormm_1_1trajectory_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> objects. </p>
<p>Overloaded:</p><ul>
<li>Take the original object's memory layout</li>
<li>Apply an alternate memory layout. The content will be determined by whatever content is available in the original object at each tier of memory: if the new object is to have a memory component on the GPU device and the original object also has a memory component on the GPU, then this is the state that will be copied over. Otherwise, the original object's data from the CPU host will become the new object's GPU component. This priority of "copy data from what exists at the same level, otherwise take from the other
    level" applies everywhere.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">original</td><td>The <a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html" title="An object to complement a topology and hold positions, velocities, and forces of all particles in a s...">PhaseSpace</a> object from which to make a deep copy </td></tr>
    <tr><td class="paramname">format_in</td><td>An alternate memory format in which to lay out the new <a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html" title="Store the coordinates and box information for a frame, only. This abridged struct can serve when the ...">CoordinateFrame</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a207799ec825202b462b6b8262e0aa036" name="a207799ec825202b462b6b8262e0aa036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a207799ec825202b462b6b8262e0aa036">&#9670;&#160;</a></span>CoordinateFrame() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">stormm::trajectory::CoordinateFrame::CoordinateFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>original</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move constructor works in similar fashion to the <a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html" title="An object to complement a topology and hold positions, velocities, and forces of all particles in a s...">PhaseSpace</a> move constructor, with std::move and no need for reassignment of the underlying POINTER-kind <a class="el" href="classstormm_1_1trajectory_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">original</td><td>The <a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html" title="An object to complement a topology and hold positions, velocities, and forces of all particles in a s...">PhaseSpace</a> object from which to make a deep copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac0a744c88d1fb224643fa204cfe1c7db" name="ac0a744c88d1fb224643fa204cfe1c7db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0a744c88d1fb224643fa204cfe1c7db">&#9670;&#160;</a></span>buildFromFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::trajectory::CoordinateFrame::buildFromFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>file_name_in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoordinateFileKind</td>          <td class="paramname"><span class="paramname"><em>file_kind</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>frame_number</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill the object from information some coordinate, restart, or trajectory file. </p>
<p>Overloaded:</p><ul>
<li>Take a file name</li>
<li>Take an ASCII-format text file already processed into RAM</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_name</td><td>Name of the file from which to obtain coordinates </td></tr>
    <tr><td class="paramname">file_kind</td><td>The type of coordinate-containing input file </td></tr>
    <tr><td class="paramname">frame_number</td><td>The frame number to read (if the file is a trajectory, not a single point from the system's phase space) </td></tr>
    <tr><td class="paramname">tf</td><td>Text file data already processed into RAM </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3706f964d2c70d04cbb85be41fdbed79" name="a3706f964d2c70d04cbb85be41fdbed79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3706f964d2c70d04cbb85be41fdbed79">&#9670;&#160;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structstormm_1_1trajectory_1_1CoordinateFrameReader.html">CoordinateFrameReader</a> stormm::trajectory::CoordinateFrame::data </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the abstract for this object, containing C-style pointers for the most rapid access to any of its member variables. </p>
<p>Overloaded:</p><ul>
<li>Get a read-only abstract from a const object</li>
<li>Get a writeable abstract from a mutable object </li>
</ul>

</div>
</div>
<a id="a32b3469ccca3887778ed602f13642a82" name="a32b3469ccca3887778ed602f13642a82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b3469ccca3887778ed602f13642a82">&#9670;&#160;</a></span>exportToFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::trajectory::CoordinateFrame::exportToFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>file_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoordinateFileKind</td>          <td class="paramname"><span class="paramname"><em>output_kind</em></span><span class="paramdefsep"> = </span><span class="paramdefval">CoordinateFileKind::AMBER_CRD</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PrintSituation</td>          <td class="paramname"><span class="paramname"><em>expectation</em></span><span class="paramdefsep"> = </span><span class="paramdefval">PrintSituation::UNKNOWN</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export the contents of this coordinate series to a trajectory, restart, or input coordinates file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_name</td><td>Name of the file to write </td></tr>
    <tr><td class="paramname">output_kind</td><td>The format of the file to write (checkpoint files print position and velocity data by obligation, but trajectory files can contain either of these as well as forces) </td></tr>
    <tr><td class="paramname">expectation</td><td>The condition in which the output file is expected to be found </td></tr>
    <tr><td class="paramname">tier</td><td>Indicate whether to obtain data on the CPU host or GPU device. To print GPU-based coordinates will not alter data on the CPU host. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a93fc71dac7333f4ec300cf48d6ed0f1e" name="a93fc71dac7333f4ec300cf48d6ed0f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93fc71dac7333f4ec300cf48d6ed0f1e">&#9670;&#160;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stormm::trajectory::CoordinateFrame::fill </td>
          <td>(</td>
          <td class="paramtype">const T *</td>          <td class="paramname"><span class="paramname"><em>xcrd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *</td>          <td class="paramname"><span class="paramname"><em>ycrd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *</td>          <td class="paramname"><span class="paramname"><em>zcrd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>scale_bits</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *</td>          <td class="paramname"><span class="paramname"><em>box_dims</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill the object from information in three arrays. </p>
<p>Overloaded:</p><ul>
<li>Fill from a collection of C-style arrays</li>
<li>Fill from a collection of Standard Template Library vector objects</li>
<li>Fill from a collection of <a class="el" href="classstormm_1_1trajectory_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> objects</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xcrd</td><td>Cartesian X coordinates of positions, velocities, or forces </td></tr>
    <tr><td class="paramname">ycrd</td><td>Cartesian Y coordinates of positions, velocities, or forces </td></tr>
    <tr><td class="paramname">zcrd</td><td>Cartesian Z coordinates of positions, velocities, or forces </td></tr>
    <tr><td class="paramname">kind</td><td>Type of coordinates coming in: fill the positions, velocities, or forces </td></tr>
    <tr><td class="paramname">cycle_in</td><td>The point in the coordinate cycle to fill </td></tr>
    <tr><td class="paramname">scale_bits</td><td>The number of bits after the decimal, applicable to fixed-precision representations of xcrd, ycrd, and zcrd (the box dimensions are always given as a double-precision array, in units of Angstroms) </td></tr>
    <tr><td class="paramname">box_dims</td><td>Box dimensions, from which the tranformation matrices will be derived </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7337fd87e8373f8f463115f5cd6562d5" name="a7337fd87e8373f8f463115f5cd6562d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7337fd87e8373f8f463115f5cd6562d5">&#9670;&#160;</a></span>getBoxDimensions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; stormm::trajectory::CoordinateFrame::getBoxDimensions </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the box dimensions in their pure form. Holding the box dimensions and the transformation matrices they imply in separate member variables represents a liability, that they might at some point become inconsistent, but it also prevents having to continuously extract box dimensions from transformation matrices each time the box needs to be resized (beyond isotropic scaling, this is not a trivial process). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tier</td><td>Level at which to retrieve the data (if STORMM is compiled to run on a GPU) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ab5d470d1827e5ac7b6dfe205141773" name="a9ab5d470d1827e5ac7b6dfe205141773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ab5d470d1827e5ac7b6dfe205141773">&#9670;&#160;</a></span>getBoxSpaceTransform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; stormm::trajectory::CoordinateFrame::getBoxSpaceTransform </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the transformation matrix to take coordinates into box (fractional) space. The result should be interpreted as a 3x3 matrix in column-major format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tier</td><td>Level at which to retrieve the data (if STORMM is compiled to run on a GPU) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ed8785d414097b193e4c1c44677da27" name="a9ed8785d414097b193e4c1c44677da27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ed8785d414097b193e4c1c44677da27">&#9670;&#160;</a></span>getCoordinateHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; double &gt; * stormm::trajectory::CoordinateFrame::getCoordinateHandle </td>
          <td>(</td>
          <td class="paramtype">CartesianDimension</td>          <td class="paramname"><span class="paramname"><em>dim</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to one of the coordinate arrays. </p>
<p>Overloaded:</p><ul>
<li>Get a const pointer to the storage array of a const object</li>
<li>Get a non-const pointer to the storage space of a mutable object.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>Specify coordinate data along one of the Cartesian axes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a349d5cc1642e050e6f028ff156be5618" name="a349d5cc1642e050e6f028ff156be5618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a349d5cc1642e050e6f028ff156be5618">&#9670;&#160;</a></span>getInterlacedCoordinates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; stormm::trajectory::CoordinateFrame::getInterlacedCoordinates </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the coordinates returned in an X/Y/Z interlaced manner. </p>
<p>Overloaded:</p><ul>
<li>Get all coordinates</li>
<li>Get coordinates for a range of atoms</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">low_index</td><td>The lower atom index of a range </td></tr>
    <tr><td class="paramname">high_index</td><td>The upper atom index of a range </td></tr>
    <tr><td class="paramname">kind</td><td>Specify coordinates, velocities, or forces&ndash;anything that could be thought of as a trajectory </td></tr>
    <tr><td class="paramname">tier</td><td>Level at which to extract the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a739d66cb965300d5dde9101e26be3d89" name="a739d66cb965300d5dde9101e26be3d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a739d66cb965300d5dde9101e26be3d89">&#9670;&#160;</a></span>getInverseTransform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; stormm::trajectory::CoordinateFrame::getInverseTransform </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the transformation matrix to take coordinates from fractional space back into real space. The result should be interpreted as a 3x3 matrix in column-major format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tier</td><td>Level at which to retrieve the data (if STORMM is compiled to run on a GPU) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a02b7ee847df6bf4429bbf236bf1bf8a5" name="a02b7ee847df6bf4429bbf236bf1bf8a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02b7ee847df6bf4429bbf236bf1bf8a5">&#9670;&#160;</a></span>getStorageHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; double &gt; * stormm::trajectory::CoordinateFrame::getStorageHandle </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the storage array accessible outside the object. </p>
<p>Overloaded:</p><ul>
<li>Get a const pointer to the storage array of a const object</li>
<li>Get a non-const pointer to the storage space of a mutable object. </li>
</ul>

</div>
</div>
<a id="a78b7d667075db0e4596eab7df2ce7d1f" name="a78b7d667075db0e4596eab7df2ce7d1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78b7d667075db0e4596eab7df2ce7d1f">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> &amp; stormm::trajectory::CoordinateFrame::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment operator likewise handles reassignment of internal POINTER-kind <a class="el" href="classstormm_1_1trajectory_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another way to say original, in a different semantic context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96f47f9ffbe6623e745740fc83bc6899" name="a96f47f9ffbe6623e745740fc83bc6899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f47f9ffbe6623e745740fc83bc6899">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> &amp; stormm::trajectory::CoordinateFrame::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another way to say original, in a different semantic context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d3615bb97bc79c209943dab182a6ebe" name="a5d3615bb97bc79c209943dab182a6ebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d3615bb97bc79c209943dab182a6ebe">&#9670;&#160;</a></span>setFrameNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::trajectory::CoordinateFrame::setFrameNumber </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>frame_number_in</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the frame number, for bookkeeping purposes. This function exists that the frame number does not become a necessary argument in one of the overloaded constructors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame_number_in</td><td>The (arbitrary) number to set the frame as </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/Trajectory/<a class="el" href="coordinateframe_8h_source.html">coordinateframe.h</a></li>
<li>src/Trajectory/<b>coordinateframe.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2
</small></address>
</div><!-- doc-content -->
</body>
</html>
