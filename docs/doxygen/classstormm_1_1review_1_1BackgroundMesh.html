<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>STORMM Source Documentation: stormm::review::BackgroundMesh&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">STORMM Source Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>stormm</b></li><li class="navelem"><b>review</b></li><li class="navelem"><a class="el" href="classstormm_1_1review_1_1BackgroundMesh.html">BackgroundMesh</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classstormm_1_1review_1_1BackgroundMesh-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">stormm::review::BackgroundMesh&lt; T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A workspace for constructing a pure potential mesh based on the frozen atoms of a large molecule. If the large molecule has nonrigid components, they must be excluded from contributing to the grid. In addition, any atoms up to 1:4 (connected by three bonds or less) must also be excluded from the grid-based potential. Computations on these atoms will not be accurate off the grid, but since they are frozen the consequences are mitigated.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="background__mesh_8h_source.html">background_mesh.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a930389bbdc32c13e74ede234031e9533" id="r_a930389bbdc32c13e74ede234031e9533"><td class="memItemLeft" align="right" valign="top"><a id="a930389bbdc32c13e74ede234031e9533" name="a930389bbdc32c13e74ede234031e9533"></a>
const <a class="el" href="classstormm_1_1structure_1_1MeshParameters.html">MeshParameters</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getDimensions</b> () const</td></tr>
<tr class="memdesc:a930389bbdc32c13e74ede234031e9533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an object describing the mesh dimensions. <br /></td></tr>
<tr class="separator:a930389bbdc32c13e74ede234031e9533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b36fc268157271ae9467928b2fe0321" id="r_a1b36fc268157271ae9467928b2fe0321"><td class="memItemLeft" align="right" valign="top"><a id="a1b36fc268157271ae9467928b2fe0321" name="a1b36fc268157271ae9467928b2fe0321"></a>
const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getTopologyPointer</b> () const</td></tr>
<tr class="memdesc:a1b36fc268157271ae9467928b2fe0321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const pointer to the topology responsible for creating this mesh. <br /></td></tr>
<tr class="separator:a1b36fc268157271ae9467928b2fe0321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab50ee1eca85ecb62348a9eed44600057" id="r_ab50ee1eca85ecb62348a9eed44600057"><td class="memItemLeft" align="right" valign="top"><a id="ab50ee1eca85ecb62348a9eed44600057" name="ab50ee1eca85ecb62348a9eed44600057"></a>
const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getCoordinatePointer</b> () const</td></tr>
<tr class="memdesc:ab50ee1eca85ecb62348a9eed44600057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const pointer to the coordinates responsible for creating this mesh. <br /></td></tr>
<tr class="separator:ab50ee1eca85ecb62348a9eed44600057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39786715e0aeb496c26d40c3e9573794" id="r_a39786715e0aeb496c26d40c3e9573794"><td class="memTemplParams" colspan="2"><a id="a39786715e0aeb496c26d40c3e9573794" name="a39786715e0aeb496c26d40c3e9573794"></a>
template&lt;typename Tcoord&gt; </td></tr>
<tr class="memitem:a39786715e0aeb496c26d40c3e9573794"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateSeries.html">CoordinateSeries</a>&lt; Tcoord &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getEnsemblePointer</b> () const</td></tr>
<tr class="memdesc:a39786715e0aeb496c26d40c3e9573794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reference to the array of structures (each stored as a <a class="el" href="classstormm_1_1review_1_1CoordinateFrame.html" title="Store the coordinates and box information for a frame, only. This abridged struct can serve when the ...">CoordinateFrame</a>) reponsible for creating this mesh. <br /></td></tr>
<tr class="separator:a39786715e0aeb496c26d40c3e9573794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2655049bf1fc0681ba25d40671115b74" id="r_a2655049bf1fc0681ba25d40671115b74"><td class="memItemLeft" align="right" valign="top"><a id="a2655049bf1fc0681ba25d40671115b74" name="a2655049bf1fc0681ba25d40671115b74"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>getEnsembleTypeCode</b> () const</td></tr>
<tr class="memdesc:a2655049bf1fc0681ba25d40671115b74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the codified data type of the ensemble. <br /></td></tr>
<tr class="separator:a2655049bf1fc0681ba25d40671115b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e6345d4c106908b45179b433ca1833" id="r_ac1e6345d4c106908b45179b433ca1833"><td class="memItemLeft" align="right" valign="top"><a id="ac1e6345d4c106908b45179b433ca1833" name="ac1e6345d4c106908b45179b433ca1833"></a>
GridDetail&#160;</td><td class="memItemRight" valign="bottom"><b>getMeshKind</b> () const</td></tr>
<tr class="memdesc:ac1e6345d4c106908b45179b433ca1833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of mesh. <br /></td></tr>
<tr class="separator:ac1e6345d4c106908b45179b433ca1833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3582d560da94058052d4426fab06b22e" id="r_a3582d560da94058052d4426fab06b22e"><td class="memItemLeft" align="right" valign="top"><a id="a3582d560da94058052d4426fab06b22e" name="a3582d560da94058052d4426fab06b22e"></a>
NonbondedPotential&#160;</td><td class="memItemRight" valign="bottom"><b>getNonbondedPotential</b> () const</td></tr>
<tr class="memdesc:a3582d560da94058052d4426fab06b22e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the non-bonded potential expressed on the mesh. This will return an error if the mesh is not associated with a non-bonded potential. <br /></td></tr>
<tr class="separator:a3582d560da94058052d4426fab06b22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c51d9f737470c71c63cc24842307ff" id="r_a50c51d9f737470c71c63cc24842307ff"><td class="memItemLeft" align="right" valign="top"><a id="a50c51d9f737470c71c63cc24842307ff" name="a50c51d9f737470c71c63cc24842307ff"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getProbeRadius</b> () const</td></tr>
<tr class="memdesc:a50c51d9f737470c71c63cc24842307ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the probe radius. Valid for all types of meshes. <br /></td></tr>
<tr class="separator:a50c51d9f737470c71c63cc24842307ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ab94b92ed3d7a0fa209aea338b66b9" id="r_ae4ab94b92ed3d7a0fa209aea338b66b9"><td class="memItemLeft" align="right" valign="top"><a id="ae4ab94b92ed3d7a0fa209aea338b66b9" name="ae4ab94b92ed3d7a0fa209aea338b66b9"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getWellDepth</b> () const</td></tr>
<tr class="memdesc:ae4ab94b92ed3d7a0fa209aea338b66b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the non-bonded probe well depth. This is valid only for non-bonded fields, in particular those associated with a van-der Waals potential. <br /></td></tr>
<tr class="separator:ae4ab94b92ed3d7a0fa209aea338b66b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e7618f77becc0eba4d38422959caa8d" id="r_a8e7618f77becc0eba4d38422959caa8d"><td class="memItemLeft" align="right" valign="top"><a id="a8e7618f77becc0eba4d38422959caa8d" name="a8e7618f77becc0eba4d38422959caa8d"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getClashDistance</b> () const</td></tr>
<tr class="memdesc:a8e7618f77becc0eba4d38422959caa8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the absolute distance at which softcore electrostatic interactions take over. This is provided for utility and accesses the nested nonbonded_model <a class="el" href="classstormm_1_1structure_1_1MeshForceField.html" title="A class to hold the rules by which the system underlying a mesh object interacts with its surrounding...">MeshForceField</a> class member variable. <br /></td></tr>
<tr class="separator:a8e7618f77becc0eba4d38422959caa8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8cdf871e5079adba2c2fe2525bc3017" id="r_aa8cdf871e5079adba2c2fe2525bc3017"><td class="memItemLeft" align="right" valign="top"><a id="aa8cdf871e5079adba2c2fe2525bc3017" name="aa8cdf871e5079adba2c2fe2525bc3017"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getClashRatio</b> () const</td></tr>
<tr class="memdesc:aa8cdf871e5079adba2c2fe2525bc3017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ratio of the van-der Waals (Lennard-Jones) sigma parameter for interacting pairs of particles at which softcore van-der Waals interactions take over. This is provided for utility and accesses the nested nonbonded_model <a class="el" href="classstormm_1_1structure_1_1MeshForceField.html" title="A class to hold the rules by which the system underlying a mesh object interacts with its surrounding...">MeshForceField</a> class member variable. <br /></td></tr>
<tr class="separator:aa8cdf871e5079adba2c2fe2525bc3017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5988962a4f61e67f69b6b458a75cac09" id="r_a5988962a4f61e67f69b6b458a75cac09"><td class="memItemLeft" align="right" valign="top"><a id="a5988962a4f61e67f69b6b458a75cac09" name="a5988962a4f61e67f69b6b458a75cac09"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getOcclusionPenalty</b> () const</td></tr>
<tr class="memdesc:a5988962a4f61e67f69b6b458a75cac09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the penalty associated with a collision on an occlusion mesh. <br /></td></tr>
<tr class="separator:a5988962a4f61e67f69b6b458a75cac09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c09b14b1c369d4c500294de62fbe93b" id="r_a4c09b14b1c369d4c500294de62fbe93b"><td class="memItemLeft" align="right" valign="top"><a id="a4c09b14b1c369d4c500294de62fbe93b" name="a4c09b14b1c369d4c500294de62fbe93b"></a>
VdwCombiningRule&#160;</td><td class="memItemRight" valign="bottom"><b>getCombiningRule</b> () const</td></tr>
<tr class="memdesc:a4c09b14b1c369d4c500294de62fbe93b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the mixing protocol used for van-der Waals (as expressed by the Lennard-Jones model) interactions. <br /></td></tr>
<tr class="separator:a4c09b14b1c369d4c500294de62fbe93b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e621ff64a772316cd08569743b9ee9" id="r_ae5e621ff64a772316cd08569743b9ee9"><td class="memItemLeft" align="right" valign="top"><a id="ae5e621ff64a772316cd08569743b9ee9" name="ae5e621ff64a772316cd08569743b9ee9"></a>
PrecisionModel&#160;</td><td class="memItemRight" valign="bottom"><b>getBuildPrecision</b> () const</td></tr>
<tr class="memdesc:ae5e621ff64a772316cd08569743b9ee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the precisionmodel under which the mesh was calculated. <br /></td></tr>
<tr class="separator:ae5e621ff64a772316cd08569743b9ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a904bba953efc5ecd64d0ec48ce1348f1" id="r_a904bba953efc5ecd64d0ec48ce1348f1"><td class="memItemLeft" align="right" valign="top"><a id="a904bba953efc5ecd64d0ec48ce1348f1" name="a904bba953efc5ecd64d0ec48ce1348f1"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getCoefficientScalingFactor</b> () const</td></tr>
<tr class="memdesc:a904bba953efc5ecd64d0ec48ce1348f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the scaling factor for mesh coefficients in fixed-precision representations. <br /></td></tr>
<tr class="separator:a904bba953efc5ecd64d0ec48ce1348f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7072e95459bc28d58fc5815604018ded" id="r_a7072e95459bc28d58fc5815604018ded"><td class="memItemLeft" align="right" valign="top"><a id="a7072e95459bc28d58fc5815604018ded" name="a7072e95459bc28d58fc5815604018ded"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getCoefficientScalingBits</b> () const</td></tr>
<tr class="memdesc:a7072e95459bc28d58fc5815604018ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of bits after the decimal in fixed-precision mesh coefficient representations. <br /></td></tr>
<tr class="separator:a7072e95459bc28d58fc5815604018ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a316b843cc9507f2a0ccfe38a4b8183b8" id="r_a316b843cc9507f2a0ccfe38a4b8183b8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structstormm_1_1structure_1_1MeshFFKit.html">MeshFFKit</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a316b843cc9507f2a0ccfe38a4b8183b8">getNonbondedKit</a> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:a316b843cc9507f2a0ccfe38a4b8183b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the abstract of the mesh in the precision of the mesh's coefficient data.  <br /></td></tr>
<tr class="separator:a316b843cc9507f2a0ccfe38a4b8183b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17287df3decb5feea344bda8f91675c1" id="r_a17287df3decb5feea344bda8f91675c1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structstormm_1_1structure_1_1MeshFFKit.html">MeshFFKit</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17287df3decb5feea344bda8f91675c1">getReferenceNonbondedKit</a> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:a17287df3decb5feea344bda8f91675c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the abstract of the mesh in double precision.  <br /></td></tr>
<tr class="separator:a17287df3decb5feea344bda8f91675c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6719d42c2ed595b29802fb47b10ca337" id="r_a6719d42c2ed595b29802fb47b10ca337"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structstormm_1_1structure_1_1MeshFFKit.html">MeshFFKit</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6719d42c2ed595b29802fb47b10ca337">templateFreeNonbondedKit</a> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:a6719d42c2ed595b29802fb47b10ca337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a template-free form of the of the mesh nonbonded abstract in the mesh coefficient data type, useful for passing between the C++- and HPC-compiled code objects.  <br /></td></tr>
<tr class="separator:a6719d42c2ed595b29802fb47b10ca337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c8200dcbf648cb59a60134010bff62e" id="r_a0c8200dcbf648cb59a60134010bff62e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c8200dcbf648cb59a60134010bff62e">setProbeRadius</a> (double probe_radius_in)</td></tr>
<tr class="memdesc:a0c8200dcbf648cb59a60134010bff62e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the probe radius, meaning either the Lennard-Jones potential sigma radius or the clash probe radius, depending on the mesh type. This includes a validity check.  <br /></td></tr>
<tr class="separator:a0c8200dcbf648cb59a60134010bff62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a566346378f27221d3b44d3b9cf7e9992" id="r_a566346378f27221d3b44d3b9cf7e9992"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a566346378f27221d3b44d3b9cf7e9992">setWellDepth</a> (double well_depth_in)</td></tr>
<tr class="memdesc:a566346378f27221d3b44d3b9cf7e9992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Lennard-Jones well depth for the probe that will generate the potential. This includes a validity check.  <br /></td></tr>
<tr class="separator:a566346378f27221d3b44d3b9cf7e9992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94b3b378a99d1e72a2097d5cb32512d7" id="r_a94b3b378a99d1e72a2097d5cb32512d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94b3b378a99d1e72a2097d5cb32512d7">setOcclusionPenalty</a> (double occlusion_penalty_in)</td></tr>
<tr class="memdesc:a94b3b378a99d1e72a2097d5cb32512d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the penalty associated with striking occupied volume on an occlusion mesh. This is intended to be modified afeter making the mesh, if at all, as the actual value has no bearing on the way the bitmask is constructed.  <br /></td></tr>
<tr class="separator:a94b3b378a99d1e72a2097d5cb32512d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3907b58619238344e29f928a6947035" id="r_af3907b58619238344e29f928a6947035"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3907b58619238344e29f928a6947035">validateCombiningRule</a> (VdwCombiningRule mixing_protocol_in, const std::vector&lt; double &gt; &amp;probe_sigma, const std::vector&lt; double &gt; &amp;probe_epsilon)</td></tr>
<tr class="memdesc:af3907b58619238344e29f928a6947035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the combining rule that will be used to make the probe interact with the receptor on any mesh (with the exception of an electrostatic field). With geometric combining rules, it is possible to tailor a single mesh for all particles that might interact with the receptor. However, with Lorentz-Berthelot rules or any case of non-conformant pair rules, new grids are required for a rigorous description of each particle type that might interact with the mesh potential.  <br /></td></tr>
<tr class="separator:af3907b58619238344e29f928a6947035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b9c6dd9553ea200da5cd54c36ba1783" id="r_a0b9c6dd9553ea200da5cd54c36ba1783"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b9c6dd9553ea200da5cd54c36ba1783">setCoefficientScalingBits</a> (int scaling_bits_in)</td></tr>
<tr class="memdesc:a0b9c6dd9553ea200da5cd54c36ba1783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of bits after the decimal to be used in fixed-precision representations of coordinates.  <br /></td></tr>
<tr class="separator:a0b9c6dd9553ea200da5cd54c36ba1783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade932608af4658b623e2c216e6da6d91" id="r_ade932608af4658b623e2c216e6da6d91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade932608af4658b623e2c216e6da6d91">computeField</a> (const <a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a> &amp;launcher=<a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a>(), PrecisionModel prec=PrecisionModel::SINGLE, HybridTargetLevel availability=HybridTargetLevel::HOST, const std::vector&lt; double &gt; &amp;probe_sigma={}, const std::vector&lt; double &gt; &amp;probe_epsilon={})</td></tr>
<tr class="memdesc:ade932608af4658b623e2c216e6da6d91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the appropriate field for the mesh. This is called automatically by the constructor if enough information is provided.  <br /></td></tr>
<tr class="separator:ade932608af4658b623e2c216e6da6d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a59a501876097ed7fe14015bb63de34af" id="r_a59a501876097ed7fe14015bb63de34af"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59a501876097ed7fe14015bb63de34af">BackgroundMesh</a> (GridDetail kind_in, NonbondedPotential field_in, const <a class="el" href="classstormm_1_1structure_1_1MeshParameters.html">MeshParameters</a> &amp;measurements_in=<a class="el" href="classstormm_1_1structure_1_1MeshParameters.html">MeshParameters</a>(), const PrecisionModel build_precision_in=PrecisionModel::SINGLE)</td></tr>
<tr class="memdesc:a59a501876097ed7fe14015bb63de34af"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructor takes all dimension parameters plus an indication of what type of potential, the molecular system, and what mask of atoms is to be mapped. Variants include different ways to define the limits of the mesh. If a GPU is available, it will be used to compute the mesh.  <br /></td></tr>
<tr class="separator:a59a501876097ed7fe14015bb63de34af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9bfc082fa060e75508b6f3d8f3496eb" id="r_ac9bfc082fa060e75508b6f3d8f3496eb"><td class="memItemLeft" align="right" valign="top"><a id="ac9bfc082fa060e75508b6f3d8f3496eb" name="ac9bfc082fa060e75508b6f3d8f3496eb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BackgroundMesh</b> (GridDetail kind_in, NonbondedPotential field_in, const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> *ag_in, const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> *cf_in, double probe_radius_in, double well_depth_in, VdwCombiningRule mixing_protocol_in, const <a class="el" href="classstormm_1_1structure_1_1MeshParameters.html">MeshParameters</a> &amp;measurements_in=<a class="el" href="classstormm_1_1structure_1_1MeshParameters.html">MeshParameters</a>(), const std::vector&lt; double &gt; &amp;probe_sigma={}, const std::vector&lt; double &gt; &amp;probe_epsilon={}, double clash_distance_in=default_mesh_elec_damping_range, double clash_ratio_in=default_mesh_vdw_damping_ratio, PrecisionModel prec=PrecisionModel::SINGLE, const <a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a> &amp;launcher=<a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a>(), HybridTargetLevel availability=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:ac9bfc082fa060e75508b6f3d8f3496eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92cccaeed46c6ff531d2d309e2c9b089" id="r_a92cccaeed46c6ff531d2d309e2c9b089"><td class="memItemLeft" align="right" valign="top"><a id="a92cccaeed46c6ff531d2d309e2c9b089" name="a92cccaeed46c6ff531d2d309e2c9b089"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BackgroundMesh</b> (GridDetail kind_in, NonbondedPotential field_in, const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;ag_in, const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> &amp;cf_in, double probe_radius_in, double well_depth_in, VdwCombiningRule mixing_protocol_in, const <a class="el" href="classstormm_1_1structure_1_1MeshParameters.html">MeshParameters</a> &amp;measurements_in=<a class="el" href="classstormm_1_1structure_1_1MeshParameters.html">MeshParameters</a>(), const std::vector&lt; double &gt; &amp;probe_sigma={}, const std::vector&lt; double &gt; &amp;probe_epsilon={}, double clash_distance_in=default_mesh_elec_damping_range, double clash_ratio_in=default_mesh_vdw_damping_ratio, PrecisionModel prec=PrecisionModel::SINGLE, const <a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a> &amp;launcher=<a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a>(), HybridTargetLevel availability=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:a92cccaeed46c6ff531d2d309e2c9b089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d9871dc776c7f041428e61b7640839" id="r_a75d9871dc776c7f041428e61b7640839"><td class="memItemLeft" align="right" valign="top"><a id="a75d9871dc776c7f041428e61b7640839" name="a75d9871dc776c7f041428e61b7640839"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BackgroundMesh</b> (GridDetail kind_in, NonbondedPotential field_in, double probe_radius_in, double well_depth_in, VdwCombiningRule mixing_protocol_in, const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> *ag_in, const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> *cf_in, double buffer, double spacing, int scale_bits_in=default_globalpos_scale_bits, const std::vector&lt; double &gt; &amp;probe_sigma={}, const std::vector&lt; double &gt; &amp;probe_epsilon={}, double clash_distance_in=default_mesh_elec_damping_range, double clash_ratio_in=default_mesh_vdw_damping_ratio, PrecisionModel prec=PrecisionModel::SINGLE, const <a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a> &amp;launcher=<a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a>(), HybridTargetLevel availability=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:a75d9871dc776c7f041428e61b7640839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e33414c0e6197c35bddcc034b3c1fe4" id="r_a3e33414c0e6197c35bddcc034b3c1fe4"><td class="memItemLeft" align="right" valign="top"><a id="a3e33414c0e6197c35bddcc034b3c1fe4" name="a3e33414c0e6197c35bddcc034b3c1fe4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BackgroundMesh</b> (GridDetail kind_in, NonbondedPotential field_in, double probe_radius_in, double well_depth_in, VdwCombiningRule mixing_protocol_in, const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;ag_in, const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> &amp;cf_in, double buffer, double spacing, int scale_bits_in=default_globalpos_scale_bits, const std::vector&lt; double &gt; &amp;probe_sigma={}, const std::vector&lt; double &gt; &amp;probe_epsilon={}, double clash_distance_in=default_mesh_elec_damping_range, double clash_ratio_in=default_mesh_vdw_damping_ratio, PrecisionModel prec=PrecisionModel::SINGLE, const <a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a> &amp;launcher=<a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a>(), HybridTargetLevel availability=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:a3e33414c0e6197c35bddcc034b3c1fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2324f35551ab32a9fcc1664f66dc435a" id="r_a2324f35551ab32a9fcc1664f66dc435a"><td class="memItemLeft" align="right" valign="top"><a id="a2324f35551ab32a9fcc1664f66dc435a" name="a2324f35551ab32a9fcc1664f66dc435a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BackgroundMesh</b> (GridDetail kind_in, NonbondedPotential field_in, double probe_radius_in, double well_depth_in, VdwCombiningRule mixing_protocol_in, const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> *ag_in, const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> *cf_in, double buffer, const std::vector&lt; double &gt; &amp;spacing, int scale_bits_in=default_globalpos_scale_bits, const std::vector&lt; double &gt; &amp;probe_sigma={}, const std::vector&lt; double &gt; &amp;probe_epsilon={}, double clash_distance_in=default_mesh_elec_damping_range, double clash_ratio_in=default_mesh_vdw_damping_ratio, PrecisionModel prec=PrecisionModel::SINGLE, const <a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a> &amp;launcher=<a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a>(), HybridTargetLevel availability=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:a2324f35551ab32a9fcc1664f66dc435a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d716b3ab32ce58df7a54b675860914" id="r_a34d716b3ab32ce58df7a54b675860914"><td class="memItemLeft" align="right" valign="top"><a id="a34d716b3ab32ce58df7a54b675860914" name="a34d716b3ab32ce58df7a54b675860914"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BackgroundMesh</b> (GridDetail kind_in, NonbondedPotential field_in, double probe_radius_in, double well_depth_in, VdwCombiningRule mixing_protocol_in, const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;ag_in, const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> &amp;cf_in, double buffer, const std::vector&lt; double &gt; &amp;spacing, int scale_bits_in=default_globalpos_scale_bits, const std::vector&lt; double &gt; &amp;probe_sigma={}, const std::vector&lt; double &gt; &amp;probe_epsilon={}, double clash_distance_in=default_mesh_elec_damping_range, double clash_ratio_in=default_mesh_vdw_damping_ratio, PrecisionModel prec=PrecisionModel::SINGLE, const <a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a> &amp;launcher=<a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a>(), HybridTargetLevel availability=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:a34d716b3ab32ce58df7a54b675860914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a390a508eaf607c220aaec5d325dea315" id="r_a390a508eaf607c220aaec5d325dea315"><td class="memItemLeft" align="right" valign="top"><a id="a390a508eaf607c220aaec5d325dea315" name="a390a508eaf607c220aaec5d325dea315"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BackgroundMesh</b> (GridDetail kind_in, NonbondedPotential field_in, double probe_radius_in, double well_depth_in, VdwCombiningRule mixing_protocol_in, const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> *ag_in, const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> *cf_in, const std::vector&lt; double &gt; &amp;mesh_bounds, double spacing, int scale_bits_in=default_globalpos_scale_bits, const std::vector&lt; double &gt; &amp;probe_sigma={}, const std::vector&lt; double &gt; &amp;probe_epsilon={}, double clash_distance_in=default_mesh_elec_damping_range, double clash_ratio_in=default_mesh_vdw_damping_ratio, PrecisionModel prec=PrecisionModel::SINGLE, const <a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a> &amp;launcher=<a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a>(), HybridTargetLevel availability=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:a390a508eaf607c220aaec5d325dea315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e59f0ee60c8196fa314c240e02295bd" id="r_a8e59f0ee60c8196fa314c240e02295bd"><td class="memItemLeft" align="right" valign="top"><a id="a8e59f0ee60c8196fa314c240e02295bd" name="a8e59f0ee60c8196fa314c240e02295bd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BackgroundMesh</b> (GridDetail kind_in, NonbondedPotential field_in, double probe_radius_in, double well_depth_in, VdwCombiningRule mixing_protocol_in, const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;ag_in, const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> &amp;cf_in, const std::vector&lt; double &gt; &amp;mesh_bounds, double spacing, int scale_bits_in=default_globalpos_scale_bits, const std::vector&lt; double &gt; &amp;probe_sigma={}, const std::vector&lt; double &gt; &amp;probe_epsilon={}, double clash_distance_in=default_mesh_elec_damping_range, double clash_ratio_in=default_mesh_vdw_damping_ratio, PrecisionModel prec=PrecisionModel::SINGLE, const <a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a> &amp;launcher=<a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a>(), HybridTargetLevel availability=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:a8e59f0ee60c8196fa314c240e02295bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b4c0618158bfe0b62de128460cf430a" id="r_a4b4c0618158bfe0b62de128460cf430a"><td class="memItemLeft" align="right" valign="top"><a id="a4b4c0618158bfe0b62de128460cf430a" name="a4b4c0618158bfe0b62de128460cf430a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BackgroundMesh</b> (GridDetail kind_in, NonbondedPotential field_in, double probe_radius_in, double well_depth_in, VdwCombiningRule mixing_protocol_in, const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> *ag_in, const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> *cf_in, const std::vector&lt; double &gt; &amp;mesh_bounds, const std::vector&lt; double &gt; &amp;spacing, int scale_bits_in=default_globalpos_scale_bits, const std::vector&lt; double &gt; &amp;probe_sigma={}, const std::vector&lt; double &gt; &amp;probe_epsilon={}, double clash_distance_in=default_mesh_elec_damping_range, double clash_ratio_in=default_mesh_vdw_damping_ratio, PrecisionModel prec=PrecisionModel::SINGLE, const <a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a> &amp;launcher=<a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a>(), HybridTargetLevel availability=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:a4b4c0618158bfe0b62de128460cf430a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726a086ee867e5f5ed933682035851db" id="r_a726a086ee867e5f5ed933682035851db"><td class="memItemLeft" align="right" valign="top"><a id="a726a086ee867e5f5ed933682035851db" name="a726a086ee867e5f5ed933682035851db"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BackgroundMesh</b> (GridDetail kind_in, NonbondedPotential field_in, double probe_radius_in, double well_depth_in, VdwCombiningRule mixing_protocol_in, const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;ag_in, const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> &amp;cf_in, const std::vector&lt; double &gt; &amp;mesh_bounds, const std::vector&lt; double &gt; &amp;spacing, int scale_bits_in=default_globalpos_scale_bits, const std::vector&lt; double &gt; &amp;probe_sigma={}, const std::vector&lt; double &gt; &amp;probe_epsilon={}, double clash_distance_in=default_mesh_elec_damping_range, double clash_ratio_in=default_mesh_vdw_damping_ratio, PrecisionModel prec=PrecisionModel::SINGLE, const <a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a> &amp;launcher=<a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a>(), HybridTargetLevel availability=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:a726a086ee867e5f5ed933682035851db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21c07f4bcaa1ce2dcc4e2e48842b0c5" id="r_ae21c07f4bcaa1ce2dcc4e2e48842b0c5"><td class="memItemLeft" align="right" valign="top"><a id="ae21c07f4bcaa1ce2dcc4e2e48842b0c5" name="ae21c07f4bcaa1ce2dcc4e2e48842b0c5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BackgroundMesh</b> (GridDetail kind_in, NonbondedPotential field_in, const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> *ag_in, const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> *cf_in, double buffer, double spacing, int scale_bits_in=default_globalpos_scale_bits, double clash_distance_in=default_mesh_elec_damping_range, PrecisionModel prec=PrecisionModel::SINGLE, const <a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a> &amp;launcher=<a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a>(), HybridTargetLevel availability=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:ae21c07f4bcaa1ce2dcc4e2e48842b0c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab127318a72ed4af379442411cf96ad8a" id="r_ab127318a72ed4af379442411cf96ad8a"><td class="memItemLeft" align="right" valign="top"><a id="ab127318a72ed4af379442411cf96ad8a" name="ab127318a72ed4af379442411cf96ad8a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BackgroundMesh</b> (GridDetail kind_in, NonbondedPotential field_in, const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;ag_in, const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> &amp;cf_in, double buffer, double spacing, int scale_bits_in=default_globalpos_scale_bits, double clash_distance_in=default_mesh_elec_damping_range, PrecisionModel prec=PrecisionModel::SINGLE, const <a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a> &amp;launcher=<a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a>(), HybridTargetLevel availability=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:ab127318a72ed4af379442411cf96ad8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67ecbe358b1e55ade4ef794f6981e73" id="r_ad67ecbe358b1e55ade4ef794f6981e73"><td class="memItemLeft" align="right" valign="top"><a id="ad67ecbe358b1e55ade4ef794f6981e73" name="ad67ecbe358b1e55ade4ef794f6981e73"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BackgroundMesh</b> (GridDetail kind_in, NonbondedPotential field_in, const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> *ag_in, const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> *cf_in, double buffer, const std::vector&lt; double &gt; &amp;spacing, int scale_bits_in=default_globalpos_scale_bits, double clash_distance_in=default_mesh_elec_damping_range, PrecisionModel prec=PrecisionModel::SINGLE, const <a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a> &amp;launcher=<a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a>(), HybridTargetLevel availability=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:ad67ecbe358b1e55ade4ef794f6981e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc2b64337ace4a9da221bf42ada04d5" id="r_abcc2b64337ace4a9da221bf42ada04d5"><td class="memItemLeft" align="right" valign="top"><a id="abcc2b64337ace4a9da221bf42ada04d5" name="abcc2b64337ace4a9da221bf42ada04d5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BackgroundMesh</b> (GridDetail kind_in, NonbondedPotential field_in, const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;ag_in, const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> &amp;cf_in, double buffer, const std::vector&lt; double &gt; &amp;spacing, int scale_bits_in=default_globalpos_scale_bits, double clash_distance_in=default_mesh_elec_damping_range, PrecisionModel prec=PrecisionModel::SINGLE, const <a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a> &amp;launcher=<a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a>(), HybridTargetLevel availability=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:abcc2b64337ace4a9da221bf42ada04d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b162f5daa8ad217739b78f7357479b2" id="r_a7b162f5daa8ad217739b78f7357479b2"><td class="memItemLeft" align="right" valign="top"><a id="a7b162f5daa8ad217739b78f7357479b2" name="a7b162f5daa8ad217739b78f7357479b2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BackgroundMesh</b> (GridDetail kind_in, NonbondedPotential field_in, const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> *ag_in, const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> *cf_in, const std::vector&lt; double &gt; &amp;mesh_bounds, double spacing, int scale_bits_in=default_globalpos_scale_bits, double clash_distance_in=default_mesh_elec_damping_range, PrecisionModel prec=PrecisionModel::SINGLE, const <a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a> &amp;launcher=<a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a>(), HybridTargetLevel availability=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:a7b162f5daa8ad217739b78f7357479b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5807f542160408cb494b7054954e01a3" id="r_a5807f542160408cb494b7054954e01a3"><td class="memItemLeft" align="right" valign="top"><a id="a5807f542160408cb494b7054954e01a3" name="a5807f542160408cb494b7054954e01a3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BackgroundMesh</b> (GridDetail kind_in, NonbondedPotential field_in, const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;ag_in, const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> &amp;cf_in, const std::vector&lt; double &gt; &amp;mesh_bounds, double spacing, int scale_bits_in=default_globalpos_scale_bits, double clash_distance_in=default_mesh_elec_damping_range, PrecisionModel prec=PrecisionModel::SINGLE, const <a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a> &amp;launcher=<a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a>(), HybridTargetLevel availability=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:a5807f542160408cb494b7054954e01a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9253b48c1e3cd8c993e2d52c966cecf" id="r_af9253b48c1e3cd8c993e2d52c966cecf"><td class="memItemLeft" align="right" valign="top"><a id="af9253b48c1e3cd8c993e2d52c966cecf" name="af9253b48c1e3cd8c993e2d52c966cecf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BackgroundMesh</b> (GridDetail kind_in, NonbondedPotential field_in, const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> *ag_in, const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> *cf_in, const std::vector&lt; double &gt; &amp;mesh_bounds, const std::vector&lt; double &gt; &amp;spacing, int scale_bits_in=default_globalpos_scale_bits, double clash_distance_in=default_mesh_elec_damping_range, PrecisionModel prec=PrecisionModel::SINGLE, const <a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a> &amp;launcher=<a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a>(), HybridTargetLevel availability=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:af9253b48c1e3cd8c993e2d52c966cecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac666ebd072fa7dd0cb463cd1035ca8" id="r_adac666ebd072fa7dd0cb463cd1035ca8"><td class="memItemLeft" align="right" valign="top"><a id="adac666ebd072fa7dd0cb463cd1035ca8" name="adac666ebd072fa7dd0cb463cd1035ca8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BackgroundMesh</b> (GridDetail kind_in, NonbondedPotential field_in, const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;ag_in, const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> &amp;cf_in, const std::vector&lt; double &gt; &amp;mesh_bounds, const std::vector&lt; double &gt; &amp;spacing, int scale_bits_in=default_globalpos_scale_bits, double clash_distance_in=default_mesh_elec_damping_range, PrecisionModel prec=PrecisionModel::SINGLE, const <a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a> &amp;launcher=<a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a>(), HybridTargetLevel availability=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:adac666ebd072fa7dd0cb463cd1035ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3450f901b6b63a72f124111403574c9d" id="r_a3450f901b6b63a72f124111403574c9d"><td class="memItemLeft" align="right" valign="top"><a id="a3450f901b6b63a72f124111403574c9d" name="a3450f901b6b63a72f124111403574c9d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BackgroundMesh</b> (GridDetail kind_in, double probe_radius_in, VdwCombiningRule mixing_protocol_in, const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> *ag_in, const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> *cf_in, double buffer, double spacing, int scale_bits_in=default_globalpos_scale_bits, const std::vector&lt; double &gt; &amp;probe_sigma={}, PrecisionModel prec=PrecisionModel::SINGLE, const <a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a> &amp;launcher=<a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a>(), HybridTargetLevel availability=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:a3450f901b6b63a72f124111403574c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af137c795293078761d524e89f9fad9f1" id="r_af137c795293078761d524e89f9fad9f1"><td class="memItemLeft" align="right" valign="top"><a id="af137c795293078761d524e89f9fad9f1" name="af137c795293078761d524e89f9fad9f1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BackgroundMesh</b> (GridDetail kind_in, double probe_radius_in, VdwCombiningRule mixing_protocol_in, const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;ag_in, const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> &amp;cf_in, double buffer, double spacing, int scale_bits_in=default_globalpos_scale_bits, const std::vector&lt; double &gt; &amp;probe_sigma={}, PrecisionModel prec=PrecisionModel::SINGLE, const <a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a> &amp;launcher=<a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a>(), HybridTargetLevel availability=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:af137c795293078761d524e89f9fad9f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19ce04d60ee1dbf789b96fbbb60d2d2f" id="r_a19ce04d60ee1dbf789b96fbbb60d2d2f"><td class="memItemLeft" align="right" valign="top"><a id="a19ce04d60ee1dbf789b96fbbb60d2d2f" name="a19ce04d60ee1dbf789b96fbbb60d2d2f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BackgroundMesh</b> (GridDetail kind_in, double probe_radius_in, VdwCombiningRule mixing_protocol_in, const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> *ag_in, const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> *cf_in, double buffer, const std::vector&lt; double &gt; &amp;spacing, int scale_bits_in=default_globalpos_scale_bits, const std::vector&lt; double &gt; &amp;probe_sigma={}, PrecisionModel prec=PrecisionModel::SINGLE, const <a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a> &amp;launcher=<a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a>(), HybridTargetLevel availability=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:a19ce04d60ee1dbf789b96fbbb60d2d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dafd04b26363103d0a157eb1556d89d" id="r_a9dafd04b26363103d0a157eb1556d89d"><td class="memItemLeft" align="right" valign="top"><a id="a9dafd04b26363103d0a157eb1556d89d" name="a9dafd04b26363103d0a157eb1556d89d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BackgroundMesh</b> (GridDetail kind_in, double probe_radius_in, VdwCombiningRule mixing_protocol_in, const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;ag_in, const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> &amp;cf_in, double buffer, const std::vector&lt; double &gt; &amp;spacing, int scale_bits_in=default_globalpos_scale_bits, const std::vector&lt; double &gt; &amp;probe_sigma={}, PrecisionModel prec=PrecisionModel::SINGLE, const <a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a> &amp;launcher=<a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a>(), HybridTargetLevel availability=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:a9dafd04b26363103d0a157eb1556d89d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad75897a012fa0c0f290c8e8dc0d9ccff" id="r_ad75897a012fa0c0f290c8e8dc0d9ccff"><td class="memItemLeft" align="right" valign="top"><a id="ad75897a012fa0c0f290c8e8dc0d9ccff" name="ad75897a012fa0c0f290c8e8dc0d9ccff"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BackgroundMesh</b> (GridDetail kind_in, double probe_radius_in, VdwCombiningRule mixing_protocol_in, const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> *ag_in, const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> *cf_in, const std::vector&lt; double &gt; &amp;mesh_bounds, double spacing, int scale_bits_in=default_globalpos_scale_bits, const std::vector&lt; double &gt; &amp;probe_sigma={}, PrecisionModel prec=PrecisionModel::SINGLE, const <a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a> &amp;launcher=<a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a>(), HybridTargetLevel availability=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:ad75897a012fa0c0f290c8e8dc0d9ccff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da59051ce9b5450a8e80797fa5db078" id="r_a8da59051ce9b5450a8e80797fa5db078"><td class="memItemLeft" align="right" valign="top"><a id="a8da59051ce9b5450a8e80797fa5db078" name="a8da59051ce9b5450a8e80797fa5db078"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BackgroundMesh</b> (GridDetail kind_in, double probe_radius_in, VdwCombiningRule mixing_protocol_in, const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;ag_in, const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> &amp;cf_in, const std::vector&lt; double &gt; &amp;mesh_bounds, double spacing, int scale_bits_in=default_globalpos_scale_bits, const std::vector&lt; double &gt; &amp;probe_sigma={}, PrecisionModel prec=PrecisionModel::SINGLE, const <a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a> &amp;launcher=<a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a>(), HybridTargetLevel availability=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:a8da59051ce9b5450a8e80797fa5db078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af500c24f48c03a09e315d3626771d281" id="r_af500c24f48c03a09e315d3626771d281"><td class="memItemLeft" align="right" valign="top"><a id="af500c24f48c03a09e315d3626771d281" name="af500c24f48c03a09e315d3626771d281"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BackgroundMesh</b> (GridDetail kind_in, double probe_radius_in, VdwCombiningRule mixing_protocol_in, const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> *ag_in, const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> *cf_in, const std::vector&lt; double &gt; &amp;mesh_bounds, const std::vector&lt; double &gt; &amp;spacing, int scale_bits_in=default_globalpos_scale_bits, const std::vector&lt; double &gt; &amp;probe_sigma={}, PrecisionModel prec=PrecisionModel::SINGLE, const <a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a> &amp;launcher=<a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a>(), HybridTargetLevel availability=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:af500c24f48c03a09e315d3626771d281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bc40247dbada0305dadff1f7d78c67e" id="r_a7bc40247dbada0305dadff1f7d78c67e"><td class="memItemLeft" align="right" valign="top"><a id="a7bc40247dbada0305dadff1f7d78c67e" name="a7bc40247dbada0305dadff1f7d78c67e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BackgroundMesh</b> (GridDetail kind_in, double probe_radius_in, VdwCombiningRule mixing_protocol_in, const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;ag_in, const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> &amp;cf_in, const std::vector&lt; double &gt; &amp;mesh_bounds, const std::vector&lt; double &gt; &amp;spacing, int scale_bits_in=default_globalpos_scale_bits, const std::vector&lt; double &gt; &amp;probe_sigma={}, PrecisionModel prec=PrecisionModel::SINGLE, const <a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a> &amp;launcher=<a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a>(), HybridTargetLevel availability=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:a7bc40247dbada0305dadff1f7d78c67e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ee1479e4a8aedb491c5658e14fb1ed" id="r_a59ee1479e4a8aedb491c5658e14fb1ed"><td class="memTemplParams" colspan="2"><a id="a59ee1479e4a8aedb491c5658e14fb1ed" name="a59ee1479e4a8aedb491c5658e14fb1ed"></a>
template&lt;typename Tcoord&gt; </td></tr>
<tr class="memitem:a59ee1479e4a8aedb491c5658e14fb1ed"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>BackgroundMesh</b> (GridDetail kind_in, NonbondedPotential field_in, const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;ag_in, const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateSeries.html">CoordinateSeries</a>&lt; Tcoord &gt; &amp;cs_in, double probe_radius_in, double well_depth_in, VdwCombiningRule mixing_protocol_in, const <a class="el" href="classstormm_1_1structure_1_1MeshParameters.html">MeshParameters</a> &amp;measurements_in=<a class="el" href="classstormm_1_1structure_1_1MeshParameters.html">MeshParameters</a>(), int averaging_order=default_mesh_density_averaging_order, const std::vector&lt; double &gt; &amp;probe_sigma={}, const std::vector&lt; double &gt; &amp;probe_epsilon={}, double clash_distance_in=default_mesh_elec_damping_range, double clash_ratio_in=default_mesh_vdw_damping_ratio, PrecisionModel prec=PrecisionModel::SINGLE, const <a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a> &amp;launcher=<a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a>(), HybridTargetLevel availability=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:a59ee1479e4a8aedb491c5658e14fb1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c98ff945120b54f90d8c0eaf548ac94" id="r_a9c98ff945120b54f90d8c0eaf548ac94"><td class="memTemplParams" colspan="2"><a id="a9c98ff945120b54f90d8c0eaf548ac94" name="a9c98ff945120b54f90d8c0eaf548ac94"></a>
template&lt;typename Tcoord&gt; </td></tr>
<tr class="memitem:a9c98ff945120b54f90d8c0eaf548ac94"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>BackgroundMesh</b> (GridDetail kind_in, NonbondedPotential field_in, double probe_radius_in, double well_depth_in, VdwCombiningRule mixing_protocol_in, const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;ag_in, const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateSeries.html">CoordinateSeries</a>&lt; Tcoord &gt; &amp;cs_in, double buffer, double spacing, int scale_bits_in=default_globalpos_scale_bits, int averaging_order=default_mesh_density_averaging_order, const std::vector&lt; double &gt; &amp;probe_sigma={}, const std::vector&lt; double &gt; &amp;probe_epsilon={}, double clash_distance_in=default_mesh_elec_damping_range, double clash_ratio_in=default_mesh_vdw_damping_ratio, PrecisionModel prec=PrecisionModel::SINGLE, const <a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a> &amp;launcher=<a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a>(), HybridTargetLevel availability=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:a9c98ff945120b54f90d8c0eaf548ac94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a053f0be2c5a693d5bac18bc1e53f3672" id="r_a053f0be2c5a693d5bac18bc1e53f3672"><td class="memTemplParams" colspan="2"><a id="a053f0be2c5a693d5bac18bc1e53f3672" name="a053f0be2c5a693d5bac18bc1e53f3672"></a>
template&lt;typename Tcoord&gt; </td></tr>
<tr class="memitem:a053f0be2c5a693d5bac18bc1e53f3672"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>BackgroundMesh</b> (GridDetail kind_in, NonbondedPotential field_in, double probe_radius_in, double well_depth_in, VdwCombiningRule mixing_protocol_in, const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;ag_in, const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateSeries.html">CoordinateSeries</a>&lt; Tcoord &gt; &amp;cs_in, double buffer, const std::vector&lt; double &gt; &amp;spacing, int scale_bits_in=default_globalpos_scale_bits, int averaging_order=default_mesh_density_averaging_order, const std::vector&lt; double &gt; &amp;probe_sigma={}, const std::vector&lt; double &gt; &amp;probe_epsilon={}, double clash_distance_in=default_mesh_elec_damping_range, double clash_ratio_in=default_mesh_vdw_damping_ratio, PrecisionModel prec=PrecisionModel::SINGLE, const <a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a> &amp;launcher=<a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a>(), HybridTargetLevel availability=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:a053f0be2c5a693d5bac18bc1e53f3672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78223828f44050549472278e552cec49" id="r_a78223828f44050549472278e552cec49"><td class="memTemplParams" colspan="2"><a id="a78223828f44050549472278e552cec49" name="a78223828f44050549472278e552cec49"></a>
template&lt;typename Tcoord&gt; </td></tr>
<tr class="memitem:a78223828f44050549472278e552cec49"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>BackgroundMesh</b> (GridDetail kind_in, NonbondedPotential field_in, double probe_radius_in, double well_depth_in, VdwCombiningRule mixing_protocol_in, const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;ag_in, const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateSeries.html">CoordinateSeries</a>&lt; Tcoord &gt; &amp;cs_in, const std::vector&lt; double &gt; &amp;mesh_bounds, double spacing, int scale_bits_in=default_globalpos_scale_bits, int averaging_order=default_mesh_density_averaging_order, const std::vector&lt; double &gt; &amp;probe_sigma={}, const std::vector&lt; double &gt; &amp;probe_epsilon={}, double clash_distance_in=default_mesh_elec_damping_range, double clash_ratio_in=default_mesh_vdw_damping_ratio, PrecisionModel prec=PrecisionModel::SINGLE, const <a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a> &amp;launcher=<a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a>(), HybridTargetLevel availability=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:a78223828f44050549472278e552cec49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc8757539fe48489dbff585c12677694" id="r_acc8757539fe48489dbff585c12677694"><td class="memTemplParams" colspan="2"><a id="acc8757539fe48489dbff585c12677694" name="acc8757539fe48489dbff585c12677694"></a>
template&lt;typename Tcoord&gt; </td></tr>
<tr class="memitem:acc8757539fe48489dbff585c12677694"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>BackgroundMesh</b> (GridDetail kind_in, NonbondedPotential field_in, double probe_radius_in, double well_depth_in, VdwCombiningRule mixing_protocol_in, const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;ag_in, const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateSeries.html">CoordinateSeries</a>&lt; Tcoord &gt; &amp;cs_in, const std::vector&lt; double &gt; &amp;mesh_bounds, const std::vector&lt; double &gt; &amp;spacing, int scale_bits_in=default_globalpos_scale_bits, int averaging_order=default_mesh_density_averaging_order, const std::vector&lt; double &gt; &amp;probe_sigma={}, const std::vector&lt; double &gt; &amp;probe_epsilon={}, double clash_distance_in=default_mesh_elec_damping_range, double clash_ratio_in=default_mesh_vdw_damping_ratio, PrecisionModel prec=PrecisionModel::SINGLE, const <a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a> &amp;launcher=<a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a>(), HybridTargetLevel availability=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:acc8757539fe48489dbff585c12677694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14539eaf5a7c5d7425ecc3cc18c2a8ed" id="r_a14539eaf5a7c5d7425ecc3cc18c2a8ed"><td class="memTemplParams" colspan="2"><a id="a14539eaf5a7c5d7425ecc3cc18c2a8ed" name="a14539eaf5a7c5d7425ecc3cc18c2a8ed"></a>
template&lt;typename Tcoord&gt; </td></tr>
<tr class="memitem:a14539eaf5a7c5d7425ecc3cc18c2a8ed"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>BackgroundMesh</b> (GridDetail kind_in, NonbondedPotential field_in, const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;ag_in, const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateSeries.html">CoordinateSeries</a>&lt; Tcoord &gt; &amp;cs_in, double buffer, double spacing, int scale_bits_in=default_globalpos_scale_bits, double clash_distance_in=default_mesh_elec_damping_range, PrecisionModel prec=PrecisionModel::SINGLE, const <a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a> &amp;launcher=<a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a>(), HybridTargetLevel availability=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:a14539eaf5a7c5d7425ecc3cc18c2a8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceecb69a19a5cfeb99a4e1a113812ae2" id="r_aceecb69a19a5cfeb99a4e1a113812ae2"><td class="memTemplParams" colspan="2"><a id="aceecb69a19a5cfeb99a4e1a113812ae2" name="aceecb69a19a5cfeb99a4e1a113812ae2"></a>
template&lt;typename Tcoord&gt; </td></tr>
<tr class="memitem:aceecb69a19a5cfeb99a4e1a113812ae2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>BackgroundMesh</b> (GridDetail kind_in, NonbondedPotential field_in, const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;ag_in, const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateSeries.html">CoordinateSeries</a>&lt; Tcoord &gt; &amp;cs_in, double buffer, const std::vector&lt; double &gt; &amp;spacing, int scale_bits_in=default_globalpos_scale_bits, double clash_distance_in=default_mesh_elec_damping_range, PrecisionModel prec=PrecisionModel::SINGLE, const <a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a> &amp;launcher=<a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a>(), HybridTargetLevel availability=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:aceecb69a19a5cfeb99a4e1a113812ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a181e5b7e67b02b09545cd1d4828b03a6" id="r_a181e5b7e67b02b09545cd1d4828b03a6"><td class="memTemplParams" colspan="2"><a id="a181e5b7e67b02b09545cd1d4828b03a6" name="a181e5b7e67b02b09545cd1d4828b03a6"></a>
template&lt;typename Tcoord&gt; </td></tr>
<tr class="memitem:a181e5b7e67b02b09545cd1d4828b03a6"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>BackgroundMesh</b> (GridDetail kind_in, NonbondedPotential field_in, const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;ag_in, const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateSeries.html">CoordinateSeries</a>&lt; Tcoord &gt; &amp;cs_in, const std::vector&lt; double &gt; &amp;mesh_bounds, double spacing, int scale_bits_in=default_globalpos_scale_bits, double clash_distance_in=default_mesh_elec_damping_range, PrecisionModel prec=PrecisionModel::SINGLE, const <a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a> &amp;launcher=<a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a>(), HybridTargetLevel availability=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:a181e5b7e67b02b09545cd1d4828b03a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99275a51bddb16ab958d33022ad0ceb4" id="r_a99275a51bddb16ab958d33022ad0ceb4"><td class="memTemplParams" colspan="2"><a id="a99275a51bddb16ab958d33022ad0ceb4" name="a99275a51bddb16ab958d33022ad0ceb4"></a>
template&lt;typename Tcoord&gt; </td></tr>
<tr class="memitem:a99275a51bddb16ab958d33022ad0ceb4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>BackgroundMesh</b> (GridDetail kind_in, NonbondedPotential field_in, const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;ag_in, const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateSeries.html">CoordinateSeries</a>&lt; Tcoord &gt; &amp;cs_in, const std::vector&lt; double &gt; &amp;mesh_bounds, const std::vector&lt; double &gt; &amp;spacing, int scale_bits_in=default_globalpos_scale_bits, double clash_distance_in=default_mesh_elec_damping_range, PrecisionModel prec=PrecisionModel::SINGLE, const <a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a> &amp;launcher=<a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a>(), HybridTargetLevel availability=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:a99275a51bddb16ab958d33022ad0ceb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c2b20990e72fcd72e95d8aa7c81c34" id="r_af3c2b20990e72fcd72e95d8aa7c81c34"><td class="memTemplParams" colspan="2"><a id="af3c2b20990e72fcd72e95d8aa7c81c34" name="af3c2b20990e72fcd72e95d8aa7c81c34"></a>
template&lt;typename Tcoord&gt; </td></tr>
<tr class="memitem:af3c2b20990e72fcd72e95d8aa7c81c34"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>BackgroundMesh</b> (GridDetail kind_in, double probe_radius_in, const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;ag_in, const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateSeries.html">CoordinateSeries</a>&lt; Tcoord &gt; &amp;cs_in, double buffer, double spacing, int scale_bits_in=default_globalpos_scale_bits, int averaging_order=default_mesh_density_averaging_order, const std::vector&lt; double &gt; &amp;probe_sigma={}, PrecisionModel prec=PrecisionModel::SINGLE, const <a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a> &amp;launcher=<a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a>(), HybridTargetLevel availability=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:af3c2b20990e72fcd72e95d8aa7c81c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27c2b95d34f9580506d94233ab9883bb" id="r_a27c2b95d34f9580506d94233ab9883bb"><td class="memTemplParams" colspan="2"><a id="a27c2b95d34f9580506d94233ab9883bb" name="a27c2b95d34f9580506d94233ab9883bb"></a>
template&lt;typename Tcoord&gt; </td></tr>
<tr class="memitem:a27c2b95d34f9580506d94233ab9883bb"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>BackgroundMesh</b> (GridDetail kind_in, double probe_radius_in, const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;ag_in, const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateSeries.html">CoordinateSeries</a>&lt; Tcoord &gt; &amp;cs_in, double buffer, const std::vector&lt; double &gt; &amp;spacing, int scale_bits_in=default_globalpos_scale_bits, int averaging_order=default_mesh_density_averaging_order, const std::vector&lt; double &gt; &amp;probe_sigma={}, PrecisionModel prec=PrecisionModel::SINGLE, const <a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a> &amp;launcher=<a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a>(), HybridTargetLevel availability=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:a27c2b95d34f9580506d94233ab9883bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae03ad38a04beef81e1e10d97c3342018" id="r_ae03ad38a04beef81e1e10d97c3342018"><td class="memTemplParams" colspan="2"><a id="ae03ad38a04beef81e1e10d97c3342018" name="ae03ad38a04beef81e1e10d97c3342018"></a>
template&lt;typename Tcoord&gt; </td></tr>
<tr class="memitem:ae03ad38a04beef81e1e10d97c3342018"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>BackgroundMesh</b> (GridDetail kind_in, double probe_radius_in, const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;ag_in, const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateSeries.html">CoordinateSeries</a>&lt; Tcoord &gt; &amp;cs_in, const std::vector&lt; double &gt; &amp;mesh_bounds, double spacing, int scale_bits_in=default_globalpos_scale_bits, int averaging_order=default_mesh_density_averaging_order, const std::vector&lt; double &gt; &amp;probe_sigma={}, PrecisionModel prec=PrecisionModel::SINGLE, const <a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a> &amp;launcher=<a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a>(), HybridTargetLevel availability=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:ae03ad38a04beef81e1e10d97c3342018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa26b2d020db69b3aefcb2730ca4b55c2" id="r_aa26b2d020db69b3aefcb2730ca4b55c2"><td class="memTemplParams" colspan="2"><a id="aa26b2d020db69b3aefcb2730ca4b55c2" name="aa26b2d020db69b3aefcb2730ca4b55c2"></a>
template&lt;typename Tcoord&gt; </td></tr>
<tr class="memitem:aa26b2d020db69b3aefcb2730ca4b55c2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>BackgroundMesh</b> (GridDetail kind_in, double probe_radius_in, const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> &amp;ag_in, const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateSeries.html">CoordinateSeries</a>&lt; Tcoord &gt; &amp;cs_in, const std::vector&lt; double &gt; &amp;mesh_bounds, const std::vector&lt; double &gt; &amp;spacing, int scale_bits_in=default_globalpos_scale_bits, int averaging_order=default_mesh_density_averaging_order, const std::vector&lt; double &gt; &amp;probe_sigma={}, PrecisionModel prec=PrecisionModel::SINGLE, const <a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a> &amp;launcher=<a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a>(), HybridTargetLevel availability=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:aa26b2d020db69b3aefcb2730ca4b55c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac40116c754cab191702c5fbd41b3006b" id="r_ac40116c754cab191702c5fbd41b3006b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac40116c754cab191702c5fbd41b3006b">BackgroundMesh</a> (const <a class="el" href="classstormm_1_1structure_1_1BackgroundMesh.html">BackgroundMesh</a>&lt; T &gt; &amp;original)=default</td></tr>
<tr class="memdesc:ac40116c754cab191702c5fbd41b3006b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy and move constructors as well as assignment operators can be set to their defaults because the object is composed of others, which may contain POINTER-kind <a class="el" href="classstormm_1_1review_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> objects but have their own copy and move assignment operators.  <br /></td></tr>
<tr class="separator:ac40116c754cab191702c5fbd41b3006b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0929d606f72dd251dc565980f6de5c15" id="r_a0929d606f72dd251dc565980f6de5c15"><td class="memItemLeft" align="right" valign="top"><a id="a0929d606f72dd251dc565980f6de5c15" name="a0929d606f72dd251dc565980f6de5c15"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BackgroundMesh</b> (<a class="el" href="classstormm_1_1structure_1_1BackgroundMesh.html">BackgroundMesh</a>&lt; T &gt; &amp;&amp;original)=default</td></tr>
<tr class="separator:a0929d606f72dd251dc565980f6de5c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b77434f081bb3d1e945a26eb567eec6" id="r_a0b77434f081bb3d1e945a26eb567eec6"><td class="memItemLeft" align="right" valign="top"><a id="a0b77434f081bb3d1e945a26eb567eec6" name="a0b77434f081bb3d1e945a26eb567eec6"></a>
<a class="el" href="classstormm_1_1structure_1_1BackgroundMesh.html">BackgroundMesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classstormm_1_1structure_1_1BackgroundMesh.html">BackgroundMesh</a>&lt; T &gt; &amp;original)=default</td></tr>
<tr class="separator:a0b77434f081bb3d1e945a26eb567eec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dbdcbdea4caa9fc2e7e42f1fb93f2fc" id="r_a4dbdcbdea4caa9fc2e7e42f1fb93f2fc"><td class="memItemLeft" align="right" valign="top"><a id="a4dbdcbdea4caa9fc2e7e42f1fb93f2fc" name="a4dbdcbdea4caa9fc2e7e42f1fb93f2fc"></a>
<a class="el" href="classstormm_1_1structure_1_1BackgroundMesh.html">BackgroundMesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classstormm_1_1structure_1_1BackgroundMesh.html">BackgroundMesh</a>&lt; T &gt; &amp;&amp;original)=default</td></tr>
<tr class="separator:a4dbdcbdea4caa9fc2e7e42f1fb93f2fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:afb01619c9147aeb5ec4256fbe2bf4f63" id="r_afb01619c9147aeb5ec4256fbe2bf4f63"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classstormm_1_1structure_1_1MeshFoundation.html">MeshFoundation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb01619c9147aeb5ec4256fbe2bf4f63">getMolecularBasis</a> () const</td></tr>
<tr class="memdesc:afb01619c9147aeb5ec4256fbe2bf4f63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the collection of molecular details underlying the mesh, including the topology and associated coordinates, plus any neighbor list.  <br /></td></tr>
<tr class="separator:afb01619c9147aeb5ec4256fbe2bf4f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03acf5ca6f716f77b4610290f57d5ddc" id="r_a03acf5ca6f716f77b4610290f57d5ddc"><td class="memItemLeft" align="right" valign="top"><a id="a03acf5ca6f716f77b4610290f57d5ddc" name="a03acf5ca6f716f77b4610290f57d5ddc"></a>
<a class="el" href="classstormm_1_1structure_1_1MeshFoundation.html">MeshFoundation</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getMolecularBasis</b> ()</td></tr>
<tr class="separator:a03acf5ca6f716f77b4610290f57d5ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9979fe441e2cb7de8ba7af109e33c050" id="r_a9979fe441e2cb7de8ba7af109e33c050"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structstormm_1_1structure_1_1BackgroundMeshReader.html">BackgroundMeshReader</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9979fe441e2cb7de8ba7af109e33c050">data</a> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:a9979fe441e2cb7de8ba7af109e33c050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an abstract of the mesh.  <br /></td></tr>
<tr class="separator:a9979fe441e2cb7de8ba7af109e33c050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a664074c851fcf8e07767b51ad1e82461" id="r_a664074c851fcf8e07767b51ad1e82461"><td class="memItemLeft" align="right" valign="top"><a id="a664074c851fcf8e07767b51ad1e82461" name="a664074c851fcf8e07767b51ad1e82461"></a>
BackgroundMeshWriter&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> (HybridTargetLevel tier=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:a664074c851fcf8e07767b51ad1e82461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a09c3267cfd6f6005001deac057a2f27c" id="r_a09c3267cfd6f6005001deac057a2f27c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structstormm_1_1structure_1_1BackgroundMeshReader.html">BackgroundMeshReader</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09c3267cfd6f6005001deac057a2f27c">templateFreeData</a> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:a09c3267cfd6f6005001deac057a2f27c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an abstract of the mesh with any templating removed.  <br /></td></tr>
<tr class="separator:a09c3267cfd6f6005001deac057a2f27c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed76f7d8a46c65e9b9483f8c9dad1ac" id="r_aeed76f7d8a46c65e9b9483f8c9dad1ac"><td class="memItemLeft" align="right" valign="top"><a id="aeed76f7d8a46c65e9b9483f8c9dad1ac" name="aeed76f7d8a46c65e9b9483f8c9dad1ac"></a>
BackgroundMeshWriter&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>templateFreeData</b> (HybridTargetLevel tier=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:aeed76f7d8a46c65e9b9483f8c9dad1ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a62604bb049958755faeca1c395c27a32" id="r_a62604bb049958755faeca1c395c27a32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62604bb049958755faeca1c395c27a32">setMeshParameters</a> (const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> *ag_in, const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> *cf_in, double padding, double spacing, int scale_bits_in=-100)</td></tr>
<tr class="memdesc:a62604bb049958755faeca1c395c27a32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the dimensions of the mesh. Variants of this member function that do not include a coordinate pointer or topology may assume that one has already been set. Variants that do accept a coordinate pointer will set that as the mesh's coordinate set.  <br /></td></tr>
<tr class="separator:a62604bb049958755faeca1c395c27a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ecf0faff665037773f95906abce997" id="r_a78ecf0faff665037773f95906abce997"><td class="memItemLeft" align="right" valign="top"><a id="a78ecf0faff665037773f95906abce997" name="a78ecf0faff665037773f95906abce997"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setMeshParameters</b> (const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> *ag_in, const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> *cf_in, double padding, const std::vector&lt; double &gt; &amp;spacing, int scale_bits_in=-100)</td></tr>
<tr class="separator:a78ecf0faff665037773f95906abce997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1bf78ef43a7f46c77627e2f9ad7ad3" id="r_a2a1bf78ef43a7f46c77627e2f9ad7ad3"><td class="memItemLeft" align="right" valign="top"><a id="a2a1bf78ef43a7f46c77627e2f9ad7ad3" name="a2a1bf78ef43a7f46c77627e2f9ad7ad3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setMeshParameters</b> (double padding, double spacing, int scale_bits_in=-100)</td></tr>
<tr class="separator:a2a1bf78ef43a7f46c77627e2f9ad7ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6721360764000ec4ac887953626fd3e1" id="r_a6721360764000ec4ac887953626fd3e1"><td class="memItemLeft" align="right" valign="top"><a id="a6721360764000ec4ac887953626fd3e1" name="a6721360764000ec4ac887953626fd3e1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setMeshParameters</b> (double padding, const std::vector&lt; double &gt; &amp;spacing, int scale_bits_in=-100)</td></tr>
<tr class="separator:a6721360764000ec4ac887953626fd3e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd01414e39605e08911ce5927a58f74f" id="r_acd01414e39605e08911ce5927a58f74f"><td class="memItemLeft" align="right" valign="top"><a id="acd01414e39605e08911ce5927a58f74f" name="acd01414e39605e08911ce5927a58f74f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setMeshParameters</b> (const std::vector&lt; double &gt; &amp;mesh_bounds, double spacing, int scale_bits_in=-100)</td></tr>
<tr class="separator:acd01414e39605e08911ce5927a58f74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a255b66c10d0d9a4e9c43602f445f6569" id="r_a255b66c10d0d9a4e9c43602f445f6569"><td class="memItemLeft" align="right" valign="top"><a id="a255b66c10d0d9a4e9c43602f445f6569" name="a255b66c10d0d9a4e9c43602f445f6569"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setMeshParameters</b> (const std::vector&lt; double &gt; &amp;mesh_bounds, const std::vector&lt; double &gt; &amp;spacing, int scale_bits_in=-100)</td></tr>
<tr class="separator:a255b66c10d0d9a4e9c43602f445f6569"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T&gt;<br />
class stormm::review::BackgroundMesh&lt; T &gt;</div><p>A workspace for constructing a pure potential mesh based on the frozen atoms of a large molecule. If the large molecule has nonrigid components, they must be excluded from contributing to the grid. In addition, any atoms up to 1:4 (connected by three bonds or less) must also be excluded from the grid-based potential. Computations on these atoms will not be accurate off the grid, but since they are frozen the consequences are mitigated. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a59a501876097ed7fe14015bb63de34af" name="a59a501876097ed7fe14015bb63de34af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59a501876097ed7fe14015bb63de34af">&#9670;&#160;</a></span>BackgroundMesh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstormm_1_1structure_1_1BackgroundMesh.html">stormm::structure::BackgroundMesh</a>&lt; T &gt;::BackgroundMesh </td>
          <td>(</td>
          <td class="paramtype">GridDetail</td>          <td class="paramname"><span class="paramname"><em>kind_in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NonbondedPotential</td>          <td class="paramname"><span class="paramname"><em>field_in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstormm_1_1structure_1_1MeshParameters.html">MeshParameters</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>measurements_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classstormm_1_1structure_1_1MeshParameters.html">MeshParameters</a>()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PrecisionModel</td>          <td class="paramname"><span class="paramname"><em>build_precision_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">PrecisionModel::SINGLE</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The constructor takes all dimension parameters plus an indication of what type of potential, the molecular system, and what mask of atoms is to be mapped. Variants include different ways to define the limits of the mesh. If a GPU is available, it will be used to compute the mesh. </p>
<p>Overloaded:</p><ul>
<li>Various combinations of parameters specific to relevant mesh kinds</li>
<li>Templated constructors for including a coordinate series rather than a single structure in occlusion field and specific nonbonded field meshes</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ag</td><td>System topology (markings in its mobile_atoms array will be used to determine which atoms to map) </td></tr>
    <tr><td class="paramname">cf</td><td>Cartesian coordinates of all particles </td></tr>
    <tr><td class="paramname">buffer</td><td>Breadth around the molecule drawing an orthhombic region in which to map the mesh </td></tr>
    <tr><td class="paramname">mesh_bounds</td><td>Boundaries of the mesh, a six-element vector describing the lower and upper Cartesian X, Y, and Z limits of an orthorhombic region in which to define a rectilinear mesh. </td></tr>
    <tr><td class="paramname">spacing</td><td>Grid spacings for the mesh cells. Provide either a single number or three dimensions for the Cartesian X, Y, and Z widths of rectilinear elements. </td></tr>
    <tr><td class="paramname">measurements_in</td><td>A full description of the mesh parameters. This provides a means to define non-orthorhombic meshes. </td></tr>
    <tr><td class="paramname">clash_distance_in</td><td>The absolute distance at which electrostatic interactions will be deemed in conflict and a softcore potential will take over </td></tr>
    <tr><td class="paramname">clash_ratio_in</td><td>The ratio of the pairwise van-der Waals sigma parameter at which a van-der Waals interaction will be declared in conflict and the softcore potential form will take over </td></tr>
    <tr><td class="paramname">scale_bits</td><td>Number of bits after the decimal when taking coordinates in units of Angstroms into the fixed-precision format of the mesh framework </td></tr>
    <tr><td class="paramname">averaging_order</td><td>The width of the discrete point patch from an occlusion mesh measured for a single frame that will be averaged to compute a contribution to a continuous field density Angstroms into the fixed-precision format of the mesh framework </td></tr>
    <tr><td class="paramname">launcher</td><td>Manager for launching mesh-based kernels (dispenses launch grid parameters) </td></tr>
    <tr><td class="paramname">prec</td><td>Precision model to use in GPU-based mesh construction computations </td></tr>
    <tr><td class="paramname">availability</td><td>Indicate whether the particle coordinate data on the CPU or GPU should be trusted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac40116c754cab191702c5fbd41b3006b" name="ac40116c754cab191702c5fbd41b3006b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac40116c754cab191702c5fbd41b3006b">&#9670;&#160;</a></span>BackgroundMesh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstormm_1_1structure_1_1BackgroundMesh.html">stormm::structure::BackgroundMesh</a>&lt; T &gt;::BackgroundMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstormm_1_1structure_1_1BackgroundMesh.html">BackgroundMesh</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>original</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy and move constructors as well as assignment operators can be set to their defaults because the object is composed of others, which may contain POINTER-kind <a class="el" href="classstormm_1_1review_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> objects but have their own copy and move assignment operators. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">original</td><td>The original object to copy or move </td></tr>
    <tr><td class="paramname">other</td><td>Assignments are made based on this pre-existing object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ade932608af4658b623e2c216e6da6d91" name="ade932608af4658b623e2c216e6da6d91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade932608af4658b623e2c216e6da6d91">&#9670;&#160;</a></span>computeField()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstormm_1_1structure_1_1BackgroundMesh.html">stormm::structure::BackgroundMesh</a>&lt; T &gt;::computeField </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>launcher</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classstormm_1_1structure_1_1MeshKlManager.html">MeshKlManager</a>()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PrecisionModel</td>          <td class="paramname"><span class="paramname"><em>prec</em></span><span class="paramdefsep"> = </span><span class="paramdefval">PrecisionModel::SINGLE</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>availability</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>probe_sigma</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>probe_epsilon</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the appropriate field for the mesh. This is called automatically by the constructor if enough information is provided. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">launcher</td><td>Manager for mesh kernels, dispenses launch parameters </td></tr>
    <tr><td class="paramname">prec</td><td>Precision model to use in GPU-based mesh construction computations </td></tr>
    <tr><td class="paramname">availability</td><td>Level at which the data is expected to be available </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9979fe441e2cb7de8ba7af109e33c050" name="a9979fe441e2cb7de8ba7af109e33c050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9979fe441e2cb7de8ba7af109e33c050">&#9670;&#160;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structstormm_1_1structure_1_1BackgroundMeshReader.html">BackgroundMeshReader</a>&lt; T &gt; <a class="el" href="classstormm_1_1structure_1_1BackgroundMesh.html">stormm::structure::BackgroundMesh</a>&lt; T &gt;::data </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an abstract of the mesh. </p>
<p>Overloaded:</p><ul>
<li>Get the reader for a const object</li>
<li>Get the writer for a mutable object</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tier</td><td>Obtain the data at the level of the CPU host or GPU device </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb01619c9147aeb5ec4256fbe2bf4f63" name="afb01619c9147aeb5ec4256fbe2bf4f63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb01619c9147aeb5ec4256fbe2bf4f63">&#9670;&#160;</a></span>getMolecularBasis()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classstormm_1_1structure_1_1MeshFoundation.html">MeshFoundation</a> &amp; <a class="el" href="classstormm_1_1structure_1_1BackgroundMesh.html">stormm::structure::BackgroundMesh</a>&lt; T &gt;::getMolecularBasis </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the collection of molecular details underlying the mesh, including the topology and associated coordinates, plus any neighbor list. </p>
<p>Overloaded:</p><ul>
<li>Return a const reference for a const object</li>
<li>Return a mutable pointer for a non-const object </li>
</ul>

</div>
</div>
<a id="a316b843cc9507f2a0ccfe38a4b8183b8" name="a316b843cc9507f2a0ccfe38a4b8183b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a316b843cc9507f2a0ccfe38a4b8183b8">&#9670;&#160;</a></span>getNonbondedKit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structstormm_1_1structure_1_1MeshFFKit.html">MeshFFKit</a>&lt; T &gt; <a class="el" href="classstormm_1_1structure_1_1BackgroundMesh.html">stormm::structure::BackgroundMesh</a>&lt; T &gt;::getNonbondedKit </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the abstract of the mesh in the precision of the mesh's coefficient data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tier</td><td>Obtain the data at the level of the CPU host or GPU device </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17287df3decb5feea344bda8f91675c1" name="a17287df3decb5feea344bda8f91675c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17287df3decb5feea344bda8f91675c1">&#9670;&#160;</a></span>getReferenceNonbondedKit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structstormm_1_1structure_1_1MeshFFKit.html">MeshFFKit</a>&lt; double &gt; <a class="el" href="classstormm_1_1structure_1_1BackgroundMesh.html">stormm::structure::BackgroundMesh</a>&lt; T &gt;::getReferenceNonbondedKit </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the abstract of the mesh in double precision. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tier</td><td>Obtain the data at the level of the CPU host or GPU device </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b9c6dd9553ea200da5cd54c36ba1783" name="a0b9c6dd9553ea200da5cd54c36ba1783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b9c6dd9553ea200da5cd54c36ba1783">&#9670;&#160;</a></span>setCoefficientScalingBits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstormm_1_1structure_1_1BackgroundMesh.html">stormm::structure::BackgroundMesh</a>&lt; T &gt;::setCoefficientScalingBits </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>scaling_bits_in</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the number of bits after the decimal to be used in fixed-precision representations of coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scaling_bits_in</td><td>The desired bit count </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62604bb049958755faeca1c395c27a32" name="a62604bb049958755faeca1c395c27a32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62604bb049958755faeca1c395c27a32">&#9670;&#160;</a></span>setMeshParameters()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstormm_1_1structure_1_1BackgroundMesh.html">stormm::structure::BackgroundMesh</a>&lt; T &gt;::setMeshParameters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> *</td>          <td class="paramname"><span class="paramname"><em>ag_in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> *</td>          <td class="paramname"><span class="paramname"><em>cf_in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>padding</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>spacing</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>scale_bits_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-100</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the dimensions of the mesh. Variants of this member function that do not include a coordinate pointer or topology may assume that one has already been set. Variants that do accept a coordinate pointer will set that as the mesh's coordinate set. </p>
<p>Overloaded:</p><ul>
<li>Take coordinate and topology pointers with a single parameter to define the mesh limits.</li>
<li>Take a single parameter to define the mesh limits around a set of coordinates defined by a particular topology, and assume that the mesh already has these things.</li>
<li>Take the minimum and maximum Cartesian X, Y, and Z limits of a rectilinear mesh (this will not require a system to implement)</li>
<li>Take a single parameter to define isotropic mesh elements</li>
<li>Take three or nine parameters to define anisotropic rectilinear or triclinic mesh elements</li>
<li>Indicate the scaling bits to be used in fixed-precision arithmetic when determining positions on the mesh, or leave that parameter unchanged</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ag_in</td><td>New topology to build the mesh around (this will be incorporated into the object) </td></tr>
    <tr><td class="paramname">cf_in</td><td>New coordinate set to build the mesh around (this will be incorporated into the object) </td></tr>
    <tr><td class="paramname">padding</td><td>Region around the molecule of interest to spread the mesh </td></tr>
    <tr><td class="paramname">mesh_bounds</td><td>Minimum and maximum Cartesian limits of the mesh </td></tr>
    <tr><td class="paramname">spacing</td><td>Width (and length, and height, or bounding vectors) of mesh elements </td></tr>
    <tr><td class="paramname">scale_bits_in</td><td>The number of bits after the decimal to use in fixed-precision computations of particle positions on the grid. The default value of -100 is nonsensical and will be interpreted as "leave the current
                      setting as it is." Limiting the number of function overloads in this way is a step towards controlling code bloat due to this large, templated class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a94b3b378a99d1e72a2097d5cb32512d7" name="a94b3b378a99d1e72a2097d5cb32512d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94b3b378a99d1e72a2097d5cb32512d7">&#9670;&#160;</a></span>setOcclusionPenalty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstormm_1_1structure_1_1BackgroundMesh.html">stormm::structure::BackgroundMesh</a>&lt; T &gt;::setOcclusionPenalty </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>occlusion_penalty_in</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the penalty associated with striking occupied volume on an occlusion mesh. This is intended to be modified afeter making the mesh, if at all, as the actual value has no bearing on the way the bitmask is constructed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">occlusion_penalty_in</td><td>The occlusion penalty to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c8200dcbf648cb59a60134010bff62e" name="a0c8200dcbf648cb59a60134010bff62e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c8200dcbf648cb59a60134010bff62e">&#9670;&#160;</a></span>setProbeRadius()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstormm_1_1structure_1_1BackgroundMesh.html">stormm::structure::BackgroundMesh</a>&lt; T &gt;::setProbeRadius </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>probe_radius_in</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the probe radius, meaning either the Lennard-Jones potential sigma radius or the clash probe radius, depending on the mesh type. This includes a validity check. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">probe_radius_in</td><td>The probe radius to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a566346378f27221d3b44d3b9cf7e9992" name="a566346378f27221d3b44d3b9cf7e9992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a566346378f27221d3b44d3b9cf7e9992">&#9670;&#160;</a></span>setWellDepth()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstormm_1_1structure_1_1BackgroundMesh.html">stormm::structure::BackgroundMesh</a>&lt; T &gt;::setWellDepth </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>well_depth_in</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the Lennard-Jones well depth for the probe that will generate the potential. This includes a validity check. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">well_depth_in</td><td>The well depth to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09c3267cfd6f6005001deac057a2f27c" name="a09c3267cfd6f6005001deac057a2f27c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c3267cfd6f6005001deac057a2f27c">&#9670;&#160;</a></span>templateFreeData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structstormm_1_1structure_1_1BackgroundMeshReader.html">BackgroundMeshReader</a>&lt; void &gt; <a class="el" href="classstormm_1_1structure_1_1BackgroundMesh.html">stormm::structure::BackgroundMesh</a>&lt; T &gt;::templateFreeData </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an abstract of the mesh with any templating removed. </p>
<p>Overloaded:</p><ul>
<li>Get the reader for a const object</li>
<li>Get the writer for a mutable object</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tier</td><td>Obtain the data at the level of the CPU host or GPU device </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6719d42c2ed595b29802fb47b10ca337" name="a6719d42c2ed595b29802fb47b10ca337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6719d42c2ed595b29802fb47b10ca337">&#9670;&#160;</a></span>templateFreeNonbondedKit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structstormm_1_1structure_1_1MeshFFKit.html">MeshFFKit</a>&lt; void &gt; <a class="el" href="classstormm_1_1structure_1_1BackgroundMesh.html">stormm::structure::BackgroundMesh</a>&lt; T &gt;::templateFreeNonbondedKit </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a template-free form of the of the mesh nonbonded abstract in the mesh coefficient data type, useful for passing between the C++- and HPC-compiled code objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tier</td><td>Obtain the data at the level of the CPU host or GPU device </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af3907b58619238344e29f928a6947035" name="af3907b58619238344e29f928a6947035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3907b58619238344e29f928a6947035">&#9670;&#160;</a></span>validateCombiningRule()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstormm_1_1structure_1_1BackgroundMesh.html">stormm::structure::BackgroundMesh</a>&lt; T &gt;::validateCombiningRule </td>
          <td>(</td>
          <td class="paramtype">VdwCombiningRule</td>          <td class="paramname"><span class="paramname"><em>mixing_protocol_in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>probe_sigma</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>probe_epsilon</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check the combining rule that will be used to make the probe interact with the receptor on any mesh (with the exception of an electrostatic field). With geometric combining rules, it is possible to tailor a single mesh for all particles that might interact with the receptor. However, with Lorentz-Berthelot rules or any case of non-conformant pair rules, new grids are required for a rigorous description of each particle type that might interact with the mesh potential. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mixing_protocol_in</td><td>The method to use </td></tr>
    <tr><td class="paramname">probe_sigma</td><td>Probe pairwise sigma parameters with each Lennard-Jones type in the topology (the topology is assumed to be set by the time this function is called). For NBFIX combining rules, this array must have entries for each Lennard-Jones type. For other combining rules, this array should have no contents. </td></tr>
    <tr><td class="paramname">probe_epsilon</td><td>Probe pairwise epsilon parameters (see probe_sigma for stipulations about this array) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/Structure/<a class="el" href="background__mesh_8h_source.html">background_mesh.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2
</small></address>
</div><!-- doc-content -->
</body>
</html>
