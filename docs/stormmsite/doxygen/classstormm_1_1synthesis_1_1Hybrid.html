<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>STORMM Source Documentation: stormm::synthesis::Hybrid&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">STORMM Source Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>stormm</b></li><li class="navelem"><b>synthesis</b></li><li class="navelem"><a class="el" href="classstormm_1_1synthesis_1_1Hybrid.html">Hybrid</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classstormm_1_1synthesis_1_1Hybrid-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">stormm::synthesis::Hybrid&lt; T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from either the GPU or the CPU. In unified mode, the two data are one insofar as the programmer sees it, and the page migration engine engaged by cudaMallocManaged handles the two physical memory spaces at a very low level. In other modes, composite memory must be uploaded or downloaded explicitly in order to maintain synchrony between host and device memory spaces. This struct mimics a lot of the most noteworthy behavior of std::vector, but with the potential to behave as a pointer as well. In this manner, it is intended to confer the convenience of C++ with the freedom of classic C programming.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="hybrid_8h_source.html">hybrid.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4c21f4b560e6dca446e2158c289839b6" id="r_a4c21f4b560e6dca446e2158c289839b6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c21f4b560e6dca446e2158c289839b6">Hybrid</a> (const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a> &amp;original)</td></tr>
<tr class="memdesc:a4c21f4b560e6dca446e2158c289839b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor handles the reassignment of the underlying raw pointers.  <br /></td></tr>
<tr class="separator:a4c21f4b560e6dca446e2158c289839b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec73f6b3a11d38580b0ef46bdc208069" id="r_aec73f6b3a11d38580b0ef46bdc208069"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec73f6b3a11d38580b0ef46bdc208069">Hybrid</a> (<a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a> &amp;&amp;original)</td></tr>
<tr class="memdesc:aec73f6b3a11d38580b0ef46bdc208069"><td class="mdescLeft">&#160;</td><td class="mdescRight">The move constructor handles migration of a <a class="el" href="classstormm_1_1synthesis_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> object.  <br /></td></tr>
<tr class="separator:aec73f6b3a11d38580b0ef46bdc208069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da23954fa7528da076df3611d88fb03" id="r_a5da23954fa7528da076df3611d88fb03"><td class="memItemLeft" align="right" valign="top"><a id="a5da23954fa7528da076df3611d88fb03" name="a5da23954fa7528da076df3611d88fb03"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~Hybrid</b> ()</td></tr>
<tr class="memdesc:a5da23954fa7528da076df3611d88fb03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor frees data with no re-allocation. <br /></td></tr>
<tr class="separator:a5da23954fa7528da076df3611d88fb03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff7b404a811130212dc6ae047969514" id="r_a5ff7b404a811130212dc6ae047969514"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ff7b404a811130212dc6ae047969514">operator=</a> (const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a> &amp;other)</td></tr>
<tr class="memdesc:a5ff7b404a811130212dc6ae047969514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment constructor handles the reassignment of the underlying raw pointers.  <br /></td></tr>
<tr class="separator:a5ff7b404a811130212dc6ae047969514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc0bbcb040a72d9e9a4e74ff2191f5a7" id="r_afc0bbcb040a72d9e9a4e74ff2191f5a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc0bbcb040a72d9e9a4e74ff2191f5a7">operator=</a> (<a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:afc0bbcb040a72d9e9a4e74ff2191f5a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The move assignment operator must likewise handle transfer of the underlying data.  <br /></td></tr>
<tr class="separator:afc0bbcb040a72d9e9a4e74ff2191f5a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23edba8c137fcc18dc80373ed4f3bef5" id="r_a23edba8c137fcc18dc80373ed4f3bef5"><td class="memItemLeft" align="right" valign="top"><a id="a23edba8c137fcc18dc80373ed4f3bef5" name="a23edba8c137fcc18dc80373ed4f3bef5"></a>
HybridKind&#160;</td><td class="memItemRight" valign="bottom"><b>getKind</b> () const</td></tr>
<tr class="memdesc:a23edba8c137fcc18dc80373ed4f3bef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the object kind (pointer or array) <br /></td></tr>
<tr class="separator:a23edba8c137fcc18dc80373ed4f3bef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01016da707409e0f133724a10ef7523" id="r_ad01016da707409e0f133724a10ef7523"><td class="memItemLeft" align="right" valign="top"><a id="ad01016da707409e0f133724a10ef7523" name="ad01016da707409e0f133724a10ef7523"></a>
HybridFormat&#160;</td><td class="memItemRight" valign="bottom"><b>getFormat</b> () const</td></tr>
<tr class="memdesc:ad01016da707409e0f133724a10ef7523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the memory format. <br /></td></tr>
<tr class="separator:ad01016da707409e0f133724a10ef7523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac777662f617195ce2b5d6b9516dc5707" id="r_ac777662f617195ce2b5d6b9516dc5707"><td class="memItemLeft" align="right" valign="top"><a id="ac777662f617195ce2b5d6b9516dc5707" name="ac777662f617195ce2b5d6b9516dc5707"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () const</td></tr>
<tr class="memdesc:ac777662f617195ce2b5d6b9516dc5707"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of elements in the <a class="el" href="classstormm_1_1synthesis_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> object's data array(s) <br /></td></tr>
<tr class="separator:ac777662f617195ce2b5d6b9516dc5707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060724c15664dfcbfb8d7e94be34113d" id="r_a060724c15664dfcbfb8d7e94be34113d"><td class="memItemLeft" align="right" valign="top"><a id="a060724c15664dfcbfb8d7e94be34113d" name="a060724c15664dfcbfb8d7e94be34113d"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>capacity</b> () const</td></tr>
<tr class="memdesc:a060724c15664dfcbfb8d7e94be34113d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of elements in the <a class="el" href="classstormm_1_1synthesis_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> object's data array(s) <br /></td></tr>
<tr class="separator:a060724c15664dfcbfb8d7e94be34113d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08464350269dee36c9aea33f97b5ad0" id="r_aa08464350269dee36c9aea33f97b5ad0"><td class="memItemLeft" align="right" valign="top"><a id="aa08464350269dee36c9aea33f97b5ad0" name="aa08464350269dee36c9aea33f97b5ad0"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>getPointerIndex</b> () const</td></tr>
<tr class="memdesc:aa08464350269dee36c9aea33f97b5ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the pointer start position, targeting another ARRAY-kind <a class="el" href="classstormm_1_1synthesis_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> object (relevant for POINTER-kind <a class="el" href="classstormm_1_1synthesis_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> objects only) <br /></td></tr>
<tr class="separator:aa08464350269dee36c9aea33f97b5ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50738326aa14102112def7dd3e16c3f2" id="r_a50738326aa14102112def7dd3e16c3f2"><td class="memItemLeft" align="right" valign="top"><a id="a50738326aa14102112def7dd3e16c3f2" name="a50738326aa14102112def7dd3e16c3f2"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>getElementSize</b> () const</td></tr>
<tr class="memdesc:a50738326aa14102112def7dd3e16c3f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of an individual element in the data array(s) <br /></td></tr>
<tr class="separator:a50738326aa14102112def7dd3e16c3f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7db6e7efb027af58c729fd8b094cf9a" id="r_ae7db6e7efb027af58c729fd8b094cf9a"><td class="memItemLeft" align="right" valign="top"><a id="ae7db6e7efb027af58c729fd8b094cf9a" name="ae7db6e7efb027af58c729fd8b094cf9a"></a>
HybridLabel&#160;</td><td class="memItemRight" valign="bottom"><b>getLabel</b> () const</td></tr>
<tr class="memdesc:ae7db6e7efb027af58c729fd8b094cf9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the object's identifying label. <br /></td></tr>
<tr class="separator:ae7db6e7efb027af58c729fd8b094cf9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a66a3020994b425ef6bf2f5b473ed4c" id="r_a8a66a3020994b425ef6bf2f5b473ed4c"><td class="memItemLeft" align="right" valign="top"><a id="a8a66a3020994b425ef6bf2f5b473ed4c" name="a8a66a3020994b425ef6bf2f5b473ed4c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getSerialNumber</b> () const</td></tr>
<tr class="memdesc:a8a66a3020994b425ef6bf2f5b473ed4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the object's identifying serial number. <br /></td></tr>
<tr class="separator:a8a66a3020994b425ef6bf2f5b473ed4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b86b79f38ba20b95ece251c3f37ace" id="r_a11b86b79f38ba20b95ece251c3f37ace"><td class="memItemLeft" align="right" valign="top"><a id="a11b86b79f38ba20b95ece251c3f37ace" name="a11b86b79f38ba20b95ece251c3f37ace"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getAllocations</b> () const</td></tr>
<tr class="memdesc:a11b86b79f38ba20b95ece251c3f37ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of times this object has been allocated. <br /></td></tr>
<tr class="separator:a11b86b79f38ba20b95ece251c3f37ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ac8cc2b2ef6211a9f5f0856d84ef20" id="r_a11ac8cc2b2ef6211a9f5f0856d84ef20"><td class="memItemLeft" align="right" valign="top"><a id="a11ac8cc2b2ef6211a9f5f0856d84ef20" name="a11ac8cc2b2ef6211a9f5f0856d84ef20"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getTargetSerialNumber</b> () const</td></tr>
<tr class="memdesc:a11ac8cc2b2ef6211a9f5f0856d84ef20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce the serial number of the target (only valid for POINTER-kind objects). This function is needed for the copy constructor in the POINTER-kind case. <br /></td></tr>
<tr class="separator:a11ac8cc2b2ef6211a9f5f0856d84ef20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55aa7f98f185b8f56c1fa5395ee3b348" id="r_a55aa7f98f185b8f56c1fa5395ee3b348"><td class="memItemLeft" align="right" valign="top"><a id="a55aa7f98f185b8f56c1fa5395ee3b348" name="a55aa7f98f185b8f56c1fa5395ee3b348"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>verifyTarget</b> () const</td></tr>
<tr class="memdesc:a55aa7f98f185b8f56c1fa5395ee3b348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that the target of a HybridKind::POINTER object remains in the state it was in when the pointer was first set. <br /></td></tr>
<tr class="separator:a55aa7f98f185b8f56c1fa5395ee3b348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e1a24a029c60c38f93227f1b8b557d" id="r_a67e1a24a029c60c38f93227f1b8b557d"><td class="memItemLeft" align="right" valign="top"><a id="a67e1a24a029c60c38f93227f1b8b557d" name="a67e1a24a029c60c38f93227f1b8b557d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>shrinkToFit</b> ()</td></tr>
<tr class="memdesc:a67e1a24a029c60c38f93227f1b8b557d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim a <a class="el" href="classstormm_1_1synthesis_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> array to the exact size of its data. <br /></td></tr>
<tr class="separator:a67e1a24a029c60c38f93227f1b8b557d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0634f9031323f7219a51c2b88485c32a" id="r_a0634f9031323f7219a51c2b88485c32a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0634f9031323f7219a51c2b88485c32a">setPointer</a> (<a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; T &gt; *target, size_t position=0, llint new_length=-1LL)</td></tr>
<tr class="memdesc:a0634f9031323f7219a51c2b88485c32a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a <a class="el" href="classstormm_1_1synthesis_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> pointer struct to a segment of a <a class="el" href="classstormm_1_1synthesis_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> array struct.  <br /></td></tr>
<tr class="separator:a0634f9031323f7219a51c2b88485c32a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e3f0516028238f5f3152836c89079a" id="r_a78e3f0516028238f5f3152836c89079a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78e3f0516028238f5f3152836c89079a">swapTarget</a> (<a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; T &gt; *new_target, ExceptionResponse policy=ExceptionResponse::SILENT)</td></tr>
<tr class="memdesc:a78e3f0516028238f5f3152836c89079a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the target of a POINTER-kind <a class="el" href="classstormm_1_1synthesis_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> object, transferring its starting index and current length to apply instead to the new target. Bounds checks will still be applied. Not valid for ARRAY-kind <a class="el" href="classstormm_1_1synthesis_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> objects or for POINTER-kind objects that have no current target.  <br /></td></tr>
<tr class="separator:a78e3f0516028238f5f3152836c89079a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af3c9bc6b4398e44ac694b8a3c683853b" id="r_af3c9bc6b4398e44ac694b8a3c683853b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3c9bc6b4398e44ac694b8a3c683853b">Hybrid</a> (size_t length_in=0, const char *tag_in=nullptr, const HybridFormat format_in=default_hpc_format, const HybridKind kind_in=HybridKind::ARRAY)</td></tr>
<tr class="memdesc:af3c9bc6b4398e44ac694b8a3c683853b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructors vary based on whether CUDA is part of the compilation.  <br /></td></tr>
<tr class="separator:af3c9bc6b4398e44ac694b8a3c683853b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67990bac134efc7cf08d4c08ad5d5902" id="r_a67990bac134efc7cf08d4c08ad5d5902"><td class="memItemLeft" align="right" valign="top"><a id="a67990bac134efc7cf08d4c08ad5d5902" name="a67990bac134efc7cf08d4c08ad5d5902"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Hybrid</b> (const std::vector&lt; T &gt; &amp;S_in, const char *tag_in=nullptr, const HybridFormat format_in=default_hpc_format)</td></tr>
<tr class="separator:a67990bac134efc7cf08d4c08ad5d5902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af692bd96cc7746bbe264df05b67932d7" id="r_af692bd96cc7746bbe264df05b67932d7"><td class="memItemLeft" align="right" valign="top"><a id="af692bd96cc7746bbe264df05b67932d7" name="af692bd96cc7746bbe264df05b67932d7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Hybrid</b> (const HybridKind kind_in, const char *tag_in=nullptr, const HybridFormat format_in=default_hpc_format, size_t length_in=0)</td></tr>
<tr class="separator:af692bd96cc7746bbe264df05b67932d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad1f62475eb415954b9fc647800e95bd6" id="r_ad1f62475eb415954b9fc647800e95bd6"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1f62475eb415954b9fc647800e95bd6">data</a> (const HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:ad1f62475eb415954b9fc647800e95bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer directly to the GpuArray's data on either the host or the device.  <br /></td></tr>
<tr class="separator:ad1f62475eb415954b9fc647800e95bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b7f19a7191ef60dc5b9d77bbb7f3a5" id="r_a15b7f19a7191ef60dc5b9d77bbb7f3a5"><td class="memItemLeft" align="right" valign="top"><a id="a15b7f19a7191ef60dc5b9d77bbb7f3a5" name="a15b7f19a7191ef60dc5b9d77bbb7f3a5"></a>
T *&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> (const HybridTargetLevel tier=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:a15b7f19a7191ef60dc5b9d77bbb7f3a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0579506f2360c1e3094643e3f66f9f1f" id="r_a0579506f2360c1e3094643e3f66f9f1f"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0579506f2360c1e3094643e3f66f9f1f">readHost</a> (size_t index) const</td></tr>
<tr class="memdesc:a0579506f2360c1e3094643e3f66f9f1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get data from a given index of the host_data array. This substitutes for direct array access via the [ ] operator, as the host_data and devc_data pointers are private.  <br /></td></tr>
<tr class="separator:a0579506f2360c1e3094643e3f66f9f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f63449d74dee393c744af621728af8" id="r_ab2f63449d74dee393c744af621728af8"><td class="memItemLeft" align="right" valign="top"><a id="ab2f63449d74dee393c744af621728af8" name="ab2f63449d74dee393c744af621728af8"></a>
std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>readHost</b> (size_t offset, size_t count) const</td></tr>
<tr class="separator:ab2f63449d74dee393c744af621728af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d866850b37ce7e99fa37fb060be2999" id="r_a2d866850b37ce7e99fa37fb060be2999"><td class="memItemLeft" align="right" valign="top"><a id="a2d866850b37ce7e99fa37fb060be2999" name="a2d866850b37ce7e99fa37fb060be2999"></a>
std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>readHost</b> () const</td></tr>
<tr class="separator:a2d866850b37ce7e99fa37fb060be2999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6ba26b738f6fdfafd2a4cf50a208134" id="r_af6ba26b738f6fdfafd2a4cf50a208134"><td class="memItemLeft" align="right" valign="top"><a id="af6ba26b738f6fdfafd2a4cf50a208134" name="af6ba26b738f6fdfafd2a4cf50a208134"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>readHost</b> (T *v, size_t offset, size_t count) const</td></tr>
<tr class="separator:af6ba26b738f6fdfafd2a4cf50a208134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a06ad7ba270e9a7fa971fbfafa5947f07" id="r_a06ad7ba270e9a7fa971fbfafa5947f07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06ad7ba270e9a7fa971fbfafa5947f07">putHost</a> (const T value, size_t index)</td></tr>
<tr class="memdesc:a06ad7ba270e9a7fa971fbfafa5947f07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put data into the host_data array. This substitutes for direct array access via the [ ] operator, as the host_data and devc_data pointers are private.  <br /></td></tr>
<tr class="separator:a06ad7ba270e9a7fa971fbfafa5947f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb35713f73a96ba407e25dbdd7435ff" id="r_abbb35713f73a96ba407e25dbdd7435ff"><td class="memItemLeft" align="right" valign="top"><a id="abbb35713f73a96ba407e25dbdd7435ff" name="abbb35713f73a96ba407e25dbdd7435ff"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>putHost</b> (const std::vector&lt; T &gt; &amp;values, size_t offset, size_t count)</td></tr>
<tr class="separator:abbb35713f73a96ba407e25dbdd7435ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b50c9f92b1d663fd167af4543e656c" id="r_a04b50c9f92b1d663fd167af4543e656c"><td class="memItemLeft" align="right" valign="top"><a id="a04b50c9f92b1d663fd167af4543e656c" name="a04b50c9f92b1d663fd167af4543e656c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>putHost</b> (const std::vector&lt; T &gt; &amp;values)</td></tr>
<tr class="separator:a04b50c9f92b1d663fd167af4543e656c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9fe37e5b633a08238a02491acd6458b" id="r_ad9fe37e5b633a08238a02491acd6458b"><td class="memItemLeft" align="right" valign="top"><a id="ad9fe37e5b633a08238a02491acd6458b" name="ad9fe37e5b633a08238a02491acd6458b"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>putHost</b> (<a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; T &gt; *target, const std::vector&lt; T &gt; &amp;values, size_t offset=0, size_t padding=0, size_t count=0)</td></tr>
<tr class="separator:ad9fe37e5b633a08238a02491acd6458b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a041f79240ace2d5d92d9cfe74b00d166" id="r_a041f79240ace2d5d92d9cfe74b00d166"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a041f79240ace2d5d92d9cfe74b00d166">pushBack</a> (const T element)</td></tr>
<tr class="memdesc:a041f79240ace2d5d92d9cfe74b00d166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mimic the C++ std::vector push_back functionality. A bounds check is followed by extension of the data arrays in the current format if necessary. The new element is placed at the end of the host_data array. The <a class="el" href="classstormm_1_1synthesis_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> object must be ARRAY-kind or a POINTER-kind with sufficient maximum capacity (no reallocation needed). Additions will go to the CPU host memory.  <br /></td></tr>
<tr class="separator:a041f79240ace2d5d92d9cfe74b00d166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b209bec63fbb8c3defc0f3e600b5d14" id="r_a7b209bec63fbb8c3defc0f3e600b5d14"><td class="memItemLeft" align="right" valign="top"><a id="a7b209bec63fbb8c3defc0f3e600b5d14" name="a7b209bec63fbb8c3defc0f3e600b5d14"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pushBack</b> (const T *elements, const size_t element_count)</td></tr>
<tr class="separator:a7b209bec63fbb8c3defc0f3e600b5d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab970ae3b42cf1b095568842ae94df76c" id="r_ab970ae3b42cf1b095568842ae94df76c"><td class="memItemLeft" align="right" valign="top"><a id="ab970ae3b42cf1b095568842ae94df76c" name="ab970ae3b42cf1b095568842ae94df76c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pushBack</b> (const std::vector&lt; T &gt; &amp;elements)</td></tr>
<tr class="separator:ab970ae3b42cf1b095568842ae94df76c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fef1abbd9ab08318e4f851f52b986bf" id="r_a6fef1abbd9ab08318e4f851f52b986bf"><td class="memItemLeft" align="right" valign="top"><a id="a6fef1abbd9ab08318e4f851f52b986bf" name="a6fef1abbd9ab08318e4f851f52b986bf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pushBack</b> (const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; T &gt; &amp;elements)</td></tr>
<tr class="separator:a6fef1abbd9ab08318e4f851f52b986bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a68ee98afa3b9b7a1b98d35407a2c6302" id="r_a68ee98afa3b9b7a1b98d35407a2c6302"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68ee98afa3b9b7a1b98d35407a2c6302">resize</a> (size_t new_length)</td></tr>
<tr class="memdesc:a68ee98afa3b9b7a1b98d35407a2c6302"><td class="mdescLeft">&#160;</td><td class="mdescRight">A std::vector-like <a class="el" href="classstormm_1_1card_1_1Hybrid.html#a68ee98afa3b9b7a1b98d35407a2c6302" title="A std::vector-like resize() feature.">resize()</a> feature.  <br /></td></tr>
<tr class="separator:a68ee98afa3b9b7a1b98d35407a2c6302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ea3e7feb767ef1f8bb61424b46e644" id="r_a49ea3e7feb767ef1f8bb61424b46e644"><td class="memItemLeft" align="right" valign="top"><a id="a49ea3e7feb767ef1f8bb61424b46e644" name="a49ea3e7feb767ef1f8bb61424b46e644"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resize</b> (size_t new_length, T value)</td></tr>
<tr class="separator:a49ea3e7feb767ef1f8bb61424b46e644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:afed4f7ccac390d98775693831480ce16" id="r_afed4f7ccac390d98775693831480ce16"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afed4f7ccac390d98775693831480ce16">getPointer</a> (size_t position=0, size_t new_length=0, const char *tag_in=nullptr) const</td></tr>
<tr class="memdesc:afed4f7ccac390d98775693831480ce16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to a <a class="el" href="classstormm_1_1synthesis_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> object at a specific location. This is the way to get const <a class="el" href="classstormm_1_1synthesis_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> POINTER-kind objects to const ARRAY-kind <a class="el" href="classstormm_1_1synthesis_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> objects. This function is only available to ARRAY-kind <a class="el" href="classstormm_1_1synthesis_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> objects.  <br /></td></tr>
<tr class="separator:afed4f7ccac390d98775693831480ce16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae4fdc385309267b92d4f8f7bf437ed" id="r_aeae4fdc385309267b92d4f8f7bf437ed"><td class="memItemLeft" align="right" valign="top"><a id="aeae4fdc385309267b92d4f8f7bf437ed" name="aeae4fdc385309267b92d4f8f7bf437ed"></a>
<a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getPointer</b> (size_t position=0, size_t new_length=0, const char *tag_in=nullptr)</td></tr>
<tr class="separator:aeae4fdc385309267b92d4f8f7bf437ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T&gt;<br />
class stormm::synthesis::Hybrid&lt; T &gt;</div><p>An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from either the GPU or the CPU. In unified mode, the two data are one insofar as the programmer sees it, and the page migration engine engaged by cudaMallocManaged handles the two physical memory spaces at a very low level. In other modes, composite memory must be uploaded or downloaded explicitly in order to maintain synchrony between host and device memory spaces. This struct mimics a lot of the most noteworthy behavior of std::vector, but with the potential to behave as a pointer as well. In this manner, it is intended to confer the convenience of C++ with the freedom of classic C programming. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af3c9bc6b4398e44ac694b8a3c683853b" name="af3c9bc6b4398e44ac694b8a3c683853b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3c9bc6b4398e44ac694b8a3c683853b">&#9670;&#160;</a></span>Hybrid() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstormm_1_1card_1_1Hybrid.html">stormm::card::Hybrid</a>&lt; T &gt;::Hybrid </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>tag_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HybridFormat</td>          <td class="paramname"><span class="paramname"><em>format_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">default_hpc_format</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HybridKind</td>          <td class="paramname"><span class="paramname"><em>kind_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridKind::ARRAY</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructors vary based on whether CUDA is part of the compilation. </p>
<p>Overloaded:</p><ul>
<li>Simple constructor takes an optional size and an optional format</li>
<li>Secondary constructor takes a std::vector of the intended type and allocates based on its size, again with an optional format</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length_in</td><td>The input length of the array </td></tr>
    <tr><td class="paramname">tag_in</td><td>A human-readable tag by which to call this array </td></tr>
    <tr><td class="paramname">format_in</td><td>Format of the resulting hybrid data structure </td></tr>
    <tr><td class="paramname">kind_in</td><td>The kind of <a class="el" href="classstormm_1_1synthesis_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> object this will be </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c21f4b560e6dca446e2158c289839b6" name="a4c21f4b560e6dca446e2158c289839b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c21f4b560e6dca446e2158c289839b6">&#9670;&#160;</a></span>Hybrid() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstormm_1_1card_1_1Hybrid.html">stormm::card::Hybrid</a>&lt; T &gt;::Hybrid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>original</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor handles the reassignment of the underlying raw pointers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">original</td><td>The <a class="el" href="classstormm_1_1synthesis_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> object to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec73f6b3a11d38580b0ef46bdc208069" name="aec73f6b3a11d38580b0ef46bdc208069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec73f6b3a11d38580b0ef46bdc208069">&#9670;&#160;</a></span>Hybrid() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstormm_1_1card_1_1Hybrid.html">stormm::card::Hybrid</a>&lt; T &gt;::Hybrid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>original</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The move constructor handles migration of a <a class="el" href="classstormm_1_1synthesis_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">original</td><td>The <a class="el" href="classstormm_1_1synthesis_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> object to move </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad1f62475eb415954b9fc647800e95bd6" name="ad1f62475eb415954b9fc647800e95bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f62475eb415954b9fc647800e95bd6">&#9670;&#160;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="classstormm_1_1card_1_1Hybrid.html">stormm::card::Hybrid</a>&lt; T &gt;::data </td>
          <td>(</td>
          <td class="paramtype">const HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer directly to the GpuArray's data on either the host or the device. </p>
<p>Overloaded:</p><ul>
<li>Get a const pointer if the object is const</li>
<li>Get a pointer that can modify the underlying data if the object is non-const</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tier</td><td>The level at which to set the pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afed4f7ccac390d98775693831480ce16" name="afed4f7ccac390d98775693831480ce16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afed4f7ccac390d98775693831480ce16">&#9670;&#160;</a></span>getPointer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; T &gt; <a class="el" href="classstormm_1_1card_1_1Hybrid.html">stormm::card::Hybrid</a>&lt; T &gt;::getPointer </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>position</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>new_length</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>tag_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to a <a class="el" href="classstormm_1_1synthesis_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> object at a specific location. This is the way to get const <a class="el" href="classstormm_1_1synthesis_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> POINTER-kind objects to const ARRAY-kind <a class="el" href="classstormm_1_1synthesis_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> objects. This function is only available to ARRAY-kind <a class="el" href="classstormm_1_1synthesis_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> objects. </p>
<p>Overloaded:</p><ul>
<li>Get a const <a class="el" href="classstormm_1_1synthesis_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> POINTER-kind object to a const <a class="el" href="classstormm_1_1synthesis_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> array</li>
<li>Get a non-const <a class="el" href="classstormm_1_1synthesis_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> POINTER-kind object to a non-const array</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The position in the array to which the POINTER-kind <a class="el" href="classstormm_1_1synthesis_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> object targets </td></tr>
    <tr><td class="paramname">new_length</td><td>The length that the POINTER-kind <a class="el" href="classstormm_1_1synthesis_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> object will have (default 0 implies it will be the length of the current array minus the POINTER-kind object's starting position) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ff7b404a811130212dc6ae047969514" name="a5ff7b404a811130212dc6ae047969514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ff7b404a811130212dc6ae047969514">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a> &amp; <a class="el" href="classstormm_1_1card_1_1Hybrid.html">stormm::card::Hybrid</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment constructor handles the reassignment of the underlying raw pointers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The <a class="el" href="classstormm_1_1synthesis_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> object to copy (a different name for a better semantic fit in the context of the = sign) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc0bbcb040a72d9e9a4e74ff2191f5a7" name="afc0bbcb040a72d9e9a4e74ff2191f5a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc0bbcb040a72d9e9a4e74ff2191f5a7">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a> &amp; <a class="el" href="classstormm_1_1card_1_1Hybrid.html">stormm::card::Hybrid</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The move assignment operator must likewise handle transfer of the underlying data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The <a class="el" href="classstormm_1_1synthesis_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> object to move (a different name for a better semantic fit in the context of the = sign) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a041f79240ace2d5d92d9cfe74b00d166" name="a041f79240ace2d5d92d9cfe74b00d166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a041f79240ace2d5d92d9cfe74b00d166">&#9670;&#160;</a></span>pushBack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstormm_1_1card_1_1Hybrid.html">stormm::card::Hybrid</a>&lt; T &gt;::pushBack </td>
          <td>(</td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>element</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mimic the C++ std::vector push_back functionality. A bounds check is followed by extension of the data arrays in the current format if necessary. The new element is placed at the end of the host_data array. The <a class="el" href="classstormm_1_1synthesis_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> object must be ARRAY-kind or a POINTER-kind with sufficient maximum capacity (no reallocation needed). Additions will go to the CPU host memory. </p>
<p>Overloaded:</p><ul>
<li>Add a single element</li>
<li>Add multiple elements from a C-style array, Standard Template Library vector, or another <a class="el" href="classstormm_1_1synthesis_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> object.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>The new item to add </td></tr>
    <tr><td class="paramname">elements</td><td>An array of new elements to add </td></tr>
    <tr><td class="paramname">element_count</td><td>The trusted length of elements, if adding from a C-style array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06ad7ba270e9a7fa971fbfafa5947f07" name="a06ad7ba270e9a7fa971fbfafa5947f07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06ad7ba270e9a7fa971fbfafa5947f07">&#9670;&#160;</a></span>putHost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstormm_1_1card_1_1Hybrid.html">stormm::card::Hybrid</a>&lt; T &gt;::putHost </td>
          <td>(</td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put data into the host_data array. This substitutes for direct array access via the [ ] operator, as the host_data and devc_data pointers are private. </p>
<p>Overloaded:</p><ul>
<li>Put a single element into the host_data at a specific index</li>
<li>Put an array of elements into the host_data, starting at a specific offset index</li>
<li>Target this (POINTER-kind) <a class="el" href="classstormm_1_1synthesis_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> object to another (ARRAY-kind) <a class="el" href="classstormm_1_1synthesis_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> object at a specific offset, then load this object's host_data with an array of elements and pad additional space in the target with zeros. Return the next unpadded index in the target for convenience.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The data to write into host_data </td></tr>
    <tr><td class="paramname">values</td><td>The data to write into host_data </td></tr>
    <tr><td class="paramname">target</td><td>Another <a class="el" href="classstormm_1_1synthesis_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> object to target </td></tr>
    <tr><td class="paramname">index</td><td>The index of host_data to write </td></tr>
    <tr><td class="paramname">offset</td><td>The index at which to begin writing values into host_data </td></tr>
    <tr><td class="paramname">count</td><td>If the data comes as an array, write only the first count values into the <a class="el" href="classstormm_1_1synthesis_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> object's host_data. The default of zero implies that the entirety of values shall be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0579506f2360c1e3094643e3f66f9f1f" name="a0579506f2360c1e3094643e3f66f9f1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0579506f2360c1e3094643e3f66f9f1f">&#9670;&#160;</a></span>readHost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classstormm_1_1card_1_1Hybrid.html">stormm::card::Hybrid</a>&lt; T &gt;::readHost </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get data from a given index of the host_data array. This substitutes for direct array access via the [ ] operator, as the host_data and devc_data pointers are private. </p>
<p>Overloaded:</p><ul>
<li>Read a single element</li>
<li>Read a subset of the elements, starting at an arbitrary point in the host_data array</li>
<li>Read the entire host_data array, up to its length, into a new (out-of-place) array</li>
<li>Read data into a pre-allocated, trusted array</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the host_data array to read </td></tr>
    <tr><td class="paramname">offset</td><td>Starting index of the host_data array to read </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements to access and return </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68ee98afa3b9b7a1b98d35407a2c6302" name="a68ee98afa3b9b7a1b98d35407a2c6302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68ee98afa3b9b7a1b98d35407a2c6302">&#9670;&#160;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstormm_1_1card_1_1Hybrid.html">stormm::card::Hybrid</a>&lt; T &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>new_length</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A std::vector-like <a class="el" href="classstormm_1_1card_1_1Hybrid.html#a68ee98afa3b9b7a1b98d35407a2c6302" title="A std::vector-like resize() feature.">resize()</a> feature. </p>
<p>Overloaded:</p><ul>
<li>Resize and fill the new space with zero</li>
<li>Resize and fill the new space with a constant value</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_length</td><td>The new length. If less than the current length, all that will change is the counted number of elements. The original data will persist, as will the array(s) storing it. </td></tr>
    <tr><td class="paramname">new_value</td><td>The value with which to populate new space. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0634f9031323f7219a51c2b88485c32a" name="a0634f9031323f7219a51c2b88485c32a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0634f9031323f7219a51c2b88485c32a">&#9670;&#160;</a></span>setPointer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstormm_1_1card_1_1Hybrid.html">stormm::card::Hybrid</a>&lt; T &gt;::setPointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>position</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llint</td>          <td class="paramname"><span class="paramname"><em>new_length</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1LL</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a <a class="el" href="classstormm_1_1synthesis_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> pointer struct to a segment of a <a class="el" href="classstormm_1_1synthesis_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> array struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Pointer to the <a class="el" href="classstormm_1_1synthesis_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> object to point into. This is a pointer because otherwise it would have to be a non-const reference. </td></tr>
    <tr><td class="paramname">position</td><td>The location in target where this <a class="el" href="classstormm_1_1synthesis_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> pointer shall direct its own data array(s) </td></tr>
    <tr><td class="paramname">new_length</td><td>The new, maximum length of data that this pointer shall occupy. If left unset or set to a negative value, it will default to the remaining elements of the <a class="el" href="classstormm_1_1synthesis_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> array struct as it is currently found (target.size() - position). The pointer's maximum capacity will likewise be set to new_length, or if new_length is not set it will default to (target.capacity() - position). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a78e3f0516028238f5f3152836c89079a" name="a78e3f0516028238f5f3152836c89079a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78e3f0516028238f5f3152836c89079a">&#9670;&#160;</a></span>swapTarget()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstormm_1_1card_1_1Hybrid.html">stormm::card::Hybrid</a>&lt; T &gt;::swapTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>new_target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExceptionResponse</td>          <td class="paramname"><span class="paramname"><em>policy</em></span><span class="paramdefsep"> = </span><span class="paramdefval">ExceptionResponse::SILENT</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap the target of a POINTER-kind <a class="el" href="classstormm_1_1synthesis_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> object, transferring its starting index and current length to apply instead to the new target. Bounds checks will still be applied. Not valid for ARRAY-kind <a class="el" href="classstormm_1_1synthesis_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> objects or for POINTER-kind objects that have no current target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Pointer to the new <a class="el" href="classstormm_1_1synthesis_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> object to point into. This is a pointer because otherwise it would have to be a non-const reference. </td></tr>
    <tr><td class="paramname">policy</td><td>Indicate different actions to take if the <a class="el" href="classstormm_1_1synthesis_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> object does not yet point to any target. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/Accelerator/<a class="el" href="hybrid_8h_source.html">hybrid.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2
</small></address>
</div><!-- doc-content -->
</body>
</html>
