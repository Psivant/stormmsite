<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>STORMM Source Documentation: stormm::energy::PMIGrid Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">STORMM Source Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>stormm</b></li><li class="navelem"><b>energy</b></li><li class="navelem"><a class="el" href="classstormm_1_1energy_1_1PMIGrid.html">PMIGrid</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classstormm_1_1energy_1_1PMIGrid-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">stormm::energy::PMIGrid Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>An object to hold a series of meshes for accumulating density from condensed-phase molecular systems and transforming it into potential, whether for charges and electrostatics or dispersion sources and van-der Waals interactions. This supports the particle-mesh interactions (PMI) of the particle-particle / particle-mesh potential partitioning common in several simulation techniques.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="pmigrid_8h_source.html">pmigrid.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a13d56abb2932c061df21778e5247b038" id="r_a13d56abb2932c061df21778e5247b038"><td class="memItemLeft" align="right" valign="top"><a id="a13d56abb2932c061df21778e5247b038" name="a13d56abb2932c061df21778e5247b038"></a>
NonbondedTheme&#160;</td><td class="memItemRight" valign="bottom"><b>getTheme</b> () const</td></tr>
<tr class="memdesc:a13d56abb2932c061df21778e5247b038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the non-bonded propery mapped onto the particle-mesh interaction grid. <br /></td></tr>
<tr class="separator:a13d56abb2932c061df21778e5247b038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a6f71e368975469f75a320406c3acb" id="r_ac1a6f71e368975469f75a320406c3acb"><td class="memItemLeft" align="right" valign="top"><a id="ac1a6f71e368975469f75a320406c3acb" name="ac1a6f71e368975469f75a320406c3acb"></a>
PrecisionModel&#160;</td><td class="memItemRight" valign="bottom"><b>getMode</b> () const</td></tr>
<tr class="memdesc:ac1a6f71e368975469f75a320406c3acb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the mode in which the object is set to operate. <br /></td></tr>
<tr class="separator:ac1a6f71e368975469f75a320406c3acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a908f69e8b1a5ebbbcc277f5bb0e0ba6c" id="r_a908f69e8b1a5ebbbcc277f5bb0e0ba6c"><td class="memItemLeft" align="right" valign="top"><a id="a908f69e8b1a5ebbbcc277f5bb0e0ba6c" name="a908f69e8b1a5ebbbcc277f5bb0e0ba6c"></a>
FFTMode&#160;</td><td class="memItemRight" valign="bottom"><b>getFFTStaging</b> () const</td></tr>
<tr class="memdesc:a908f69e8b1a5ebbbcc277f5bb0e0ba6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the method for performing real-to-complex and complex-to-real FFTs. This implies how the grid data itself may be padded. <br /></td></tr>
<tr class="separator:a908f69e8b1a5ebbbcc277f5bb0e0ba6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a874f9870d891ecd5f376daad78d10de2" id="r_a874f9870d891ecd5f376daad78d10de2"><td class="memItemLeft" align="right" valign="top"><a id="a874f9870d891ecd5f376daad78d10de2" name="a874f9870d891ecd5f376daad78d10de2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>fixedPrecisionEnabled</b> () const</td></tr>
<tr class="memdesc:a874f9870d891ecd5f376daad78d10de2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate whether fixed-precision accumulation is enabled. This will test whether fp_accumulation_bits is greater than zero. <br /></td></tr>
<tr class="separator:a874f9870d891ecd5f376daad78d10de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f55042ea1cc7f84eceb879d2efc9ae3" id="r_a3f55042ea1cc7f84eceb879d2efc9ae3"><td class="memItemLeft" align="right" valign="top"><a id="a3f55042ea1cc7f84eceb879d2efc9ae3" name="a3f55042ea1cc7f84eceb879d2efc9ae3"></a>
QMapMethod&#160;</td><td class="memItemRight" valign="bottom"><b>getRecommendedMappingMethod</b> () const</td></tr>
<tr class="memdesc:a3f55042ea1cc7f84eceb879d2efc9ae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the recommended density mapping method for the current set of grids. <br /></td></tr>
<tr class="separator:a3f55042ea1cc7f84eceb879d2efc9ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c69e4d8ea192637418ec634d5f36cad" id="r_a6c69e4d8ea192637418ec634d5f36cad"><td class="memItemLeft" align="right" valign="top"><a id="a6c69e4d8ea192637418ec634d5f36cad" name="a6c69e4d8ea192637418ec634d5f36cad"></a>
QMapMethod&#160;</td><td class="memItemRight" valign="bottom"><b>getWorkUnitConfiguration</b> () const</td></tr>
<tr class="memdesc:a6c69e4d8ea192637418ec634d5f36cad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the work unit configuration of the object. <br /></td></tr>
<tr class="separator:a6c69e4d8ea192637418ec634d5f36cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c23199bdf59ec89a64a88fef1939df" id="r_a80c23199bdf59ec89a64a88fef1939df"><td class="memItemLeft" align="right" valign="top"><a id="a80c23199bdf59ec89a64a88fef1939df" name="a80c23199bdf59ec89a64a88fef1939df"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>dataIsReal</b> () const</td></tr>
<tr class="memdesc:a80c23199bdf59ec89a64a88fef1939df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate whether the data is present as real numbers or fixed-precision accumulators. Even with fixed-precision enabled, this object may hold data as real numbers for non-accumulating tasks. <br /></td></tr>
<tr class="separator:a80c23199bdf59ec89a64a88fef1939df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a047e1f465127046253ea665883d70554" id="r_a047e1f465127046253ea665883d70554"><td class="memItemLeft" align="right" valign="top"><a id="a047e1f465127046253ea665883d70554" name="a047e1f465127046253ea665883d70554"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getFixedPrecisionBits</b> () const</td></tr>
<tr class="memdesc:a047e1f465127046253ea665883d70554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of bits used in scaling numbers for fixed precision accumulation. <br /></td></tr>
<tr class="separator:a047e1f465127046253ea665883d70554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a331355407c3ba571294ec9531527d799" id="r_a331355407c3ba571294ec9531527d799"><td class="memItemLeft" align="right" valign="top"><a id="a331355407c3ba571294ec9531527d799" name="a331355407c3ba571294ec9531527d799"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getSharedFixedPrecisionBits</b> () const</td></tr>
<tr class="memdesc:a331355407c3ba571294ec9531527d799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of bits used in scaling numbers for fixed precision accumulation in <b>shared</b> accumulation density mapping kernels. <br /></td></tr>
<tr class="separator:a331355407c3ba571294ec9531527d799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2599391b860242bed5b1e307c20aa3f" id="r_ad2599391b860242bed5b1e307c20aa3f"><td class="memItemLeft" align="right" valign="top"><a id="ad2599391b860242bed5b1e307c20aa3f" name="ad2599391b860242bed5b1e307c20aa3f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getSystemCount</b> () const</td></tr>
<tr class="memdesc:ad2599391b860242bed5b1e307c20aa3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of systems with grid managed by this object. <br /></td></tr>
<tr class="separator:ad2599391b860242bed5b1e307c20aa3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0283e21dd57b02efbf9a62ac4722da4f" id="r_a0283e21dd57b02efbf9a62ac4722da4f"><td class="memItemLeft" align="right" valign="top"><a id="a0283e21dd57b02efbf9a62ac4722da4f" name="a0283e21dd57b02efbf9a62ac4722da4f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getInterpolationOrder</b> () const</td></tr>
<tr class="memdesc:a0283e21dd57b02efbf9a62ac4722da4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the interpolation order to be used in mapping particle density to the particle-mesh interaction grid. <br /></td></tr>
<tr class="separator:a0283e21dd57b02efbf9a62ac4722da4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a93d39acf21947eff862d4d90bfe5f" id="r_af2a93d39acf21947eff862d4d90bfe5f"><td class="memItemLeft" align="right" valign="top"><a id="af2a93d39acf21947eff862d4d90bfe5f" name="af2a93d39acf21947eff862d4d90bfe5f"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>getTotalCapacity</b> () const</td></tr>
<tr class="memdesc:af2a93d39acf21947eff862d4d90bfe5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total capacity allocated to store grid data. <br /></td></tr>
<tr class="separator:af2a93d39acf21947eff862d4d90bfe5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e7e08d4b0f320908ffc3c1f065127b5" id="r_a4e7e08d4b0f320908ffc3c1f065127b5"><td class="memItemLeft" align="right" valign="top"><a id="a4e7e08d4b0f320908ffc3c1f065127b5" name="a4e7e08d4b0f320908ffc3c1f065127b5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getWorkUnitCount</b> () const</td></tr>
<tr class="memdesc:a4e7e08d4b0f320908ffc3c1f065127b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of work units used by the optimized kernel. <br /></td></tr>
<tr class="separator:a4e7e08d4b0f320908ffc3c1f065127b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac437a8c4b4b3926162ba585a37a8e4ee" id="r_ac437a8c4b4b3926162ba585a37a8e4ee"><td class="memItemLeft" align="right" valign="top"><a id="ac437a8c4b4b3926162ba585a37a8e4ee" name="ac437a8c4b4b3926162ba585a37a8e4ee"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getLargestWorkUnitGridPoints</b> () const</td></tr>
<tr class="memdesc:ac437a8c4b4b3926162ba585a37a8e4ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report the number of grid points present in the largest work unit. <br /></td></tr>
<tr class="separator:ac437a8c4b4b3926162ba585a37a8e4ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85657f17724564a70b1fb80ae04d377" id="r_ab85657f17724564a70b1fb80ae04d377"><td class="memItemLeft" align="right" valign="top"><a id="ab85657f17724564a70b1fb80ae04d377" name="ab85657f17724564a70b1fb80ae04d377"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>shortFormatAccumulation</b> () const</td></tr>
<tr class="memdesc:ab85657f17724564a70b1fb80ae04d377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report whether the <a class="el" href="classstormm_1_1energy_1_1PMIGrid.html" title="An object to hold a series of meshes for accumulating density from condensed-phase molecular systems ...">PMIGrid</a> will use short format accumulation. <br /></td></tr>
<tr class="separator:ab85657f17724564a70b1fb80ae04d377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5b94f040c34d51facd1a94057d573c" id="r_a7c5b94f040c34d51facd1a94057d573c"><td class="memItemLeft" align="right" valign="top"><a id="a7c5b94f040c34d51facd1a94057d573c" name="a7c5b94f040c34d51facd1a94057d573c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>useOverflowAccumulation</b> () const</td></tr>
<tr class="memdesc:a7c5b94f040c34d51facd1a94057d573c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report whether the <a class="el" href="classstormm_1_1energy_1_1PMIGrid.html" title="An object to hold a series of meshes for accumulating density from condensed-phase molecular systems ...">PMIGrid</a> will need to use overflow accumulators. <br /></td></tr>
<tr class="separator:a7c5b94f040c34d51facd1a94057d573c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a522db3e41af0542e989c4ce745822663" id="r_a522db3e41af0542e989c4ce745822663"><td class="memTemplParams" colspan="2"><a id="a522db3e41af0542e989c4ce745822663" name="a522db3e41af0542e989c4ce745822663"></a>
template&lt;typename T, typename Tacc, typename Tcalc, typename T4&gt; </td></tr>
<tr class="memitem:a522db3e41af0542e989c4ce745822663"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classstormm_1_1energy_1_1CellGrid.html">CellGrid</a>&lt; T, Tacc, Tcalc, T4 &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getCellGridPointer</b> () const</td></tr>
<tr class="memdesc:a522db3e41af0542e989c4ce745822663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the pointer to the attached <a class="el" href="classstormm_1_1energy_1_1CellGrid.html" title="An object to manage the spatial decomposition of a system of particles. The general strategy is to ar...">CellGrid</a> object, which provides the basis for the grids / meshes contained in this object. This will restore the type of the object but must be invoked in a manner consistent with its original typing. <br /></td></tr>
<tr class="separator:a522db3e41af0542e989c4ce745822663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af202a0edbf916f775299a47a38bb53b6" id="r_af202a0edbf916f775299a47a38bb53b6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structstormm_1_1energy_1_1CellGridReader.html">CellGridReader</a>&lt; void, void, void, void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af202a0edbf916f775299a47a38bb53b6">getTemplateFreeCellGridReader</a> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:af202a0edbf916f775299a47a38bb53b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an abstract of the attached cell grid object, with all templating cast away. This exists because the templated types of the pointer stored in the <a class="el" href="classstormm_1_1energy_1_1PMIGrid.html" title="An object to hold a series of meshes for accumulating density from condensed-phase molecular systems ...">PMIGrid</a> object are placeholders for its true types. Out of an abundance of caution, a <a class="el" href="classstormm_1_1energy_1_1CellGrid.html" title="An object to manage the spatial decomposition of a system of particles. The general strategy is to ar...">CellGrid</a> pointer with the proper data types for all four components is created so that the <a class="el" href="classstormm_1_1energy_1_1CellGrid.html" title="An object to manage the spatial decomposition of a system of particles. The general strategy is to ar...">CellGrid</a>'s public member function templateFreeData() can be invoked.  <br /></td></tr>
<tr class="separator:af202a0edbf916f775299a47a38bb53b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d178527143c84498f7605d1f4497aa3" id="r_a9d178527143c84498f7605d1f4497aa3"><td class="memItemLeft" align="right" valign="top"><a id="a9d178527143c84498f7605d1f4497aa3" name="a9d178527143c84498f7605d1f4497aa3"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>getCellGridMatrixTypeID</b> () const</td></tr>
<tr class="memdesc:a9d178527143c84498f7605d1f4497aa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type ID of the attached <a class="el" href="classstormm_1_1energy_1_1CellGrid.html" title="An object to manage the spatial decomposition of a system of particles. The general strategy is to ar...">CellGrid</a> object's cell dimension matrix expressions. This is the "typename T" seen in many <a class="el" href="classstormm_1_1energy_1_1CellGrid.html" title="An object to manage the spatial decomposition of a system of particles. The general strategy is to ar...">CellGrid</a> class function declarations, and the root data type of the four-tuples in which its coordinates are expressed. Possible types include float, double, int, and llint. <br /></td></tr>
<tr class="separator:a9d178527143c84498f7605d1f4497aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad41622f6a99a1a072d014d481755983a" id="r_ad41622f6a99a1a072d014d481755983a"><td class="memItemLeft" align="right" valign="top"><a id="ad41622f6a99a1a072d014d481755983a" name="ad41622f6a99a1a072d014d481755983a"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>getCellGridAccumulatorTypeID</b> () const</td></tr>
<tr class="memdesc:ad41622f6a99a1a072d014d481755983a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type ID of the attached <a class="el" href="classstormm_1_1energy_1_1CellGrid.html" title="An object to manage the spatial decomposition of a system of particles. The general strategy is to ar...">CellGrid</a> object's accumulators. This is "typename
       Tacc" in various <a class="el" href="classstormm_1_1energy_1_1CellGrid.html" title="An object to manage the spatial decomposition of a system of particles. The general strategy is to ar...">CellGrid</a> class function declarations and invocations. Acceptable types include int and llint. <br /></td></tr>
<tr class="separator:ad41622f6a99a1a072d014d481755983a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7937ccd3c984bcef02e9ee4fd4cf92d5" id="r_a7937ccd3c984bcef02e9ee4fd4cf92d5"><td class="memItemLeft" align="right" valign="top"><a id="a7937ccd3c984bcef02e9ee4fd4cf92d5" name="a7937ccd3c984bcef02e9ee4fd4cf92d5"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>getCellGridCalculationTypeID</b> () const</td></tr>
<tr class="memdesc:a7937ccd3c984bcef02e9ee4fd4cf92d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type ID of the attached <a class="el" href="classstormm_1_1energy_1_1CellGrid.html" title="An object to manage the spatial decomposition of a system of particles. The general strategy is to ar...">CellGrid</a> object's fractional space coordinate transformations, which sets a precedent for any calculations that will be done with an object of the class. This is "typename Tcalc" in various <a class="el" href="classstormm_1_1energy_1_1CellGrid.html" title="An object to manage the spatial decomposition of a system of particles. The general strategy is to ar...">CellGrid</a> class function declarations and invocations. <br /></td></tr>
<tr class="separator:a7937ccd3c984bcef02e9ee4fd4cf92d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba6aabe226d8552746f7144c8b68456e" id="r_aba6aabe226d8552746f7144c8b68456e"><td class="memItemLeft" align="right" valign="top"><a id="aba6aabe226d8552746f7144c8b68456e" name="aba6aabe226d8552746f7144c8b68456e"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>getCellGridCoordinateTypeID</b> () const</td></tr>
<tr class="memdesc:aba6aabe226d8552746f7144c8b68456e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type ID of the attached <a class="el" href="classstormm_1_1energy_1_1CellGrid.html" title="An object to manage the spatial decomposition of a system of particles. The general strategy is to ar...">CellGrid</a> object's coordinate data, a four-tuple of its cell dimension matrix data. Acceptable types include float, double, int, and llint. This is "typename T4" in most CellGrid-associated function declarations and invocations, sometimes "typename Tcrd". <br /></td></tr>
<tr class="separator:aba6aabe226d8552746f7144c8b68456e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ab5cb0e3bc2be0e3caab8b1480529e" id="r_ad6ab5cb0e3bc2be0e3caab8b1480529e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6ab5cb0e3bc2be0e3caab8b1480529e">getTotalOnGrid</a> (int system_index) const</td></tr>
<tr class="memdesc:ad6ab5cb0e3bc2be0e3caab8b1480529e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total substance, particle density, mapped to all grid elements for a particular system.  <br /></td></tr>
<tr class="separator:ad6ab5cb0e3bc2be0e3caab8b1480529e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f0f5e99042da0bcd27fd88f9b9ac24c" id="r_a8f0f5e99042da0bcd27fd88f9b9ac24c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f0f5e99042da0bcd27fd88f9b9ac24c">getGrid</a> (int system_index) const</td></tr>
<tr class="memdesc:a8f0f5e99042da0bcd27fd88f9b9ac24c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export the particle-mesh interaction grid asssociated with one system in the synthesis. The resulting linearized data reflects an ordering of the grid that is identical to the way it appears in the <a class="el" href="classstormm_1_1energy_1_1PMIGrid.html" title="An object to hold a series of meshes for accumulating density from condensed-phase molecular systems ...">PMIGrid</a> itself.  <br /></td></tr>
<tr class="separator:a8f0f5e99042da0bcd27fd88f9b9ac24c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae1762e0d1e0021d2b938c3f42cac49" id="r_a9ae1762e0d1e0021d2b938c3f42cac49"><td class="memItemLeft" align="right" valign="top"><a id="a9ae1762e0d1e0021d2b938c3f42cac49" name="a9ae1762e0d1e0021d2b938c3f42cac49"></a>
const <a class="el" href="classstormm_1_1synthesis_1_1PhaseSpaceSynthesis.html">PhaseSpaceSynthesis</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getCoordinateSynthesisPointer</b> () const</td></tr>
<tr class="memdesc:a9ae1762e0d1e0021d2b938c3f42cac49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the underlying coordinate synthesis. <br /></td></tr>
<tr class="separator:a9ae1762e0d1e0021d2b938c3f42cac49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2deb958abeac3d3ba26b73cbc0a12d62" id="r_a2deb958abeac3d3ba26b73cbc0a12d62"><td class="memItemLeft" align="right" valign="top"><a id="a2deb958abeac3d3ba26b73cbc0a12d62" name="a2deb958abeac3d3ba26b73cbc0a12d62"></a>
const <a class="el" href="classstormm_1_1synthesis_1_1AtomGraphSynthesis.html">AtomGraphSynthesis</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getTopologySynthesisPointer</b> () const</td></tr>
<tr class="memdesc:a2deb958abeac3d3ba26b73cbc0a12d62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the underlying topology synthesis. <br /></td></tr>
<tr class="separator:a2deb958abeac3d3ba26b73cbc0a12d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f2352f56b754616ec93ce2136b7952d" id="r_a3f2352f56b754616ec93ce2136b7952d"><td class="memItemLeft" align="right" valign="top"><a id="a3f2352f56b754616ec93ce2136b7952d" name="a3f2352f56b754616ec93ce2136b7952d"></a>
const <a class="el" href="classstormm_1_1energy_1_1PMIGrid.html">PMIGrid</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getSelfPointer</b> () const</td></tr>
<tr class="memdesc:a3f2352f56b754616ec93ce2136b7952d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the <a class="el" href="classstormm_1_1energy_1_1PMIGrid.html" title="An object to hold a series of meshes for accumulating density from condensed-phase molecular systems ...">PMIGrid</a> object itself. <br /></td></tr>
<tr class="separator:a3f2352f56b754616ec93ce2136b7952d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a271b07c72bcba773b5ed48abdaa71c31" id="r_a271b07c72bcba773b5ed48abdaa71c31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a271b07c72bcba773b5ed48abdaa71c31">setMode</a> (PrecisionModel mode_in)</td></tr>
<tr class="memdesc:a271b07c72bcba773b5ed48abdaa71c31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the mode in which the object is set to operate. This will leave bounds arrays unchanged but blow away data as the object is reconfigured.  <br /></td></tr>
<tr class="separator:a271b07c72bcba773b5ed48abdaa71c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f172d1890a44bce36a935c4badc485" id="r_ae2f172d1890a44bce36a935c4badc485"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2f172d1890a44bce36a935c4badc485">setRealDataFormat</a> (bool real_in=true)</td></tr>
<tr class="memdesc:ae2f172d1890a44bce36a935c4badc485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the character of the data format. If called with TRUE the object will report holding real-valued data.  <br /></td></tr>
<tr class="separator:ae2f172d1890a44bce36a935c4badc485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a331bcd6a1e890d146c27a991e59eb76f" id="r_a331bcd6a1e890d146c27a991e59eb76f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a331bcd6a1e890d146c27a991e59eb76f">prepareFixedPrecisionModel</a> (int fp_accumulation_bits_in, int shared_fp_bits_in)</td></tr>
<tr class="memdesc:a331bcd6a1e890d146c27a991e59eb76f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the object to enable or disable fixed-precision accumulation.  <br /></td></tr>
<tr class="separator:a331bcd6a1e890d146c27a991e59eb76f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86823ff269987252527444257eed6667" id="r_a86823ff269987252527444257eed6667"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86823ff269987252527444257eed6667">setRecommendedMappingMethod</a> (const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;gpu)</td></tr>
<tr class="memdesc:a86823ff269987252527444257eed6667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the recommended mapping method based on the density of the grid and available resources.  <br /></td></tr>
<tr class="separator:a86823ff269987252527444257eed6667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f9c85a6047e6f70490276d291fe9eb" id="r_ae0f9c85a6047e6f70490276d291fe9eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0f9c85a6047e6f70490276d291fe9eb">initialize</a> (HybridTargetLevel tier=HybridTargetLevel::HOST, const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;gpu=null_gpu)</td></tr>
<tr class="memdesc:ae0f9c85a6047e6f70490276d291fe9eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the particle-mesh interaction grids, respecting the object's precision and accumulation modes. If fixed-precision is enabled, this will set the data content to register as no longer "real numbers" (not imaginary numbers, but integers).  <br /></td></tr>
<tr class="separator:ae0f9c85a6047e6f70490276d291fe9eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd2f29c2f4daa5fe28b305dffe80d5c" id="r_a5fd2f29c2f4daa5fe28b305dffe80d5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5fd2f29c2f4daa5fe28b305dffe80d5c">convertToReal</a> (HybridTargetLevel tier=HybridTargetLevel::HOST, const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;gpu=null_gpu)</td></tr>
<tr class="memdesc:a5fd2f29c2f4daa5fe28b305dffe80d5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert fixed-precision integer data in the object to real data. There is no function to convert real back to fixed-precision integer data: the process is to accumulate in the one mode and then convert to the other when finished.  <br /></td></tr>
<tr class="separator:a5fd2f29c2f4daa5fe28b305dffe80d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a70c265d502b4bc97cd95bf1b393bd98c" id="r_a70c265d502b4bc97cd95bf1b393bd98c"><td class="memTemplParams" colspan="2"><a id="a70c265d502b4bc97cd95bf1b393bd98c" name="a70c265d502b4bc97cd95bf1b393bd98c"></a>
template&lt;typename T, typename Tacc, typename Tcalc, typename T4&gt; </td></tr>
<tr class="memitem:a70c265d502b4bc97cd95bf1b393bd98c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PMIGrid</b> (const <a class="el" href="classstormm_1_1energy_1_1CellGrid.html">CellGrid</a>&lt; T, Tacc, Tcalc, T4 &gt; *cg_in, NonbondedTheme theme_in, int b_spline_order_in=default_bspline_order, PrecisionModel mode_in=PrecisionModel::SINGLE, FFTMode fft_staging_in=FFTMode::IN_PLACE, int fp_accumulation_bits_in=0, int shared_fp_accumulation_bits_in=-1, const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;gpu=null_gpu, const QMapMethod work_unit_configuration_in=QMapMethod::GENERAL_PURPOSE)</td></tr>
<tr class="memdesc:a70c265d502b4bc97cd95bf1b393bd98c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructor builds the object off of a <a class="el" href="classstormm_1_1energy_1_1CellGrid.html" title="An object to manage the spatial decomposition of a system of particles. The general strategy is to ar...">CellGrid</a> object, which is in turn linked to a particular coordinate synthesis (<a class="el" href="classstormm_1_1energy_1_1PhaseSpaceSynthesis.html" title="A fixed-precision representation of coordinates, velocities, and forces to manage a set of simulation...">PhaseSpaceSynthesis</a>). <br /></td></tr>
<tr class="separator:a70c265d502b4bc97cd95bf1b393bd98c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9772c0bf16b1c454d7fbcc5e5a5dff7" id="r_ab9772c0bf16b1c454d7fbcc5e5a5dff7"><td class="memTemplParams" colspan="2"><a id="ab9772c0bf16b1c454d7fbcc5e5a5dff7" name="ab9772c0bf16b1c454d7fbcc5e5a5dff7"></a>
template&lt;typename T, typename Tacc, typename Tcalc, typename T4&gt; </td></tr>
<tr class="memitem:ab9772c0bf16b1c454d7fbcc5e5a5dff7"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PMIGrid</b> (const <a class="el" href="classstormm_1_1energy_1_1CellGrid.html">CellGrid</a>&lt; T, Tacc, Tcalc, T4 &gt; &amp;cg_in, NonbondedTheme theme_in, int b_spline_order_in=default_bspline_order, PrecisionModel mode_in=PrecisionModel::SINGLE, FFTMode fft_staging_in=FFTMode::IN_PLACE, int fp_accumulation_bits_in=0, int shared_fp_accumulation_bits_in=-1, const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;gpu=null_gpu, const QMapMethod work_unit_configuration_in=QMapMethod::GENERAL_PURPOSE)</td></tr>
<tr class="separator:ab9772c0bf16b1c454d7fbcc5e5a5dff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae0b98199fa441662cb3bfa340b50826e" id="r_ae0b98199fa441662cb3bfa340b50826e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0b98199fa441662cb3bfa340b50826e">PMIGrid</a> (const <a class="el" href="classstormm_1_1energy_1_1PMIGrid.html">PMIGrid</a> &amp;original)=default</td></tr>
<tr class="memdesc:ae0b98199fa441662cb3bfa340b50826e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The choice to re-cast arrays in the abstracts rather than have special POINTER-kind <a class="el" href="classstormm_1_1energy_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> objects in the <a class="el" href="classstormm_1_1energy_1_1PMIGrid.html" title="An object to hold a series of meshes for accumulating density from condensed-phase molecular systems ...">PMIGrid</a> itself allows the default copy and move constructors, as well as the copy and move assignment operators, to remain valid.  <br /></td></tr>
<tr class="separator:ae0b98199fa441662cb3bfa340b50826e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4140e82542339c01ef1a155bfaa1fe53" id="r_a4140e82542339c01ef1a155bfaa1fe53"><td class="memItemLeft" align="right" valign="top"><a id="a4140e82542339c01ef1a155bfaa1fe53" name="a4140e82542339c01ef1a155bfaa1fe53"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PMIGrid</b> (<a class="el" href="classstormm_1_1energy_1_1PMIGrid.html">PMIGrid</a> &amp;&amp;original)=default</td></tr>
<tr class="separator:a4140e82542339c01ef1a155bfaa1fe53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17bf201fab8333bf0a236d1c9f6b9343" id="r_a17bf201fab8333bf0a236d1c9f6b9343"><td class="memItemLeft" align="right" valign="top"><a id="a17bf201fab8333bf0a236d1c9f6b9343" name="a17bf201fab8333bf0a236d1c9f6b9343"></a>
<a class="el" href="classstormm_1_1energy_1_1PMIGrid.html">PMIGrid</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classstormm_1_1energy_1_1PMIGrid.html">PMIGrid</a> &amp;original)=default</td></tr>
<tr class="separator:a17bf201fab8333bf0a236d1c9f6b9343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ece9435c08e5ccdc7f8eb343ca461b1" id="r_a7ece9435c08e5ccdc7f8eb343ca461b1"><td class="memItemLeft" align="right" valign="top"><a id="a7ece9435c08e5ccdc7f8eb343ca461b1" name="a7ece9435c08e5ccdc7f8eb343ca461b1"></a>
<a class="el" href="classstormm_1_1energy_1_1PMIGrid.html">PMIGrid</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classstormm_1_1energy_1_1PMIGrid.html">PMIGrid</a> &amp;&amp;original)=default</td></tr>
<tr class="separator:a7ece9435c08e5ccdc7f8eb343ca461b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:adbe1a10a1a8fbe8512e627ec5a7bde34" id="r_adbe1a10a1a8fbe8512e627ec5a7bde34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstormm_1_1data__types_1_1uint4.html">uint4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adbe1a10a1a8fbe8512e627ec5a7bde34">getGridDimensions</a> (int system_index) const</td></tr>
<tr class="memdesc:adbe1a10a1a8fbe8512e627ec5a7bde34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the dimensions of one of the grids in the object.  <br /></td></tr>
<tr class="separator:adbe1a10a1a8fbe8512e627ec5a7bde34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa92fe5f6f3b6954302a1bb5108d0d122" id="r_aa92fe5f6f3b6954302a1bb5108d0d122"><td class="memItemLeft" align="right" valign="top"><a id="aa92fe5f6f3b6954302a1bb5108d0d122" name="aa92fe5f6f3b6954302a1bb5108d0d122"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getGridDimensions</b> (int system_index, UnitCellAxis uc_axis) const</td></tr>
<tr class="separator:aa92fe5f6f3b6954302a1bb5108d0d122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e2f7b4d6b9d8a8fd86e390817040a8" id="r_ac8e2f7b4d6b9d8a8fd86e390817040a8"><td class="memItemLeft" align="right" valign="top"><a id="ac8e2f7b4d6b9d8a8fd86e390817040a8" name="ac8e2f7b4d6b9d8a8fd86e390817040a8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getGridDimensions</b> (int system_index, CartesianDimension uc_axis) const</td></tr>
<tr class="separator:ac8e2f7b4d6b9d8a8fd86e390817040a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a56c44e5afbfa36da3910a5911f290071" id="r_a56c44e5afbfa36da3910a5911f290071"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstormm_1_1energy_1_1PMIGridWriter.html">PMIGridWriter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56c44e5afbfa36da3910a5911f290071">data</a> (HybridTargetLevel tier=HybridTargetLevel::HOST)</td></tr>
<tr class="memdesc:a56c44e5afbfa36da3910a5911f290071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the abstract for this object containing its precision mode, grid dimensions, and pointers to relevant data arrays.  <br /></td></tr>
<tr class="separator:a56c44e5afbfa36da3910a5911f290071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ca193c81560b1a5f15b1c98ee58e463" id="r_a5ca193c81560b1a5f15b1c98ee58e463"><td class="memItemLeft" align="right" valign="top"><a id="a5ca193c81560b1a5f15b1c98ee58e463" name="a5ca193c81560b1a5f15b1c98ee58e463"></a>
const <a class="el" href="structstormm_1_1energy_1_1PMIGridReader.html">PMIGridReader</a>&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="separator:a5ca193c81560b1a5f15b1c98ee58e463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a7011c2c3a5dacf13a0167fd84c6624b5" id="r_a7011c2c3a5dacf13a0167fd84c6624b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstormm_1_1energy_1_1PMIGridAccumulator.html">PMIGridAccumulator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7011c2c3a5dacf13a0167fd84c6624b5">fpData</a> (HybridTargetLevel tier=HybridTargetLevel::HOST)</td></tr>
<tr class="memdesc:a7011c2c3a5dacf13a0167fd84c6624b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the fixed-precision abstract for this object, re-interpreting either main data array and adding an integer array of overflow accumulators for accumulation protected against the non-associativity that breaks bitwise reproducibility for floating point parallel computations.  <br /></td></tr>
<tr class="separator:a7011c2c3a5dacf13a0167fd84c6624b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a507a665fec7b1d333f34014d454843f7" id="r_a507a665fec7b1d333f34014d454843f7"><td class="memItemLeft" align="right" valign="top"><a id="a507a665fec7b1d333f34014d454843f7" name="a507a665fec7b1d333f34014d454843f7"></a>
const <a class="el" href="structstormm_1_1energy_1_1PMIGridFPReader.html">PMIGridFPReader</a>&#160;</td><td class="memItemRight" valign="bottom"><b>fpData</b> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="separator:a507a665fec7b1d333f34014d454843f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6f2fa0211aa1347c72c9def65255c2a5" id="r_a6f2fa0211aa1347c72c9def65255c2a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f2fa0211aa1347c72c9def65255c2a5">prepareWorkUnits</a> (QMapMethod approach, const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;gpu)</td></tr>
<tr class="memdesc:a6f2fa0211aa1347c72c9def65255c2a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare a set of work units for the synthesis of systems. These work units will be tailored to the synthesis for which the topology was created, but can be changed given a new GPU.  <br /></td></tr>
<tr class="separator:a6f2fa0211aa1347c72c9def65255c2a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3ce2da6a79196e2cadc9870361b00b5" id="r_ac3ce2da6a79196e2cadc9870361b00b5"><td class="memItemLeft" align="right" valign="top"><a id="ac3ce2da6a79196e2cadc9870361b00b5" name="ac3ce2da6a79196e2cadc9870361b00b5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>prepareWorkUnits</b> (const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;gpu)</td></tr>
<tr class="separator:ac3ce2da6a79196e2cadc9870361b00b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An object to hold a series of meshes for accumulating density from condensed-phase molecular systems and transforming it into potential, whether for charges and electrostatics or dispersion sources and van-der Waals interactions. This supports the particle-mesh interactions (PMI) of the particle-particle / particle-mesh potential partitioning common in several simulation techniques. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae0b98199fa441662cb3bfa340b50826e" name="ae0b98199fa441662cb3bfa340b50826e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0b98199fa441662cb3bfa340b50826e">&#9670;&#160;</a></span>PMIGrid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">stormm::energy::PMIGrid::PMIGrid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstormm_1_1energy_1_1PMIGrid.html">PMIGrid</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>original</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The choice to re-cast arrays in the abstracts rather than have special POINTER-kind <a class="el" href="classstormm_1_1energy_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> objects in the <a class="el" href="classstormm_1_1energy_1_1PMIGrid.html" title="An object to hold a series of meshes for accumulating density from condensed-phase molecular systems ...">PMIGrid</a> itself allows the default copy and move constructors, as well as the copy and move assignment operators, to remain valid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">original</td><td>The original object to copy or move </td></tr>
    <tr><td class="paramname">other</td><td>Another object placed on the right hand side of the assignment statement </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5fd2f29c2f4daa5fe28b305dffe80d5c" name="a5fd2f29c2f4daa5fe28b305dffe80d5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fd2f29c2f4daa5fe28b305dffe80d5c">&#9670;&#160;</a></span>convertToReal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::energy::PMIGrid::convertToReal </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gpu</em></span><span class="paramdefsep"> = </span><span class="paramdefval">null_gpu</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert fixed-precision integer data in the object to real data. There is no function to convert real back to fixed-precision integer data: the process is to accumulate in the one mode and then convert to the other when finished. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tier</td><td>Indicate whether to initialize the density grids at the level of the CPU host or the GPU device </td></tr>
    <tr><td class="paramname">gpu</td><td>Details of the available GPU, if the initialization focuses on device memory </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56c44e5afbfa36da3910a5911f290071" name="a56c44e5afbfa36da3910a5911f290071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56c44e5afbfa36da3910a5911f290071">&#9670;&#160;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstormm_1_1energy_1_1PMIGridWriter.html">PMIGridWriter</a> stormm::energy::PMIGrid::data </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the abstract for this object containing its precision mode, grid dimensions, and pointers to relevant data arrays. </p>
<p>Overloaded:</p><ul>
<li>Get a writeable abstract from a mutable object.</li>
<li>Get a read-only abstract from a const object.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tier</td><td>Specify whether to obtain pointers on the CPU host or GPU device </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7011c2c3a5dacf13a0167fd84c6624b5" name="a7011c2c3a5dacf13a0167fd84c6624b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7011c2c3a5dacf13a0167fd84c6624b5">&#9670;&#160;</a></span>fpData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstormm_1_1energy_1_1PMIGridAccumulator.html">PMIGridAccumulator</a> stormm::energy::PMIGrid::fpData </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the fixed-precision abstract for this object, re-interpreting either main data array and adding an integer array of overflow accumulators for accumulation protected against the non-associativity that breaks bitwise reproducibility for floating point parallel computations. </p>
<p>Overloaded:</p><ul>
<li>Get a writeable abstract from a mutable object.</li>
<li>Get a read-only abstract from a const object.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tier</td><td>Specify whether to obtain pointers on the CPU host or GPU device </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f0f5e99042da0bcd27fd88f9b9ac24c" name="a8f0f5e99042da0bcd27fd88f9b9ac24c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f0f5e99042da0bcd27fd88f9b9ac24c">&#9670;&#160;</a></span>getGrid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; stormm::energy::PMIGrid::getGrid </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>system_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export the particle-mesh interaction grid asssociated with one system in the synthesis. The resulting linearized data reflects an ordering of the grid that is identical to the way it appears in the <a class="el" href="classstormm_1_1energy_1_1PMIGrid.html" title="An object to hold a series of meshes for accumulating density from condensed-phase molecular systems ...">PMIGrid</a> itself. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">system_index</td><td>The system of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adbe1a10a1a8fbe8512e627ec5a7bde34" name="adbe1a10a1a8fbe8512e627ec5a7bde34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbe1a10a1a8fbe8512e627ec5a7bde34">&#9670;&#160;</a></span>getGridDimensions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstormm_1_1data__types_1_1uint4.html">uint4</a> stormm::energy::PMIGrid::getGridDimensions </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>system_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the dimensions of one of the grids in the object. </p>
<p>Overloaded:</p><ul>
<li>Get all dimensions, including the offset in the data arrays, of one system's PMI grid</li>
<li>Get the dimension of one system's grid along a particular axis</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">system_index</td><td>Index of the system of interest within the associated synthesis </td></tr>
    <tr><td class="paramname">uc_axis</td><td>The unit cell axis of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af202a0edbf916f775299a47a38bb53b6" name="af202a0edbf916f775299a47a38bb53b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af202a0edbf916f775299a47a38bb53b6">&#9670;&#160;</a></span>getTemplateFreeCellGridReader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structstormm_1_1energy_1_1CellGridReader.html">CellGridReader</a>&lt; void, void, void, void &gt; stormm::energy::PMIGrid::getTemplateFreeCellGridReader </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an abstract of the attached cell grid object, with all templating cast away. This exists because the templated types of the pointer stored in the <a class="el" href="classstormm_1_1energy_1_1PMIGrid.html" title="An object to hold a series of meshes for accumulating density from condensed-phase molecular systems ...">PMIGrid</a> object are placeholders for its true types. Out of an abundance of caution, a <a class="el" href="classstormm_1_1energy_1_1CellGrid.html" title="An object to manage the spatial decomposition of a system of particles. The general strategy is to ar...">CellGrid</a> pointer with the proper data types for all four components is created so that the <a class="el" href="classstormm_1_1energy_1_1CellGrid.html" title="An object to manage the spatial decomposition of a system of particles. The general strategy is to ar...">CellGrid</a>'s public member function templateFreeData() can be invoked. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tier</td><td>Specify whether to obtain pointers, void-casted or otherwise, on the CPU host or GPU device </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad6ab5cb0e3bc2be0e3caab8b1480529e" name="ad6ab5cb0e3bc2be0e3caab8b1480529e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6ab5cb0e3bc2be0e3caab8b1480529e">&#9670;&#160;</a></span>getTotalOnGrid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stormm::energy::PMIGrid::getTotalOnGrid </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>system_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the total substance, particle density, mapped to all grid elements for a particular system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">system_index</td><td>The system of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0f9c85a6047e6f70490276d291fe9eb" name="ae0f9c85a6047e6f70490276d291fe9eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0f9c85a6047e6f70490276d291fe9eb">&#9670;&#160;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::energy::PMIGrid::initialize </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gpu</em></span><span class="paramdefsep"> = </span><span class="paramdefval">null_gpu</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the particle-mesh interaction grids, respecting the object's precision and accumulation modes. If fixed-precision is enabled, this will set the data content to register as no longer "real numbers" (not imaginary numbers, but integers). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tier</td><td>Indicate whether to initialize the density grids at the level of the CPU host or the GPU device </td></tr>
    <tr><td class="paramname">gpu</td><td>Details of the available GPU, if the initialization focuses on device memory </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a331bcd6a1e890d146c27a991e59eb76f" name="a331bcd6a1e890d146c27a991e59eb76f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a331bcd6a1e890d146c27a991e59eb76f">&#9670;&#160;</a></span>prepareFixedPrecisionModel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::energy::PMIGrid::prepareFixedPrecisionModel </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>fp_accumulation_bits_in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>shared_fp_bits_in</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the object to enable or disable fixed-precision accumulation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp_accumulation_bits_in</td><td>The number of bits used in fixed-precision accumulation, indicating the power of two by which to scale numbers going int each sum </td></tr>
    <tr><td class="paramname">shared_fp_bits_in</td><td>The number of bits used in fixed-precision accumulation with a separate space in <b>shared</b> memory. While this will be set to be consistent with fp_accumulation_bits_in if possible, there is a critical difference: this accumulation is done in the interest of going directly to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f2fa0211aa1347c72c9def65255c2a5" name="a6f2fa0211aa1347c72c9def65255c2a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f2fa0211aa1347c72c9def65255c2a5">&#9670;&#160;</a></span>prepareWorkUnits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::energy::PMIGrid::prepareWorkUnits </td>
          <td>(</td>
          <td class="paramtype">QMapMethod</td>          <td class="paramname"><span class="paramname"><em>approach</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gpu</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepare a set of work units for the synthesis of systems. These work units will be tailored to the synthesis for which the topology was created, but can be changed given a new GPU. </p>
<p>Overloaded:</p><ul>
<li>Tailor work units to a chosen a mapping method</li>
<li>Tailor work units to the recommended mapping method</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">approach</td><td>The chosen work unit mapping method (if the grid density or parameters do do not comport with the method, an alternative will be selected) </td></tr>
    <tr><td class="paramname">gpu</td><td>Details of the available GPU </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a271b07c72bcba773b5ed48abdaa71c31" name="a271b07c72bcba773b5ed48abdaa71c31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a271b07c72bcba773b5ed48abdaa71c31">&#9670;&#160;</a></span>setMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::energy::PMIGrid::setMode </td>
          <td>(</td>
          <td class="paramtype">PrecisionModel</td>          <td class="paramname"><span class="paramname"><em>mode_in</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the mode in which the object is set to operate. This will leave bounds arrays unchanged but blow away data as the object is reconfigured. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode_in</td><td>The chosen mode for the object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2f172d1890a44bce36a935c4badc485" name="ae2f172d1890a44bce36a935c4badc485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2f172d1890a44bce36a935c4badc485">&#9670;&#160;</a></span>setRealDataFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::energy::PMIGrid::setRealDataFormat </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>real_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the character of the data format. If called with TRUE the object will report holding real-valued data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">real_in</td><td>Specify whether the object holds real (TRUE) or fixed-precision data (FALSE) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86823ff269987252527444257eed6667" name="a86823ff269987252527444257eed6667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86823ff269987252527444257eed6667">&#9670;&#160;</a></span>setRecommendedMappingMethod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::energy::PMIGrid::setRecommendedMappingMethod </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gpu</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the recommended mapping method based on the density of the grid and available resources. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu</td><td>Specifications of the GPU that will perform the work </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/Potential/<a class="el" href="pmigrid_8h_source.html">pmigrid.h</a></li>
<li>src/Potential/<b>pmigrid.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2
</small></address>
</div><!-- doc-content -->
</body>
</html>
