<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>STORMM Source Documentation: stormm::energy::ValenceWorkUnit Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">STORMM Source Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>stormm</b></li><li class="navelem"><b>energy</b></li><li class="navelem"><a class="el" href="classstormm_1_1energy_1_1ValenceWorkUnit.html">ValenceWorkUnit</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classstormm_1_1energy_1_1ValenceWorkUnit-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">stormm::energy::ValenceWorkUnit Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>An object to collect the components of a valence work unit (which will also track frozen atoms to implement coordinate updates, velocity updates, and constraints). While the work unit is encoded in the <a class="el" href="classstormm_1_1energy_1_1AtomGraphSynthesis.html" title="A collection of one or more AtomGraph objects, with similar components arranged in contiguous arrays ...">AtomGraphSynthesis</a> object, the assembly is best done by a dedicated object with plenty of its own methods operating on a single topology (<a class="el" href="classstormm_1_1energy_1_1AtomGraph.html" title="A struct to hold information relating to an Amber topology. This struct&#39;s member functions are limite...">AtomGraph</a>). All systems in the <a class="el" href="classstormm_1_1energy_1_1AtomGraphSynthesis.html" title="A collection of one or more AtomGraph objects, with similar components arranged in contiguous arrays ...">AtomGraphSynthesis</a> are designed to function independently of one another&ndash;the only difference is that they have consensus tables of most parameters and differen atom indexing. Translating a valence work unit into a list of instructions within an <a class="el" href="classstormm_1_1energy_1_1AtomGraphSynthesis.html" title="A collection of one or more AtomGraph objects, with similar components arranged in contiguous arrays ...">AtomGraphSynthesis</a> is therefore a critical member function of this class.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="valence__workunit_8h_source.html">valence_workunit.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a80a906bc59321fd06438edb9cfd8eeab" id="r_a80a906bc59321fd06438edb9cfd8eeab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80a906bc59321fd06438edb9cfd8eeab">ValenceWorkUnit</a> (ValenceDelegator *vdel_in, std::vector&lt; int &gt; *tvwu_coverage, int list_index_in, int seed_atom_in, int max_atoms_in=maximum_valence_work_unit_atoms)</td></tr>
<tr class="memdesc:a80a906bc59321fd06438edb9cfd8eeab"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructor takes a specific input topology (multiple systems using the same topology in an <a class="el" href="classstormm_1_1energy_1_1AtomGraphSynthesis.html" title="A collection of one or more AtomGraph objects, with similar components arranged in contiguous arrays ...">AtomGraphSynthesis</a> can thereby take the same valence work unit and translate the atom indices as appropriate rather than regenerating the work unit for many equivalent systems). Mapping starts from a specific atom and proceeds until a maximum number of atoms has been accumulated in order to process as many related valence terms as possible.  <br /></td></tr>
<tr class="separator:a80a906bc59321fd06438edb9cfd8eeab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a607f7d4da2781dc9f5e7ed612e105e43" id="r_a607f7d4da2781dc9f5e7ed612e105e43"><td class="memItemLeft" align="right" valign="top"><a id="a607f7d4da2781dc9f5e7ed612e105e43" name="a607f7d4da2781dc9f5e7ed612e105e43"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getImportedAtomCount</b> () const</td></tr>
<tr class="memdesc:a607f7d4da2781dc9f5e7ed612e105e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of atoms currently imported into this work unit. <br /></td></tr>
<tr class="separator:a607f7d4da2781dc9f5e7ed612e105e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f292d9c9513e51c9dbd3b28dea6e94" id="r_a26f292d9c9513e51c9dbd3b28dea6e94"><td class="memItemLeft" align="right" valign="top"><a id="a26f292d9c9513e51c9dbd3b28dea6e94" name="a26f292d9c9513e51c9dbd3b28dea6e94"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getMovedAtomCount</b> () const</td></tr>
<tr class="memdesc:a26f292d9c9513e51c9dbd3b28dea6e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of atoms currently set to be moved by this work unit. <br /></td></tr>
<tr class="separator:a26f292d9c9513e51c9dbd3b28dea6e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b44bd8a2c7744951c66e324a8275d1" id="r_a58b44bd8a2c7744951c66e324a8275d1"><td class="memItemLeft" align="right" valign="top"><a id="a58b44bd8a2c7744951c66e324a8275d1" name="a58b44bd8a2c7744951c66e324a8275d1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getUpdatedAtomCount</b> () const</td></tr>
<tr class="memdesc:a58b44bd8a2c7744951c66e324a8275d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of atoms currently set to be updated by this work unit. <br /></td></tr>
<tr class="separator:a58b44bd8a2c7744951c66e324a8275d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1739a986fdfe27683caf05968bee1c6" id="r_ad1739a986fdfe27683caf05968bee1c6"><td class="memItemLeft" align="right" valign="top"><a id="ad1739a986fdfe27683caf05968bee1c6" name="ad1739a986fdfe27683caf05968bee1c6"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getListIndex</b> () const</td></tr>
<tr class="memdesc:ad1739a986fdfe27683caf05968bee1c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list index of this work unit. <br /></td></tr>
<tr class="separator:ad1739a986fdfe27683caf05968bee1c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfea766aacae7df45be4b9a8972adaa0" id="r_adfea766aacae7df45be4b9a8972adaa0"><td class="memItemLeft" align="right" valign="top"><a id="adfea766aacae7df45be4b9a8972adaa0" name="adfea766aacae7df45be4b9a8972adaa0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getMinAtomIndex</b> () const</td></tr>
<tr class="memdesc:adfea766aacae7df45be4b9a8972adaa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum topological atom index of any used by this work unit. <br /></td></tr>
<tr class="separator:adfea766aacae7df45be4b9a8972adaa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd3c19fe41663188e2213e916984ad8" id="r_a5cd3c19fe41663188e2213e916984ad8"><td class="memItemLeft" align="right" valign="top"><a id="a5cd3c19fe41663188e2213e916984ad8" name="a5cd3c19fe41663188e2213e916984ad8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getMaxAtomIndex</b> () const</td></tr>
<tr class="memdesc:a5cd3c19fe41663188e2213e916984ad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum topological atom index of any used by this work unit. <br /></td></tr>
<tr class="separator:a5cd3c19fe41663188e2213e916984ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d24b39e850d5740811f1ac1fbd22d6f" id="r_a9d24b39e850d5740811f1ac1fbd22d6f"><td class="memItemLeft" align="right" valign="top"><a id="a9d24b39e850d5740811f1ac1fbd22d6f" name="a9d24b39e850d5740811f1ac1fbd22d6f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getMaxAtoms</b> () const</td></tr>
<tr class="memdesc:a9d24b39e850d5740811f1ac1fbd22d6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum atom count that this work unit can hold. <br /></td></tr>
<tr class="separator:a9d24b39e850d5740811f1ac1fbd22d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a8d174dbe46c1c049a94f78519bf158" id="r_a3a8d174dbe46c1c049a94f78519bf158"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a8d174dbe46c1c049a94f78519bf158">getAtomImportList</a> (int atom_offset=0) const</td></tr>
<tr class="memdesc:a3a8d174dbe46c1c049a94f78519bf158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of imported atoms.  <br /></td></tr>
<tr class="separator:a3a8d174dbe46c1c049a94f78519bf158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e0f898d47a75245755658822fb931e9" id="r_a1e0f898d47a75245755658822fb931e9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e0f898d47a75245755658822fb931e9">getImportedAtomIndex</a> (int slot, int atom_offset=0) const</td></tr>
<tr class="memdesc:a1e0f898d47a75245755658822fb931e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a specific imported atom.  <br /></td></tr>
<tr class="separator:a1e0f898d47a75245755658822fb931e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d3eda15efc25db5184904327f50638" id="r_a87d3eda15efc25db5184904327f50638"><td class="memItemLeft" align="right" valign="top"><a id="a87d3eda15efc25db5184904327f50638" name="a87d3eda15efc25db5184904327f50638"></a>
std::vector&lt; <a class="el" href="structstormm_1_1data__types_1_1uint2.html">uint2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getAtomManipulationMasks</b> () const</td></tr>
<tr class="memdesc:a87d3eda15efc25db5184904327f50638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get bitmasks of moving atoms and atoms that this work unit is assigned to update. Bits signify 1 for an atom being moving or an update assignment. The masks are encoded in a tuple with the x members making a mask for each segment of moving atoms and the y members making a mask for each segment of assigned update atoms. <br /></td></tr>
<tr class="separator:a87d3eda15efc25db5184904327f50638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b7780da41a8c26e9eb36a9654bb047" id="r_a40b7780da41a8c26e9eb36a9654bb047"><td class="memItemLeft" align="right" valign="top"><a id="a40b7780da41a8c26e9eb36a9654bb047" name="a40b7780da41a8c26e9eb36a9654bb047"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getPaddedConstraintInstructionCount</b> () const</td></tr>
<tr class="memdesc:a40b7780da41a8c26e9eb36a9654bb047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the padded size of the largest constraint group. The padding extends the size of each constraint group in the work unit to the minimum factor of two, with a maximum allowed size of 16. <br /></td></tr>
<tr class="separator:a40b7780da41a8c26e9eb36a9654bb047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cffcee752049eb858da500aa98822be" id="r_a6cffcee752049eb858da500aa98822be"><td class="memItemLeft" align="right" valign="top"><a id="a6cffcee752049eb858da500aa98822be" name="a6cffcee752049eb858da500aa98822be"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getTaskCounts</b> () const</td></tr>
<tr class="memdesc:a6cffcee752049eb858da500aa98822be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a vector describing the number of each type of item this work unit can be tasked to perform. <br /></td></tr>
<tr class="separator:a6cffcee752049eb858da500aa98822be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d990e41b64e46f39fab7f5b2b82cda" id="r_a32d990e41b64e46f39fab7f5b2b82cda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32d990e41b64e46f39fab7f5b2b82cda">storeCompositeBondInstructions</a> (const std::vector&lt; int &gt; &amp;bond_param_map={}, const std::vector&lt; int &gt; &amp;ubrd_param_map={})</td></tr>
<tr class="memdesc:a32d990e41b64e46f39fab7f5b2b82cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute and store a vector of the bond instructions. This function accepts parameter interpretation tables in order to produce instructions for a collated topology handling many systems (<a class="el" href="classstormm_1_1energy_1_1AtomGraphSynthesis.html" title="A collection of one or more AtomGraph objects, with similar components arranged in contiguous arrays ...">AtomGraphSynthesis</a>).  <br /></td></tr>
<tr class="separator:a32d990e41b64e46f39fab7f5b2b82cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8baf9fd328bb0af1d0c778ffd5d5d5dc" id="r_a8baf9fd328bb0af1d0c778ffd5d5d5dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8baf9fd328bb0af1d0c778ffd5d5d5dc">storeAngleInstructions</a> (const std::vector&lt; int &gt; &amp;parameter_map={})</td></tr>
<tr class="memdesc:a8baf9fd328bb0af1d0c778ffd5d5d5dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a vector of the harmonic angle instructions. This function accepts a parameter interpretation table in order to produce instructions for a collated topology handling many systems (<a class="el" href="classstormm_1_1energy_1_1AtomGraphSynthesis.html" title="A collection of one or more AtomGraph objects, with similar components arranged in contiguous arrays ...">AtomGraphSynthesis</a>).  <br /></td></tr>
<tr class="separator:a8baf9fd328bb0af1d0c778ffd5d5d5dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a0a362032e759818423449dfd7d360" id="r_a97a0a362032e759818423449dfd7d360"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97a0a362032e759818423449dfd7d360">storeCompositeDihedralInstructions</a> (const std::vector&lt; int &gt; &amp;dihe_param_map={}, const std::vector&lt; int &gt; &amp;dihe14_param_map={}, const std::vector&lt; int &gt; &amp;cimp_param_map={})</td></tr>
<tr class="memdesc:a97a0a362032e759818423449dfd7d360"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a vector of the composite (cosine-based) dihedral, associated 1:4 interactions, as well as CHARMM improper dihedral instructions. This function accepts parameter interpretation tables in order to produce instructions for a collated topology handling many systems (<a class="el" href="classstormm_1_1energy_1_1AtomGraphSynthesis.html" title="A collection of one or more AtomGraph objects, with similar components arranged in contiguous arrays ...">AtomGraphSynthesis</a>).  <br /></td></tr>
<tr class="separator:a97a0a362032e759818423449dfd7d360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c43d58fced09e383adfe2c2c73a9096" id="r_a2c43d58fced09e383adfe2c2c73a9096"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c43d58fced09e383adfe2c2c73a9096">storeCmapInstructions</a> (const std::vector&lt; int &gt; &amp;parameter_map={})</td></tr>
<tr class="memdesc:a2c43d58fced09e383adfe2c2c73a9096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a vector of the CMAP instructions. This function accepts a parameter interpretation table in order to produce instructions for a collated topology handling many systems (<a class="el" href="classstormm_1_1energy_1_1AtomGraphSynthesis.html" title="A collection of one or more AtomGraph objects, with similar components arranged in contiguous arrays ...">AtomGraphSynthesis</a>).  <br /></td></tr>
<tr class="separator:a2c43d58fced09e383adfe2c2c73a9096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36931ab2faf23bcb47d55324d93e301f" id="r_a36931ab2faf23bcb47d55324d93e301f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36931ab2faf23bcb47d55324d93e301f">storeInferred14Instructions</a> (const std::vector&lt; int &gt; &amp;parameter_map={})</td></tr>
<tr class="memdesc:a36931ab2faf23bcb47d55324d93e301f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a vector of the inferred 1:4 attenuated pair interaction instructions. This function accepts a parameter interpretation table in order to produce instructions for a collated topology handling many systems (<a class="el" href="classstormm_1_1energy_1_1AtomGraphSynthesis.html" title="A collection of one or more AtomGraph objects, with similar components arranged in contiguous arrays ...">AtomGraphSynthesis</a>).  <br /></td></tr>
<tr class="separator:a36931ab2faf23bcb47d55324d93e301f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6062f2cec657b8ce44beadb0ed22a3f9" id="r_a6062f2cec657b8ce44beadb0ed22a3f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6062f2cec657b8ce44beadb0ed22a3f9">storePositionalRestraintInstructions</a> (const std::vector&lt; int &gt; &amp;kr_param_map={}, const std::vector&lt; int &gt; &amp;xyz_param_map={})</td></tr>
<tr class="memdesc:a6062f2cec657b8ce44beadb0ed22a3f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a vector of the positional restraint instructions for this work unit. This function accepts parameter interpretation tables showing how the raw list of restraint settings (k(2,3), r(1,2,3,4), and x / y / z targets) can be condensed by an <a class="el" href="classstormm_1_1energy_1_1AtomGraphSynthesis.html" title="A collection of one or more AtomGraph objects, with similar components arranged in contiguous arrays ...">AtomGraphSynthesis</a>.  <br /></td></tr>
<tr class="separator:a6062f2cec657b8ce44beadb0ed22a3f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b3e83effc865755c9fa4099e1f21fc" id="r_a85b3e83effc865755c9fa4099e1f21fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85b3e83effc865755c9fa4099e1f21fc">storeDistanceRestraintInstructions</a> (const std::vector&lt; int &gt; &amp;kr_param_map={})</td></tr>
<tr class="memdesc:a85b3e83effc865755c9fa4099e1f21fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a vector of the distance restraint instructions for this work unit. This function accepts a parameter interpretation table showing how the raw list of restraint settings (k(2,3) and r(1,2,3,4)) can be condensed by an <a class="el" href="classstormm_1_1energy_1_1AtomGraphSynthesis.html" title="A collection of one or more AtomGraph objects, with similar components arranged in contiguous arrays ...">AtomGraphSynthesis</a>.  <br /></td></tr>
<tr class="separator:a85b3e83effc865755c9fa4099e1f21fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5087654adfa3ea77dfe69bfcf00bf172" id="r_a5087654adfa3ea77dfe69bfcf00bf172"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5087654adfa3ea77dfe69bfcf00bf172">storeAngleRestraintInstructions</a> (const std::vector&lt; int &gt; &amp;kr_param_map={})</td></tr>
<tr class="memdesc:a5087654adfa3ea77dfe69bfcf00bf172"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a vector of the three-point angle restraint instructions for this work unit. This function accepts a parameter interpretation table showing how the raw list of restraint settings (k(2,3) and r(1,2,3,4)) can be condensed by an <a class="el" href="classstormm_1_1energy_1_1AtomGraphSynthesis.html" title="A collection of one or more AtomGraph objects, with similar components arranged in contiguous arrays ...">AtomGraphSynthesis</a>.  <br /></td></tr>
<tr class="separator:a5087654adfa3ea77dfe69bfcf00bf172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac89fc80e8a415044a88c7ba7e7e13e03" id="r_ac89fc80e8a415044a88c7ba7e7e13e03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac89fc80e8a415044a88c7ba7e7e13e03">storeDihedralRestraintInstructions</a> (const std::vector&lt; int &gt; &amp;kr_param_map={})</td></tr>
<tr class="memdesc:ac89fc80e8a415044a88c7ba7e7e13e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a vector of the four-point dihedral restraint instructions for this work unit. This function accepts a parameter interpretation table showing how the raw list of restraint settings (k(2,3) and r(1,2,3,4)) can be condensed by an <a class="el" href="classstormm_1_1energy_1_1AtomGraphSynthesis.html" title="A collection of one or more AtomGraph objects, with similar components arranged in contiguous arrays ...">AtomGraphSynthesis</a>.  <br /></td></tr>
<tr class="separator:ac89fc80e8a415044a88c7ba7e7e13e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab614a6b47b8176399bef2a16f197b3fa" id="r_ab614a6b47b8176399bef2a16f197b3fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab614a6b47b8176399bef2a16f197b3fa">storeVirtualSiteInstructions</a> (const std::vector&lt; int &gt; &amp;parameter_map={})</td></tr>
<tr class="memdesc:ab614a6b47b8176399bef2a16f197b3fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a vector of the virtual site instructions for this work unit. This function accepts a parameter interpretation table showing how the raw list of unique virtual site frames from one topology maps into a larger selection kept by an <a class="el" href="classstormm_1_1energy_1_1AtomGraphSynthesis.html" title="A collection of one or more AtomGraph objects, with similar components arranged in contiguous arrays ...">AtomGraphSynthesis</a>.  <br /></td></tr>
<tr class="separator:ab614a6b47b8176399bef2a16f197b3fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a264931ecf34afc7814d0421908931f06" id="r_a264931ecf34afc7814d0421908931f06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a264931ecf34afc7814d0421908931f06">storeSettleGroupInstructions</a> (const std::vector&lt; int &gt; &amp;parameter_map={})</td></tr>
<tr class="memdesc:a264931ecf34afc7814d0421908931f06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a vector of the SETTLE constraint group instructions for this work unit. This function accepts a parameter interpretation table showing how the raw list of unique SETTLE geometries in one topology maps into a possibly more diverse list curated by an <a class="el" href="classstormm_1_1energy_1_1AtomGraphSynthesis.html" title="A collection of one or more AtomGraph objects, with similar components arranged in contiguous arrays ...">AtomGraphSynthesis</a>.  <br /></td></tr>
<tr class="separator:a264931ecf34afc7814d0421908931f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f758efc6aecd3497f2ac443a9fd783" id="r_ac3f758efc6aecd3497f2ac443a9fd783"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3f758efc6aecd3497f2ac443a9fd783">storeConstraintGroupInstructions</a> (const std::vector&lt; int &gt; &amp;parameter_map={}, const std::vector&lt; int &gt; &amp;group_param_bounds={})</td></tr>
<tr class="memdesc:ac3f758efc6aecd3497f2ac443a9fd783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a vector of the hub-and-spoke constraint group instructions for this work unit. This function accepts a parameter interpretation table showing how the raw list of unique constraint groups in one topology maps into a possibly more diverse list curated by an <a class="el" href="classstormm_1_1energy_1_1AtomGraphSynthesis.html" title="A collection of one or more AtomGraph objects, with similar components arranged in contiguous arrays ...">AtomGraphSynthesis</a>.  <br /></td></tr>
<tr class="separator:ac3f758efc6aecd3497f2ac443a9fd783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e0f312d7d3bf36e3084c2d60dceb64" id="r_a47e0f312d7d3bf36e3084c2d60dceb64"><td class="memItemLeft" align="right" valign="top"><a id="a47e0f312d7d3bf36e3084c2d60dceb64" name="a47e0f312d7d3bf36e3084c2d60dceb64"></a>
const std::vector&lt; <a class="el" href="structstormm_1_1data__types_1_1uint2.html">uint2</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getCompositeBondInstructions</b> () const</td></tr>
<tr class="memdesc:a47e0f312d7d3bf36e3084c2d60dceb64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the stored vector of composite bond instructions. <br /></td></tr>
<tr class="separator:a47e0f312d7d3bf36e3084c2d60dceb64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef3f8353fa0a07e89228530506553b5" id="r_a3ef3f8353fa0a07e89228530506553b5"><td class="memItemLeft" align="right" valign="top"><a id="a3ef3f8353fa0a07e89228530506553b5" name="a3ef3f8353fa0a07e89228530506553b5"></a>
const std::vector&lt; <a class="el" href="structstormm_1_1data__types_1_1uint2.html">uint2</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getAngleInstructions</b> () const</td></tr>
<tr class="memdesc:a3ef3f8353fa0a07e89228530506553b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the stored vector of angle instructions. <br /></td></tr>
<tr class="separator:a3ef3f8353fa0a07e89228530506553b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c374fdd2b3132f753672425994c6b0e" id="r_a9c374fdd2b3132f753672425994c6b0e"><td class="memItemLeft" align="right" valign="top"><a id="a9c374fdd2b3132f753672425994c6b0e" name="a9c374fdd2b3132f753672425994c6b0e"></a>
const std::vector&lt; <a class="el" href="structstormm_1_1data__types_1_1uint3.html">uint3</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getCompositeDihedralInstructions</b> () const</td></tr>
<tr class="memdesc:a9c374fdd2b3132f753672425994c6b0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the stored vector of composite dihedral instructions. <br /></td></tr>
<tr class="separator:a9c374fdd2b3132f753672425994c6b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a0f8a3318f08c2eddbd59a6520dceb5" id="r_a1a0f8a3318f08c2eddbd59a6520dceb5"><td class="memItemLeft" align="right" valign="top"><a id="a1a0f8a3318f08c2eddbd59a6520dceb5" name="a1a0f8a3318f08c2eddbd59a6520dceb5"></a>
const std::vector&lt; <a class="el" href="structstormm_1_1data__types_1_1uint2.html">uint2</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getCmapInstructions</b> () const</td></tr>
<tr class="memdesc:a1a0f8a3318f08c2eddbd59a6520dceb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the stored vector of CMAP instructions. <br /></td></tr>
<tr class="separator:a1a0f8a3318f08c2eddbd59a6520dceb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662625eef861ec3945968e4aeb871c40" id="r_a662625eef861ec3945968e4aeb871c40"><td class="memItemLeft" align="right" valign="top"><a id="a662625eef861ec3945968e4aeb871c40" name="a662625eef861ec3945968e4aeb871c40"></a>
const std::vector&lt; uint &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getInferred14Instructions</b> () const</td></tr>
<tr class="memdesc:a662625eef861ec3945968e4aeb871c40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the stored vector of CMAP instructions. <br /></td></tr>
<tr class="separator:a662625eef861ec3945968e4aeb871c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c84b56bf66ba55a75707046b03949d7" id="r_a5c84b56bf66ba55a75707046b03949d7"><td class="memItemLeft" align="right" valign="top"><a id="a5c84b56bf66ba55a75707046b03949d7" name="a5c84b56bf66ba55a75707046b03949d7"></a>
const std::vector&lt; <a class="el" href="structstormm_1_1data__types_1_1uint2.html">uint2</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getPositionalRestraintInstructions</b> () const</td></tr>
<tr class="memdesc:a5c84b56bf66ba55a75707046b03949d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the stored vector of positional restraint instructions. <br /></td></tr>
<tr class="separator:a5c84b56bf66ba55a75707046b03949d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef1215824988c61cfffb583a75333363" id="r_aef1215824988c61cfffb583a75333363"><td class="memItemLeft" align="right" valign="top"><a id="aef1215824988c61cfffb583a75333363" name="aef1215824988c61cfffb583a75333363"></a>
const std::vector&lt; <a class="el" href="structstormm_1_1data__types_1_1uint2.html">uint2</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getDistanceRestraintInstructions</b> () const</td></tr>
<tr class="memdesc:aef1215824988c61cfffb583a75333363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the stored vector of distance restraint instructions. <br /></td></tr>
<tr class="separator:aef1215824988c61cfffb583a75333363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11275491a3456d552c84749aeb88b650" id="r_a11275491a3456d552c84749aeb88b650"><td class="memItemLeft" align="right" valign="top"><a id="a11275491a3456d552c84749aeb88b650" name="a11275491a3456d552c84749aeb88b650"></a>
const std::vector&lt; <a class="el" href="structstormm_1_1data__types_1_1uint2.html">uint2</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getAngleRestraintInstructions</b> () const</td></tr>
<tr class="memdesc:a11275491a3456d552c84749aeb88b650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the stored vector of three-point angle restraint instructions. <br /></td></tr>
<tr class="separator:a11275491a3456d552c84749aeb88b650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd3adcf5df969df179579691dab9643d" id="r_abd3adcf5df969df179579691dab9643d"><td class="memItemLeft" align="right" valign="top"><a id="abd3adcf5df969df179579691dab9643d" name="abd3adcf5df969df179579691dab9643d"></a>
const std::vector&lt; <a class="el" href="structstormm_1_1data__types_1_1uint2.html">uint2</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getDihedralRestraintInstructions</b> () const</td></tr>
<tr class="memdesc:abd3adcf5df969df179579691dab9643d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the stored vector of four-point dihedral restraint instructions. <br /></td></tr>
<tr class="separator:abd3adcf5df969df179579691dab9643d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b4fef601c6b7889a19a5eede3628c0" id="r_ab9b4fef601c6b7889a19a5eede3628c0"><td class="memItemLeft" align="right" valign="top"><a id="ab9b4fef601c6b7889a19a5eede3628c0" name="ab9b4fef601c6b7889a19a5eede3628c0"></a>
const std::vector&lt; <a class="el" href="structstormm_1_1data__types_1_1uint2.html">uint2</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getVirtualSiteInstructions</b> () const</td></tr>
<tr class="memdesc:ab9b4fef601c6b7889a19a5eede3628c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the stored vector of virtual site placement instructions. <br /></td></tr>
<tr class="separator:ab9b4fef601c6b7889a19a5eede3628c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab144b79757171cc333535cf1e386c38d" id="r_ab144b79757171cc333535cf1e386c38d"><td class="memItemLeft" align="right" valign="top"><a id="ab144b79757171cc333535cf1e386c38d" name="ab144b79757171cc333535cf1e386c38d"></a>
const std::vector&lt; <a class="el" href="structstormm_1_1data__types_1_1uint2.html">uint2</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getSettleGroupInstructions</b> () const</td></tr>
<tr class="memdesc:ab144b79757171cc333535cf1e386c38d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the stored vector of SETTLE constraint group instructions. <br /></td></tr>
<tr class="separator:ab144b79757171cc333535cf1e386c38d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee96b0cd33619a31a474c9f98204763" id="r_aaee96b0cd33619a31a474c9f98204763"><td class="memItemLeft" align="right" valign="top"><a id="aaee96b0cd33619a31a474c9f98204763" name="aaee96b0cd33619a31a474c9f98204763"></a>
const std::vector&lt; <a class="el" href="structstormm_1_1data__types_1_1uint2.html">uint2</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getConstraintGroupInstructions</b> () const</td></tr>
<tr class="memdesc:aaee96b0cd33619a31a474c9f98204763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the stored vector of hub-and-spoke constraint group instructions. <br /></td></tr>
<tr class="separator:aaee96b0cd33619a31a474c9f98204763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7921c59e9b2eb70b34757c63c255ee5e" id="r_a7921c59e9b2eb70b34757c63c255ee5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstormm_1_1data__types_1_1uint2.html">uint2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7921c59e9b2eb70b34757c63c255ee5e">getCompositeBondInstruction</a> (int index) const</td></tr>
<tr class="memdesc:a7921c59e9b2eb70b34757c63c255ee5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a specific composite bond instruction.  <br /></td></tr>
<tr class="separator:a7921c59e9b2eb70b34757c63c255ee5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1c98acabc701c509ddedd571fd5fbe" id="r_a5e1c98acabc701c509ddedd571fd5fbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstormm_1_1data__types_1_1uint2.html">uint2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e1c98acabc701c509ddedd571fd5fbe">getAngleInstruction</a> (int index) const</td></tr>
<tr class="memdesc:a5e1c98acabc701c509ddedd571fd5fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a specific angle instruction.  <br /></td></tr>
<tr class="separator:a5e1c98acabc701c509ddedd571fd5fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17cfc5c2896eab4ebbb5c77cf02c257" id="r_ae17cfc5c2896eab4ebbb5c77cf02c257"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstormm_1_1data__types_1_1uint3.html">uint3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae17cfc5c2896eab4ebbb5c77cf02c257">getCompositeDihedralInstruction</a> (int index) const</td></tr>
<tr class="memdesc:ae17cfc5c2896eab4ebbb5c77cf02c257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a specific composite dihedral instruction.  <br /></td></tr>
<tr class="separator:ae17cfc5c2896eab4ebbb5c77cf02c257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae68d96857a805398c656b66e68a0d7c8" id="r_ae68d96857a805398c656b66e68a0d7c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstormm_1_1data__types_1_1uint2.html">uint2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae68d96857a805398c656b66e68a0d7c8">getCmapInstruction</a> (int index) const</td></tr>
<tr class="memdesc:ae68d96857a805398c656b66e68a0d7c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a specific CMAP instruction.  <br /></td></tr>
<tr class="separator:ae68d96857a805398c656b66e68a0d7c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838f6a41adfd013ff5fcac581adbe281" id="r_a838f6a41adfd013ff5fcac581adbe281"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a838f6a41adfd013ff5fcac581adbe281">getInferred14Instruction</a> (int index) const</td></tr>
<tr class="memdesc:a838f6a41adfd013ff5fcac581adbe281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a specific CMAP instruction.  <br /></td></tr>
<tr class="separator:a838f6a41adfd013ff5fcac581adbe281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f2f9f2a6196188cbc1c7eafb90b038a" id="r_a2f2f9f2a6196188cbc1c7eafb90b038a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstormm_1_1data__types_1_1uint2.html">uint2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f2f9f2a6196188cbc1c7eafb90b038a">getPositionalRestraintInstruction</a> (int index) const</td></tr>
<tr class="memdesc:a2f2f9f2a6196188cbc1c7eafb90b038a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a specific positional restraint instruction.  <br /></td></tr>
<tr class="separator:a2f2f9f2a6196188cbc1c7eafb90b038a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a246803250b8fbafc4d8b73e490e61ce9" id="r_a246803250b8fbafc4d8b73e490e61ce9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstormm_1_1data__types_1_1uint2.html">uint2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a246803250b8fbafc4d8b73e490e61ce9">getDistanceRestraintInstruction</a> (int index) const</td></tr>
<tr class="memdesc:a246803250b8fbafc4d8b73e490e61ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a specific distance restraint instruction.  <br /></td></tr>
<tr class="separator:a246803250b8fbafc4d8b73e490e61ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6a76ca3003555c0b4448e05fa2e1204" id="r_ab6a76ca3003555c0b4448e05fa2e1204"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstormm_1_1data__types_1_1uint2.html">uint2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6a76ca3003555c0b4448e05fa2e1204">getAngleRestraintInstruction</a> (int index) const</td></tr>
<tr class="memdesc:ab6a76ca3003555c0b4448e05fa2e1204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a specific three-point angle restraint instruction.  <br /></td></tr>
<tr class="separator:ab6a76ca3003555c0b4448e05fa2e1204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044d00ff464ad82af424c7893599e229" id="r_a044d00ff464ad82af424c7893599e229"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstormm_1_1data__types_1_1uint2.html">uint2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a044d00ff464ad82af424c7893599e229">getDihedralRestraintInstruction</a> (int index) const</td></tr>
<tr class="memdesc:a044d00ff464ad82af424c7893599e229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a specific four-point dihedral restraint instruction.  <br /></td></tr>
<tr class="separator:a044d00ff464ad82af424c7893599e229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7eb00a5407460702198df1003e368ec" id="r_aa7eb00a5407460702198df1003e368ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstormm_1_1data__types_1_1uint2.html">uint2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7eb00a5407460702198df1003e368ec">getVirtualSiteInstruction</a> (int index) const</td></tr>
<tr class="memdesc:aa7eb00a5407460702198df1003e368ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a specific virtual site placement instruction.  <br /></td></tr>
<tr class="separator:aa7eb00a5407460702198df1003e368ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6fb6fafec712b8c2188f198be513532" id="r_aa6fb6fafec712b8c2188f198be513532"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstormm_1_1data__types_1_1uint2.html">uint2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6fb6fafec712b8c2188f198be513532">getSettleGroupInstruction</a> (int index) const</td></tr>
<tr class="memdesc:aa6fb6fafec712b8c2188f198be513532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a specific SETTLE constraint group instruction.  <br /></td></tr>
<tr class="separator:aa6fb6fafec712b8c2188f198be513532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab311987c4e7ca851e9846a4cf175bff3" id="r_ab311987c4e7ca851e9846a4cf175bff3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstormm_1_1data__types_1_1uint2.html">uint2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab311987c4e7ca851e9846a4cf175bff3">getConstraintGroupInstruction</a> (int index) const</td></tr>
<tr class="memdesc:ab311987c4e7ca851e9846a4cf175bff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a specific hub-and-spoke constraint group instruction.  <br /></td></tr>
<tr class="separator:ab311987c4e7ca851e9846a4cf175bff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4148a6acfac3c1062c9da5edc0bd923a" id="r_a4148a6acfac3c1062c9da5edc0bd923a"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; uint &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4148a6acfac3c1062c9da5edc0bd923a">getAccumulationFlags</a> (VwuTask vtask) const</td></tr>
<tr class="memdesc:a4148a6acfac3c1062c9da5edc0bd923a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the bitstrings indicating which energetic interactions each work unit is responsible for accumulating into the official energy outputs.  <br /></td></tr>
<tr class="separator:a4148a6acfac3c1062c9da5edc0bd923a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3829d430c08f969e074935420968ce46" id="r_a3829d430c08f969e074935420968ce46"><td class="memItemLeft" align="right" valign="top"><a id="a3829d430c08f969e074935420968ce46" name="a3829d430c08f969e074935420968ce46"></a>
const std::vector&lt; uint &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getAtomUpdateFlags</b> () const</td></tr>
<tr class="memdesc:a3829d430c08f969e074935420968ce46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the bitstrings indicating which of the imported (cached) atoms this work unit is responsible for updating in the global postion and velocity arrays. <br /></td></tr>
<tr class="separator:a3829d430c08f969e074935420968ce46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06fff070a64510acbd427538d22323d7" id="r_a06fff070a64510acbd427538d22323d7"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06fff070a64510acbd427538d22323d7">getSimpleTaskList</a> (VwuTask vtask) const</td></tr>
<tr class="memdesc:a06fff070a64510acbd427538d22323d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the topological indices of each task assigned to this work unit. Assignment of an energy / force-producing term or constraint group does not imply that a work unit is responsible for updating the final positions of all atoms involved. Composite task lists must be accessed with the special-purpose functions below.  <br /></td></tr>
<tr class="separator:a06fff070a64510acbd427538d22323d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51bede3b6c67ad48b5bcba06e203dabf" id="r_a51bede3b6c67ad48b5bcba06e203dabf"><td class="memItemLeft" align="right" valign="top"><a id="a51bede3b6c67ad48b5bcba06e203dabf" name="a51bede3b6c67ad48b5bcba06e203dabf"></a>
const std::vector&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getCompositeBondTaskList</b> () const</td></tr>
<tr class="memdesc:a51bede3b6c67ad48b5bcba06e203dabf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the composite bond tasks assigned to this work unit. This will return a vector of concatenated bond and Urey-Bradley term indices into the original topology. Interpreting which is which requires the corresponding vector of composite bond term instructions. <br /></td></tr>
<tr class="separator:a51bede3b6c67ad48b5bcba06e203dabf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad6b4b3dbbc919370aa1111bc391af01" id="r_aad6b4b3dbbc919370aa1111bc391af01"><td class="memItemLeft" align="right" valign="top"><a id="aad6b4b3dbbc919370aa1111bc391af01" name="aad6b4b3dbbc919370aa1111bc391af01"></a>
const std::vector&lt; <a class="el" href="structstormm_1_1data__types_1_1int2.html">int2</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getCompositeDihedralTaskList</b> () const</td></tr>
<tr class="memdesc:aad6b4b3dbbc919370aa1111bc391af01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the composite dihedral tasks assigned to this work unit. This will return a vector of tuples containing the topological indices of dihedrals or CHARMM impropers that the work unit evaluates. Interpretation of the tuples will depend on knowing whether each term index pertains to a standard cosine-based dihedral or a CHARMM improper dihedral, for which the corresponding instructions list must be accessed. <br /></td></tr>
<tr class="separator:aad6b4b3dbbc919370aa1111bc391af01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f439d819eaeb0f3fb88e40861f15984" id="r_a4f439d819eaeb0f3fb88e40861f15984"><td class="memItemLeft" align="right" valign="top"><a id="a4f439d819eaeb0f3fb88e40861f15984" name="a4f439d819eaeb0f3fb88e40861f15984"></a>
ValenceDelegator *&#160;</td><td class="memItemRight" valign="bottom"><b>getDelegatorPointer</b> ()</td></tr>
<tr class="memdesc:a4f439d819eaeb0f3fb88e40861f15984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the pointer to the <a class="el" href="classstormm_1_1synthesis_1_1ValenceDelegator.html" title="Object to track how different valence terms in a topology are delegated. Valence work units may evalu...">ValenceDelegator</a> managing the creation of this object. <br /></td></tr>
<tr class="separator:a4f439d819eaeb0f3fb88e40861f15984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a666d50ee34f5973152e5a7430ed83f52" id="r_a666d50ee34f5973152e5a7430ed83f52"><td class="memItemLeft" align="right" valign="top"><a id="a666d50ee34f5973152e5a7430ed83f52" name="a666d50ee34f5973152e5a7430ed83f52"></a>
const <a class="el" href="classstormm_1_1topology_1_1AtomGraph.html">AtomGraph</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getTopologyPointer</b> () const</td></tr>
<tr class="memdesc:a666d50ee34f5973152e5a7430ed83f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the topology for which this work unit applies. <br /></td></tr>
<tr class="separator:a666d50ee34f5973152e5a7430ed83f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a3d390e90b50a0738bc828f287531dc" id="r_a4a3d390e90b50a0738bc828f287531dc"><td class="memItemLeft" align="right" valign="top"><a id="a4a3d390e90b50a0738bc828f287531dc" name="a4a3d390e90b50a0738bc828f287531dc"></a>
const <a class="el" href="classstormm_1_1restraints_1_1RestraintApparatus.html">RestraintApparatus</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getRestraintApparatusPointer</b> () const</td></tr>
<tr class="memdesc:a4a3d390e90b50a0738bc828f287531dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the restraint collection for which this work unit applies. <br /></td></tr>
<tr class="separator:a4a3d390e90b50a0738bc828f287531dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a387cfea57759a727b9ff8cd53051bb49" id="r_a387cfea57759a727b9ff8cd53051bb49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a387cfea57759a727b9ff8cd53051bb49">setListIndex</a> (int list_index_in)</td></tr>
<tr class="memdesc:a387cfea57759a727b9ff8cd53051bb49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the list index of this work unit, in the event that the list of work units for a particular topology needs to be re-ordered.  <br /></td></tr>
<tr class="separator:a387cfea57759a727b9ff8cd53051bb49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a533922b6ea5fe9a74c6e4478eedf2711" id="r_a533922b6ea5fe9a74c6e4478eedf2711"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a533922b6ea5fe9a74c6e4478eedf2711">setAtomLimit</a> (int new_limit)</td></tr>
<tr class="memdesc:a533922b6ea5fe9a74c6e4478eedf2711"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the atom limit for a valence work unit. This can be useful in situations where it is desirable to form several work units out of a single molecule, despite there being enough room in just one to hold all atoms of the molecule.  <br /></td></tr>
<tr class="separator:a533922b6ea5fe9a74c6e4478eedf2711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e843cb5fb1646669c58384fe4860c5" id="r_a93e843cb5fb1646669c58384fe4860c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93e843cb5fb1646669c58384fe4860c5">addNewAtomImport</a> (int atom_index)</td></tr>
<tr class="memdesc:a93e843cb5fb1646669c58384fe4860c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new atom to a work unit. This will update the associated <a class="el" href="classstormm_1_1synthesis_1_1ValenceDelegator.html" title="Object to track how different valence terms in a topology are delegated. Valence work units may evalu...">ValenceDelegator</a> and all assignments therein.  <br /></td></tr>
<tr class="separator:a93e843cb5fb1646669c58384fe4860c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eba8cc8f3909d9f5f927bf6c93feee1" id="r_a8eba8cc8f3909d9f5f927bf6c93feee1"><td class="memItemLeft" align="right" valign="top"><a id="a8eba8cc8f3909d9f5f927bf6c93feee1" name="a8eba8cc8f3909d9f5f927bf6c93feee1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addNewAtomUpdate</b> (const int atom_index)</td></tr>
<tr class="memdesc:a8eba8cc8f3909d9f5f927bf6c93feee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new atom to the list of updates that a work unit shall perform. The atom must already be part of the atom import list. <br /></td></tr>
<tr class="separator:a8eba8cc8f3909d9f5f927bf6c93feee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb187bf3ca72cc96654f3c082a9e3222" id="r_afb187bf3ca72cc96654f3c082a9e3222"><td class="memItemLeft" align="right" valign="top"><a id="afb187bf3ca72cc96654f3c082a9e3222" name="afb187bf3ca72cc96654f3c082a9e3222"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>makeAtomMoveList</b> ()</td></tr>
<tr class="memdesc:afb187bf3ca72cc96654f3c082a9e3222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the move list for atoms in the work unit. Any atom that the work unit is responsible for updating must be moved by the work unit, but also any atom sharing a constraint group with one of the atoms which is on the official update list. <br /></td></tr>
<tr class="separator:afb187bf3ca72cc96654f3c082a9e3222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa2b9e423b5b82e2c761efafd464c67" id="r_a2fa2b9e423b5b82e2c761efafd464c67"><td class="memItemLeft" align="right" valign="top"><a id="a2fa2b9e423b5b82e2c761efafd464c67" name="a2fa2b9e423b5b82e2c761efafd464c67"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>sortAtomSets</b> ()</td></tr>
<tr class="memdesc:a2fa2b9e423b5b82e2c761efafd464c67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the atom lists (import, movement, and update) of this work unit into ascending order. This will optimize memory access when reading the atoms and set the stage for mapping valence terms / atom groups to the local list. <br /></td></tr>
<tr class="separator:a2fa2b9e423b5b82e2c761efafd464c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048e1ea71c203b3a55f1ec2e658627a2" id="r_a048e1ea71c203b3a55f1ec2e658627a2"><td class="memItemLeft" align="right" valign="top"><a id="a048e1ea71c203b3a55f1ec2e658627a2" name="a048e1ea71c203b3a55f1ec2e658627a2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>makeAtomUpdateMask</b> ()</td></tr>
<tr class="memdesc:a048e1ea71c203b3a55f1ec2e658627a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a bit mask spanning the atom imports, marking all of those that the work unit is responsible for updating in the global position and velocity arrays. <br /></td></tr>
<tr class="separator:a048e1ea71c203b3a55f1ec2e658627a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3938cd00badff13f524b3172200c159f" id="r_a3938cd00badff13f524b3172200c159f"><td class="memItemLeft" align="right" valign="top"><a id="a3938cd00badff13f524b3172200c159f" name="a3938cd00badff13f524b3172200c159f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>logActivities</b> ()</td></tr>
<tr class="memdesc:a3938cd00badff13f524b3172200c159f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log all activities of this work unit: valence terms, restraints, virtual sites, and constraints. This will translate the topological indices of atoms into indices of the local import list. <br /></td></tr>
<tr class="separator:a3938cd00badff13f524b3172200c159f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An object to collect the components of a valence work unit (which will also track frozen atoms to implement coordinate updates, velocity updates, and constraints). While the work unit is encoded in the <a class="el" href="classstormm_1_1energy_1_1AtomGraphSynthesis.html" title="A collection of one or more AtomGraph objects, with similar components arranged in contiguous arrays ...">AtomGraphSynthesis</a> object, the assembly is best done by a dedicated object with plenty of its own methods operating on a single topology (<a class="el" href="classstormm_1_1energy_1_1AtomGraph.html" title="A struct to hold information relating to an Amber topology. This struct&#39;s member functions are limite...">AtomGraph</a>). All systems in the <a class="el" href="classstormm_1_1energy_1_1AtomGraphSynthesis.html" title="A collection of one or more AtomGraph objects, with similar components arranged in contiguous arrays ...">AtomGraphSynthesis</a> are designed to function independently of one another&ndash;the only difference is that they have consensus tables of most parameters and differen atom indexing. Translating a valence work unit into a list of instructions within an <a class="el" href="classstormm_1_1energy_1_1AtomGraphSynthesis.html" title="A collection of one or more AtomGraph objects, with similar components arranged in contiguous arrays ...">AtomGraphSynthesis</a> is therefore a critical member function of this class. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a80a906bc59321fd06438edb9cfd8eeab" name="a80a906bc59321fd06438edb9cfd8eeab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80a906bc59321fd06438edb9cfd8eeab">&#9670;&#160;</a></span>ValenceWorkUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">stormm::synthesis::ValenceWorkUnit::ValenceWorkUnit </td>
          <td>(</td>
          <td class="paramtype">ValenceDelegator *</td>          <td class="paramname"><span class="paramname"><em>vdel_in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *</td>          <td class="paramname"><span class="paramname"><em>tvwu_coverage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>list_index_in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>seed_atom_in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>max_atoms_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">maximum_valence_work_unit_atoms</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The constructor takes a specific input topology (multiple systems using the same topology in an <a class="el" href="classstormm_1_1energy_1_1AtomGraphSynthesis.html" title="A collection of one or more AtomGraph objects, with similar components arranged in contiguous arrays ...">AtomGraphSynthesis</a> can thereby take the same valence work unit and translate the atom indices as appropriate rather than regenerating the work unit for many equivalent systems). Mapping starts from a specific atom and proceeds until a maximum number of atoms has been accumulated in order to process as many related valence terms as possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vdel_in</td><td>Valence delegator managing the creation of this valence work unit </td></tr>
    <tr><td class="paramname">tvwu_coverage</td><td>Array spanning all atoms in the system to mark whether any one of them has been included in the valence work unit currently under construction. This is distinct from arrays with similar functionality held by the <a class="el" href="classstormm_1_1synthesis_1_1ValenceDelegator.html" title="Object to track how different valence terms in a topology are delegated. Valence work units may evalu...">ValenceDelegator</a> object, which track whether an atom has been included as an update priority in any valence work unit. Having this work-unit specific resource ensures that atoms are not included multiple times in the import array. It is cleared after each work unit's construction so as to not require re-allocation. </td></tr>
    <tr><td class="paramname">list_index_in</td><td>Index of this unit in a larger list (the unit should remember its own index number, for the purposes of coordinating with other work units) </td></tr>
    <tr><td class="paramname">seed_atom_in</td><td>The first atom to incorporate into the work unit. Subsequent atoms will be either bonded in some chain to the seed, retracing previous topological indices whereby previous work units left some atoms behind, or jumping forward to the next new molecule. </td></tr>
    <tr><td class="paramname">max_atoms_in</td><td>The maximum number of atoms to accumulate in the work unit </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a93e843cb5fb1646669c58384fe4860c5" name="a93e843cb5fb1646669c58384fe4860c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e843cb5fb1646669c58384fe4860c5">&#9670;&#160;</a></span>addNewAtomImport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::synthesis::ValenceWorkUnit::addNewAtomImport </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>atom_index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new atom to a work unit. This will update the associated <a class="el" href="classstormm_1_1synthesis_1_1ValenceDelegator.html" title="Object to track how different valence terms in a topology are delegated. Valence work units may evalu...">ValenceDelegator</a> and all assignments therein. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">atom_index</td><td>Index of the atom of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4148a6acfac3c1062c9da5edc0bd923a" name="a4148a6acfac3c1062c9da5edc0bd923a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4148a6acfac3c1062c9da5edc0bd923a">&#9670;&#160;</a></span>getAccumulationFlags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; uint &gt; &amp; stormm::synthesis::ValenceWorkUnit::getAccumulationFlags </td>
          <td>(</td>
          <td class="paramtype">VwuTask</td>          <td class="paramname"><span class="paramname"><em>vtask</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the bitstrings indicating which energetic interactions each work unit is responsible for accumulating into the official energy outputs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vtask</td><td>The type of task accumulator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e1c98acabc701c509ddedd571fd5fbe" name="a5e1c98acabc701c509ddedd571fd5fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e1c98acabc701c509ddedd571fd5fbe">&#9670;&#160;</a></span>getAngleInstruction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstormm_1_1data__types_1_1uint2.html">uint2</a> stormm::synthesis::ValenceWorkUnit::getAngleInstruction </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a specific angle instruction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the instruction to retrieve </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6a76ca3003555c0b4448e05fa2e1204" name="ab6a76ca3003555c0b4448e05fa2e1204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6a76ca3003555c0b4448e05fa2e1204">&#9670;&#160;</a></span>getAngleRestraintInstruction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstormm_1_1data__types_1_1uint2.html">uint2</a> stormm::synthesis::ValenceWorkUnit::getAngleRestraintInstruction </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a specific three-point angle restraint instruction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the instruction to retrieve </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a8d174dbe46c1c049a94f78519bf158" name="a3a8d174dbe46c1c049a94f78519bf158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a8d174dbe46c1c049a94f78519bf158">&#9670;&#160;</a></span>getAtomImportList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; stormm::synthesis::ValenceWorkUnit::getAtomImportList </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>atom_offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the list of imported atoms. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">atom_offset</td><td>Offset of the atoms to add to the topological indices, if importing from a synthesis of many systems </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae68d96857a805398c656b66e68a0d7c8" name="ae68d96857a805398c656b66e68a0d7c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae68d96857a805398c656b66e68a0d7c8">&#9670;&#160;</a></span>getCmapInstruction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstormm_1_1data__types_1_1uint2.html">uint2</a> stormm::synthesis::ValenceWorkUnit::getCmapInstruction </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a specific CMAP instruction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the instruction to retrieve </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7921c59e9b2eb70b34757c63c255ee5e" name="a7921c59e9b2eb70b34757c63c255ee5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7921c59e9b2eb70b34757c63c255ee5e">&#9670;&#160;</a></span>getCompositeBondInstruction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstormm_1_1data__types_1_1uint2.html">uint2</a> stormm::synthesis::ValenceWorkUnit::getCompositeBondInstruction </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a specific composite bond instruction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the instruction to retrieve </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae17cfc5c2896eab4ebbb5c77cf02c257" name="ae17cfc5c2896eab4ebbb5c77cf02c257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae17cfc5c2896eab4ebbb5c77cf02c257">&#9670;&#160;</a></span>getCompositeDihedralInstruction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstormm_1_1data__types_1_1uint3.html">uint3</a> stormm::synthesis::ValenceWorkUnit::getCompositeDihedralInstruction </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a specific composite dihedral instruction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the instruction to retrieve </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab311987c4e7ca851e9846a4cf175bff3" name="ab311987c4e7ca851e9846a4cf175bff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab311987c4e7ca851e9846a4cf175bff3">&#9670;&#160;</a></span>getConstraintGroupInstruction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstormm_1_1data__types_1_1uint2.html">uint2</a> stormm::synthesis::ValenceWorkUnit::getConstraintGroupInstruction </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a specific hub-and-spoke constraint group instruction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the instruction to retrieve </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a044d00ff464ad82af424c7893599e229" name="a044d00ff464ad82af424c7893599e229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a044d00ff464ad82af424c7893599e229">&#9670;&#160;</a></span>getDihedralRestraintInstruction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstormm_1_1data__types_1_1uint2.html">uint2</a> stormm::synthesis::ValenceWorkUnit::getDihedralRestraintInstruction </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a specific four-point dihedral restraint instruction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the instruction to retrieve </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a246803250b8fbafc4d8b73e490e61ce9" name="a246803250b8fbafc4d8b73e490e61ce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a246803250b8fbafc4d8b73e490e61ce9">&#9670;&#160;</a></span>getDistanceRestraintInstruction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstormm_1_1data__types_1_1uint2.html">uint2</a> stormm::synthesis::ValenceWorkUnit::getDistanceRestraintInstruction </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a specific distance restraint instruction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the instruction to retrieve </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e0f898d47a75245755658822fb931e9" name="a1e0f898d47a75245755658822fb931e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e0f898d47a75245755658822fb931e9">&#9670;&#160;</a></span>getImportedAtomIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stormm::synthesis::ValenceWorkUnit::getImportedAtomIndex </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>slot</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>atom_offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a specific imported atom. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>Index of the atom of interest from within the work unit's array (this will return a topological index found in position atom_idx of the local import list) </td></tr>
    <tr><td class="paramname">atom_offset</td><td>Offset of the atoms to add to the topological indices, if importing from a larger synthesis of topologies / systems </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a838f6a41adfd013ff5fcac581adbe281" name="a838f6a41adfd013ff5fcac581adbe281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a838f6a41adfd013ff5fcac581adbe281">&#9670;&#160;</a></span>getInferred14Instruction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint stormm::synthesis::ValenceWorkUnit::getInferred14Instruction </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a specific CMAP instruction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the instruction to retrieve </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f2f9f2a6196188cbc1c7eafb90b038a" name="a2f2f9f2a6196188cbc1c7eafb90b038a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f2f9f2a6196188cbc1c7eafb90b038a">&#9670;&#160;</a></span>getPositionalRestraintInstruction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstormm_1_1data__types_1_1uint2.html">uint2</a> stormm::synthesis::ValenceWorkUnit::getPositionalRestraintInstruction </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a specific positional restraint instruction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the instruction to retrieve </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa6fb6fafec712b8c2188f198be513532" name="aa6fb6fafec712b8c2188f198be513532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6fb6fafec712b8c2188f198be513532">&#9670;&#160;</a></span>getSettleGroupInstruction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstormm_1_1data__types_1_1uint2.html">uint2</a> stormm::synthesis::ValenceWorkUnit::getSettleGroupInstruction </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a specific SETTLE constraint group instruction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the instruction to retrieve </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06fff070a64510acbd427538d22323d7" name="a06fff070a64510acbd427538d22323d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06fff070a64510acbd427538d22323d7">&#9670;&#160;</a></span>getSimpleTaskList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; int &gt; &amp; stormm::synthesis::ValenceWorkUnit::getSimpleTaskList </td>
          <td>(</td>
          <td class="paramtype">VwuTask</td>          <td class="paramname"><span class="paramname"><em>vtask</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the topological indices of each task assigned to this work unit. Assignment of an energy / force-producing term or constraint group does not imply that a work unit is responsible for updating the final positions of all atoms involved. Composite task lists must be accessed with the special-purpose functions below. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vtask</td><td>The type of task, i.e. bonded interactions, or SETTLE constraint groups </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7eb00a5407460702198df1003e368ec" name="aa7eb00a5407460702198df1003e368ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7eb00a5407460702198df1003e368ec">&#9670;&#160;</a></span>getVirtualSiteInstruction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstormm_1_1data__types_1_1uint2.html">uint2</a> stormm::synthesis::ValenceWorkUnit::getVirtualSiteInstruction </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a specific virtual site placement instruction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the instruction to retrieve </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a533922b6ea5fe9a74c6e4478eedf2711" name="a533922b6ea5fe9a74c6e4478eedf2711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a533922b6ea5fe9a74c6e4478eedf2711">&#9670;&#160;</a></span>setAtomLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::synthesis::ValenceWorkUnit::setAtomLimit </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>new_limit</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the atom limit for a valence work unit. This can be useful in situations where it is desirable to form several work units out of a single molecule, despite there being enough room in just one to hold all atoms of the molecule. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_limit</td><td>The new limit on the number of atoms. This cannot be lower than the number of atoms already in the work unit. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a387cfea57759a727b9ff8cd53051bb49" name="a387cfea57759a727b9ff8cd53051bb49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a387cfea57759a727b9ff8cd53051bb49">&#9670;&#160;</a></span>setListIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::synthesis::ValenceWorkUnit::setListIndex </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>list_index_in</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the list index of this work unit, in the event that the list of work units for a particular topology needs to be re-ordered. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list_index_in</td><td>The new list index for the work unit </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8baf9fd328bb0af1d0c778ffd5d5d5dc" name="a8baf9fd328bb0af1d0c778ffd5d5d5dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8baf9fd328bb0af1d0c778ffd5d5d5dc">&#9670;&#160;</a></span>storeAngleInstructions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::synthesis::ValenceWorkUnit::storeAngleInstructions </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>parameter_map</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store a vector of the harmonic angle instructions. This function accepts a parameter interpretation table in order to produce instructions for a collated topology handling many systems (<a class="el" href="classstormm_1_1energy_1_1AtomGraphSynthesis.html" title="A collection of one or more AtomGraph objects, with similar components arranged in contiguous arrays ...">AtomGraphSynthesis</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameter_map</td><td>Map of the angle parameter sets (optional) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5087654adfa3ea77dfe69bfcf00bf172" name="a5087654adfa3ea77dfe69bfcf00bf172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5087654adfa3ea77dfe69bfcf00bf172">&#9670;&#160;</a></span>storeAngleRestraintInstructions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::synthesis::ValenceWorkUnit::storeAngleRestraintInstructions </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>kr_param_map</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store a vector of the three-point angle restraint instructions for this work unit. This function accepts a parameter interpretation table showing how the raw list of restraint settings (k(2,3) and r(1,2,3,4)) can be condensed by an <a class="el" href="classstormm_1_1energy_1_1AtomGraphSynthesis.html" title="A collection of one or more AtomGraph objects, with similar components arranged in contiguous arrays ...">AtomGraphSynthesis</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kr_param_map</td><td>Mapping for k(2,3) and r(1,2,3,4) settings (optional) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c43d58fced09e383adfe2c2c73a9096" name="a2c43d58fced09e383adfe2c2c73a9096"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c43d58fced09e383adfe2c2c73a9096">&#9670;&#160;</a></span>storeCmapInstructions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::synthesis::ValenceWorkUnit::storeCmapInstructions </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>parameter_map</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store a vector of the CMAP instructions. This function accepts a parameter interpretation table in order to produce instructions for a collated topology handling many systems (<a class="el" href="classstormm_1_1energy_1_1AtomGraphSynthesis.html" title="A collection of one or more AtomGraph objects, with similar components arranged in contiguous arrays ...">AtomGraphSynthesis</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameter_map</td><td>Map of the one topology's CMAP surface indices onto the synthesis (optional) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32d990e41b64e46f39fab7f5b2b82cda" name="a32d990e41b64e46f39fab7f5b2b82cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32d990e41b64e46f39fab7f5b2b82cda">&#9670;&#160;</a></span>storeCompositeBondInstructions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::synthesis::ValenceWorkUnit::storeCompositeBondInstructions </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bond_param_map</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ubrd_param_map</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute and store a vector of the bond instructions. This function accepts parameter interpretation tables in order to produce instructions for a collated topology handling many systems (<a class="el" href="classstormm_1_1energy_1_1AtomGraphSynthesis.html" title="A collection of one or more AtomGraph objects, with similar components arranged in contiguous arrays ...">AtomGraphSynthesis</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bond_param_map</td><td>Map of the bond parameter sets (optional) </td></tr>
    <tr><td class="paramname">ubrd_param_map</td><td>Map of the Urey-Bradley parameter sets (optional) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97a0a362032e759818423449dfd7d360" name="a97a0a362032e759818423449dfd7d360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97a0a362032e759818423449dfd7d360">&#9670;&#160;</a></span>storeCompositeDihedralInstructions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::synthesis::ValenceWorkUnit::storeCompositeDihedralInstructions </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dihe_param_map</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dihe14_param_map</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>cimp_param_map</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store a vector of the composite (cosine-based) dihedral, associated 1:4 interactions, as well as CHARMM improper dihedral instructions. This function accepts parameter interpretation tables in order to produce instructions for a collated topology handling many systems (<a class="el" href="classstormm_1_1energy_1_1AtomGraphSynthesis.html" title="A collection of one or more AtomGraph objects, with similar components arranged in contiguous arrays ...">AtomGraphSynthesis</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dihe_param_map</td><td>Map of the dihedral parameter sets (optional) </td></tr>
    <tr><td class="paramname">dihe_param_map</td><td>Map of the 1:4 scaling factor parameter pairs (optional) </td></tr>
    <tr><td class="paramname">dihe_param_map</td><td>Map of the CHARMM harmonic improper parameter sets (optional) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3f758efc6aecd3497f2ac443a9fd783" name="ac3f758efc6aecd3497f2ac443a9fd783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3f758efc6aecd3497f2ac443a9fd783">&#9670;&#160;</a></span>storeConstraintGroupInstructions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::synthesis::ValenceWorkUnit::storeConstraintGroupInstructions </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>parameter_map</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>group_param_bounds</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store a vector of the hub-and-spoke constraint group instructions for this work unit. This function accepts a parameter interpretation table showing how the raw list of unique constraint groups in one topology maps into a possibly more diverse list curated by an <a class="el" href="classstormm_1_1energy_1_1AtomGraphSynthesis.html" title="A collection of one or more AtomGraph objects, with similar components arranged in contiguous arrays ...">AtomGraphSynthesis</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameter_map</td><td>Mapping for SETTLE group mass and geometry specifications (optional) </td></tr>
    <tr><td class="paramname">group_param_bounds</td><td>Bounds for constraint group parameter sets in an <a class="el" href="classstormm_1_1energy_1_1AtomGraphSynthesis.html" title="A collection of one or more AtomGraph objects, with similar components arranged in contiguous arrays ...">AtomGraphSynthesis</a> (required if parameter_map is supplied, to properly align the parameter indices of each instruction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac89fc80e8a415044a88c7ba7e7e13e03" name="ac89fc80e8a415044a88c7ba7e7e13e03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac89fc80e8a415044a88c7ba7e7e13e03">&#9670;&#160;</a></span>storeDihedralRestraintInstructions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::synthesis::ValenceWorkUnit::storeDihedralRestraintInstructions </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>kr_param_map</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store a vector of the four-point dihedral restraint instructions for this work unit. This function accepts a parameter interpretation table showing how the raw list of restraint settings (k(2,3) and r(1,2,3,4)) can be condensed by an <a class="el" href="classstormm_1_1energy_1_1AtomGraphSynthesis.html" title="A collection of one or more AtomGraph objects, with similar components arranged in contiguous arrays ...">AtomGraphSynthesis</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kr_param_map</td><td>Mapping for k(2,3) and r(1,2,3,4) settings (optional) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a85b3e83effc865755c9fa4099e1f21fc" name="a85b3e83effc865755c9fa4099e1f21fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b3e83effc865755c9fa4099e1f21fc">&#9670;&#160;</a></span>storeDistanceRestraintInstructions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::synthesis::ValenceWorkUnit::storeDistanceRestraintInstructions </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>kr_param_map</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store a vector of the distance restraint instructions for this work unit. This function accepts a parameter interpretation table showing how the raw list of restraint settings (k(2,3) and r(1,2,3,4)) can be condensed by an <a class="el" href="classstormm_1_1energy_1_1AtomGraphSynthesis.html" title="A collection of one or more AtomGraph objects, with similar components arranged in contiguous arrays ...">AtomGraphSynthesis</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kr_param_map</td><td>Mapping for k(2,3) and r(1,2,3,4) settings (optional) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a36931ab2faf23bcb47d55324d93e301f" name="a36931ab2faf23bcb47d55324d93e301f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36931ab2faf23bcb47d55324d93e301f">&#9670;&#160;</a></span>storeInferred14Instructions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::synthesis::ValenceWorkUnit::storeInferred14Instructions </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>parameter_map</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store a vector of the inferred 1:4 attenuated pair interaction instructions. This function accepts a parameter interpretation table in order to produce instructions for a collated topology handling many systems (<a class="el" href="classstormm_1_1energy_1_1AtomGraphSynthesis.html" title="A collection of one or more AtomGraph objects, with similar components arranged in contiguous arrays ...">AtomGraphSynthesis</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameter_map</td><td>Map of the one topology's attenuated interaction scaling factors onto the synthesis (optional) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6062f2cec657b8ce44beadb0ed22a3f9" name="a6062f2cec657b8ce44beadb0ed22a3f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6062f2cec657b8ce44beadb0ed22a3f9">&#9670;&#160;</a></span>storePositionalRestraintInstructions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::synthesis::ValenceWorkUnit::storePositionalRestraintInstructions </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>kr_param_map</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz_param_map</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store a vector of the positional restraint instructions for this work unit. This function accepts parameter interpretation tables showing how the raw list of restraint settings (k(2,3), r(1,2,3,4), and x / y / z targets) can be condensed by an <a class="el" href="classstormm_1_1energy_1_1AtomGraphSynthesis.html" title="A collection of one or more AtomGraph objects, with similar components arranged in contiguous arrays ...">AtomGraphSynthesis</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kr_param_map</td><td>Mapping for k(2,3) and r(1,2,3,4) settings (optional) </td></tr>
    <tr><td class="paramname">xyz_param_map</td><td>Mapping for Cartesian coordinate targets (optional) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a264931ecf34afc7814d0421908931f06" name="a264931ecf34afc7814d0421908931f06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a264931ecf34afc7814d0421908931f06">&#9670;&#160;</a></span>storeSettleGroupInstructions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::synthesis::ValenceWorkUnit::storeSettleGroupInstructions </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>parameter_map</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store a vector of the SETTLE constraint group instructions for this work unit. This function accepts a parameter interpretation table showing how the raw list of unique SETTLE geometries in one topology maps into a possibly more diverse list curated by an <a class="el" href="classstormm_1_1energy_1_1AtomGraphSynthesis.html" title="A collection of one or more AtomGraph objects, with similar components arranged in contiguous arrays ...">AtomGraphSynthesis</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameter_map</td><td>Mapping for SETTLE group mass and geometry specifications (optional) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab614a6b47b8176399bef2a16f197b3fa" name="ab614a6b47b8176399bef2a16f197b3fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab614a6b47b8176399bef2a16f197b3fa">&#9670;&#160;</a></span>storeVirtualSiteInstructions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stormm::synthesis::ValenceWorkUnit::storeVirtualSiteInstructions </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>parameter_map</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store a vector of the virtual site instructions for this work unit. This function accepts a parameter interpretation table showing how the raw list of unique virtual site frames from one topology maps into a larger selection kept by an <a class="el" href="classstormm_1_1energy_1_1AtomGraphSynthesis.html" title="A collection of one or more AtomGraph objects, with similar components arranged in contiguous arrays ...">AtomGraphSynthesis</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameter_map</td><td>Mapping for virtual site frame specifications (optional) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/Synthesis/<a class="el" href="valence__workunit_8h_source.html">valence_workunit.h</a></li>
<li>src/Synthesis/<b>valence_workunit.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2
</small></address>
</div><!-- doc-content -->
</body>
</html>
