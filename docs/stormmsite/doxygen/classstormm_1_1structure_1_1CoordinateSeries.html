<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>STORMM Source Documentation: stormm::structure::CoordinateSeries&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">STORMM Source Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>stormm</b></li><li class="navelem"><b>structure</b></li><li class="navelem"><a class="el" href="classstormm_1_1structure_1_1CoordinateSeries.html">CoordinateSeries</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classstormm_1_1structure_1_1CoordinateSeries-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">stormm::structure::CoordinateSeries&lt; T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Store the coordinates and box information for a series of frames, in one of several levels of precision. Individual frames can be extracted into <a class="el" href="classstormm_1_1structure_1_1CoordinateFrame.html" title="Store the coordinates and box information for a frame, only. This abridged struct can serve when the ...">CoordinateFrame</a>, and <a class="el" href="classstormm_1_1structure_1_1PhaseSpace.html" title="An object to complement a topology and hold positions, velocities, and forces of all particles in a s...">PhaseSpace</a>, and <a class="el" href="classstormm_1_1structure_1_1PhaseSpaceSynthesis.html" title="A fixed-precision representation of coordinates, velocities, and forces to manage a set of simulation...">PhaseSpaceSynthesis</a> objects, or new frames can be added from <a class="el" href="classstormm_1_1structure_1_1CoordinateFrame.html" title="Store the coordinates and box information for a frame, only. This abridged struct can serve when the ...">CoordinateFrame</a> objects. This object is not the <a class="el" href="classstormm_1_1structure_1_1CoordinateFrame.html" title="Store the coordinates and box information for a frame, only. This abridged struct can serve when the ...">CoordinateFrame</a> equivalent of a <a class="el" href="classstormm_1_1structure_1_1PhaseSpaceSynthesis.html" title="A fixed-precision representation of coordinates, velocities, and forces to manage a set of simulation...">PhaseSpaceSynthesis</a> object, however: its purpose is to collect only the coordinates of many frames of a single system at the appropriate level of precision.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="coordinate__series_8h_source.html">coordinate_series.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac9bf6a44869601feddbfd8bdc02f320f" id="r_ac9bf6a44869601feddbfd8bdc02f320f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9bf6a44869601feddbfd8bdc02f320f">CoordinateSeries</a> (const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateSeries.html">CoordinateSeries</a> &amp;original, HybridFormat format_in)</td></tr>
<tr class="memdesc:ac9bf6a44869601feddbfd8bdc02f320f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A special copy constructor can create an object with an altered memory format.  <br /></td></tr>
<tr class="separator:ac9bf6a44869601feddbfd8bdc02f320f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92bf75c6d446aa8cef46a50786e2321a" id="r_a92bf75c6d446aa8cef46a50786e2321a"><td class="memItemLeft" align="right" valign="top"><a id="a92bf75c6d446aa8cef46a50786e2321a" name="a92bf75c6d446aa8cef46a50786e2321a"></a>
HybridFormat&#160;</td><td class="memItemRight" valign="bottom"><b>getFormat</b> () const</td></tr>
<tr class="memdesc:a92bf75c6d446aa8cef46a50786e2321a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the memory format. <br /></td></tr>
<tr class="separator:a92bf75c6d446aa8cef46a50786e2321a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab86e66625c229765f11d31e937472662" id="r_ab86e66625c229765f11d31e937472662"><td class="memItemLeft" align="right" valign="top"><a id="ab86e66625c229765f11d31e937472662" name="ab86e66625c229765f11d31e937472662"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getAtomCount</b> () const</td></tr>
<tr class="memdesc:ab86e66625c229765f11d31e937472662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of atoms in each frame of the series. <br /></td></tr>
<tr class="separator:ab86e66625c229765f11d31e937472662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2281e251738a1999d1dec28d0b45a9aa" id="r_a2281e251738a1999d1dec28d0b45a9aa"><td class="memItemLeft" align="right" valign="top"><a id="a2281e251738a1999d1dec28d0b45a9aa" name="a2281e251738a1999d1dec28d0b45a9aa"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getFrameCount</b> () const</td></tr>
<tr class="memdesc:a2281e251738a1999d1dec28d0b45a9aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of frames in the series. <br /></td></tr>
<tr class="separator:a2281e251738a1999d1dec28d0b45a9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3563e07b8f8761caf8eccc39e49a9bd3" id="r_a3563e07b8f8761caf8eccc39e49a9bd3"><td class="memItemLeft" align="right" valign="top"><a id="a3563e07b8f8761caf8eccc39e49a9bd3" name="a3563e07b8f8761caf8eccc39e49a9bd3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getFrameCapacity</b> () const</td></tr>
<tr class="memdesc:a3563e07b8f8761caf8eccc39e49a9bd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum number of frames that the object can hold. <br /></td></tr>
<tr class="separator:a3563e07b8f8761caf8eccc39e49a9bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49af708c5824375ce960610455dd2222" id="r_a49af708c5824375ce960610455dd2222"><td class="memItemLeft" align="right" valign="top"><a id="a49af708c5824375ce960610455dd2222" name="a49af708c5824375ce960610455dd2222"></a>
UnitCellType&#160;</td><td class="memItemRight" valign="bottom"><b>getUnitCellType</b> () const</td></tr>
<tr class="memdesc:a49af708c5824375ce960610455dd2222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unit cell type of the coordinate system. <br /></td></tr>
<tr class="separator:a49af708c5824375ce960610455dd2222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8328c462c653174b0a6247bae6fd7eb" id="r_ac8328c462c653174b0a6247bae6fd7eb"><td class="memItemLeft" align="right" valign="top"><a id="ac8328c462c653174b0a6247bae6fd7eb" name="ac8328c462c653174b0a6247bae6fd7eb"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getFixedPrecisionBits</b> () const</td></tr>
<tr class="memdesc:ac8328c462c653174b0a6247bae6fd7eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the fixed precision bits after the decimal (if applicable, warn if the data type is non-integer). <br /></td></tr>
<tr class="separator:ac8328c462c653174b0a6247bae6fd7eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30333cf52fbac843369caee3a013a9ba" id="r_a30333cf52fbac843369caee3a013a9ba"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30333cf52fbac843369caee3a013a9ba">getBoxSpaceTransform</a> (int frame_index, HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:a30333cf52fbac843369caee3a013a9ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the transformation matrix to take coordinates into box (fractional) space. The result should be interpreted as a 3x3 matrix in column-major format.  <br /></td></tr>
<tr class="separator:a30333cf52fbac843369caee3a013a9ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fdfc66717964f35c59a537069bde0d1" id="r_a3fdfc66717964f35c59a537069bde0d1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3fdfc66717964f35c59a537069bde0d1">getInverseTransform</a> (int frame_index, HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:a3fdfc66717964f35c59a537069bde0d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the transformation matrix to take coordinates from fractional space back into real space. The result should be interpreted as a 3x3 matrix in column-major format.  <br /></td></tr>
<tr class="separator:a3fdfc66717964f35c59a537069bde0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad012d39dcb1d47e753cacbb8ffef92" id="r_a6ad012d39dcb1d47e753cacbb8ffef92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ad012d39dcb1d47e753cacbb8ffef92">exportFrame</a> (size_t frame_index, HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:a6ad012d39dcb1d47e753cacbb8ffef92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare a <a class="el" href="classstormm_1_1structure_1_1CoordinateFrame.html" title="Store the coordinates and box information for a frame, only. This abridged struct can serve when the ...">CoordinateFrame</a> object based on one frame of the series, accomplishing any necessary data conversions to put the coordinates back into the familiar double-precision format.  <br /></td></tr>
<tr class="separator:a6ad012d39dcb1d47e753cacbb8ffef92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e0a22bf3848c5172e83cbd1290a266" id="r_af7e0a22bf3848c5172e83cbd1290a266"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html">PhaseSpace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7e0a22bf3848c5172e83cbd1290a266">exportPhaseSpace</a> (size_t frame_index, HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:af7e0a22bf3848c5172e83cbd1290a266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare a <a class="el" href="classstormm_1_1structure_1_1PhaseSpace.html" title="An object to complement a topology and hold positions, velocities, and forces of all particles in a s...">PhaseSpace</a> object based on one frame of the series, accomplishing any data conversions needed to put the coordinates back into the familiar double-precision format.  <br /></td></tr>
<tr class="separator:af7e0a22bf3848c5172e83cbd1290a266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75699e5b3e2aa61af103039efe26ab55" id="r_a75699e5b3e2aa61af103039efe26ab55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75699e5b3e2aa61af103039efe26ab55">exportToFile</a> (const std::string &amp;file_name, CoordinateFileKind output_kind=CoordinateFileKind::AMBER_CRD, PrintSituation expectation=PrintSituation::UNKNOWN, int low_index=0, int high_index=0, HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:a75699e5b3e2aa61af103039efe26ab55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export the contents of this coordinate series to a trajectory file.  <br /></td></tr>
<tr class="separator:a75699e5b3e2aa61af103039efe26ab55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c34348feecb335e6a346b0a08ed290" id="r_a07c34348feecb335e6a346b0a08ed290"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07c34348feecb335e6a346b0a08ed290">getCoordinateReference</a> (CartesianDimension dim) const</td></tr>
<tr class="memdesc:a07c34348feecb335e6a346b0a08ed290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reference to the one of the Cartesian coordinate arrays.  <br /></td></tr>
<tr class="separator:a07c34348feecb335e6a346b0a08ed290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e7c3d7d57f3fa31deaff2df27b8c1a4" id="r_a4e7c3d7d57f3fa31deaff2df27b8c1a4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e7c3d7d57f3fa31deaff2df27b8c1a4">getCoordinatePointer</a> (CartesianDimension dim) const</td></tr>
<tr class="memdesc:a4e7c3d7d57f3fa31deaff2df27b8c1a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const pointer to one of the Cartesian coordinate arrays.  <br /></td></tr>
<tr class="separator:a4e7c3d7d57f3fa31deaff2df27b8c1a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ddc1e0042abfd2065365f429eb420ad" id="r_a0ddc1e0042abfd2065365f429eb420ad"><td class="memItemLeft" align="right" valign="top"><a id="a0ddc1e0042abfd2065365f429eb420ad" name="a0ddc1e0042abfd2065365f429eb420ad"></a>
const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getBoxTransforms</b> () const</td></tr>
<tr class="memdesc:a0ddc1e0042abfd2065365f429eb420ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reference to the box space transformation matrices. <br /></td></tr>
<tr class="separator:a0ddc1e0042abfd2065365f429eb420ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6149557d5bcfd39a841c9cea67f8fdf1" id="r_a6149557d5bcfd39a841c9cea67f8fdf1"><td class="memItemLeft" align="right" valign="top"><a id="a6149557d5bcfd39a841c9cea67f8fdf1" name="a6149557d5bcfd39a841c9cea67f8fdf1"></a>
const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; double &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>getBoxTransformPointer</b> () const</td></tr>
<tr class="memdesc:a6149557d5bcfd39a841c9cea67f8fdf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const pointer to the box space transformation matrices. <br /></td></tr>
<tr class="separator:a6149557d5bcfd39a841c9cea67f8fdf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a940e624781ecf4e7a4e9d123b57a5bfa" id="r_a940e624781ecf4e7a4e9d123b57a5bfa"><td class="memItemLeft" align="right" valign="top"><a id="a940e624781ecf4e7a4e9d123b57a5bfa" name="a940e624781ecf4e7a4e9d123b57a5bfa"></a>
const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getInverseTransforms</b> () const</td></tr>
<tr class="memdesc:a940e624781ecf4e7a4e9d123b57a5bfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reference to the box space transformation matrices. <br /></td></tr>
<tr class="separator:a940e624781ecf4e7a4e9d123b57a5bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e2befa9af5b1e07a30c2c5c8378135f" id="r_a4e2befa9af5b1e07a30c2c5c8378135f"><td class="memItemLeft" align="right" valign="top"><a id="a4e2befa9af5b1e07a30c2c5c8378135f" name="a4e2befa9af5b1e07a30c2c5c8378135f"></a>
const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; double &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>getInverseTransformPointer</b> () const</td></tr>
<tr class="memdesc:a4e2befa9af5b1e07a30c2c5c8378135f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const pointer to the box space transformation matrices. <br /></td></tr>
<tr class="separator:a4e2befa9af5b1e07a30c2c5c8378135f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f33e71815d5ace5cddebc34665931b2" id="r_a9f33e71815d5ace5cddebc34665931b2"><td class="memItemLeft" align="right" valign="top"><a id="a9f33e71815d5ace5cddebc34665931b2" name="a9f33e71815d5ace5cddebc34665931b2"></a>
const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; double &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>getBoxDimensionPointer</b> () const</td></tr>
<tr class="memdesc:a9f33e71815d5ace5cddebc34665931b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const pointer to the list of box dimensions for all frames. <br /></td></tr>
<tr class="separator:a9f33e71815d5ace5cddebc34665931b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad51227bfe2c77c89633eb0c4f38ac8" id="r_a8ad51227bfe2c77c89633eb0c4f38ac8"><td class="memItemLeft" align="right" valign="top"><a id="a8ad51227bfe2c77c89633eb0c4f38ac8" name="a8ad51227bfe2c77c89633eb0c4f38ac8"></a>
const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateSeries.html">CoordinateSeries</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>getSelfPointer</b> () const</td></tr>
<tr class="memdesc:a8ad51227bfe2c77c89633eb0c4f38ac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const pointer to the object iself, so that it may be passed to functions by const reference and still emit a const poiner. <br /></td></tr>
<tr class="separator:a8ad51227bfe2c77c89633eb0c4f38ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43d1eda1a2c6331281ad1ffbcc1899a" id="r_ab43d1eda1a2c6331281ad1ffbcc1899a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab43d1eda1a2c6331281ad1ffbcc1899a">importFromFile</a> (const std::string &amp;file_name, CoordinateFileKind file_kind=CoordinateFileKind::UNKNOWN, const std::vector&lt; int &gt; &amp;frame_numbers={}, int replica_count=1, int frame_index_start=-1)</td></tr>
<tr class="memdesc:ab43d1eda1a2c6331281ad1ffbcc1899a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import coordinates from a file. This function accepts directives to read a subset of the coordinates and integrate them into the series at a specified point.  <br /></td></tr>
<tr class="separator:ab43d1eda1a2c6331281ad1ffbcc1899a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b7d452d042d841f28e8b1776ba9eae" id="r_a47b7d452d042d841f28e8b1776ba9eae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47b7d452d042d841f28e8b1776ba9eae">reserve</a> (const int new_frame_capacity)</td></tr>
<tr class="memdesc:a47b7d452d042d841f28e8b1776ba9eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve capacity in this series. The new frames will be uninitialized.  <br /></td></tr>
<tr class="separator:a47b7d452d042d841f28e8b1776ba9eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02f2c3a22ebb702c7436a69a32855bf" id="r_ae02f2c3a22ebb702c7436a69a32855bf"><td class="memItemLeft" align="right" valign="top"><a id="ae02f2c3a22ebb702c7436a69a32855bf" name="ae02f2c3a22ebb702c7436a69a32855bf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>shrinkToFit</b> ()</td></tr>
<tr class="memdesc:ae02f2c3a22ebb702c7436a69a32855bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shrink the object's various arrays to accommodate only the current frame and atom counts. Mimics the Standard Template Library vector shrink_to_fit() member function. <br /></td></tr>
<tr class="separator:ae02f2c3a22ebb702c7436a69a32855bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a177c3972176420bdd8e125df6f222135" id="r_a177c3972176420bdd8e125df6f222135"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a177c3972176420bdd8e125df6f222135">CoordinateSeries</a> (int natom_in=0, int nframe_in=0, UnitCellType unit_cell_in=UnitCellType::NONE, int globalpos_scale_bits_in=0, HybridFormat format_in=default_hpc_format)</td></tr>
<tr class="memdesc:a177c3972176420bdd8e125df6f222135"><td class="mdescLeft">&#160;</td><td class="mdescRight">There are several options for constructing this collection of coordinate frames.  <br /></td></tr>
<tr class="separator:a177c3972176420bdd8e125df6f222135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc556a14b33722e1863e955d159e42e5" id="r_acc556a14b33722e1863e955d159e42e5"><td class="memItemLeft" align="right" valign="top"><a id="acc556a14b33722e1863e955d159e42e5" name="acc556a14b33722e1863e955d159e42e5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CoordinateSeries</b> (const std::string &amp;file_name, int atom_count_in=0, CoordinateFileKind file_kind=CoordinateFileKind::UNKNOWN, const std::vector&lt; int &gt; &amp;frame_numbers={}, int replica_count=1, UnitCellType unit_cell_in=UnitCellType::NONE, int globalpos_scale_bits_in=0, HybridFormat format_in=default_hpc_format)</td></tr>
<tr class="separator:acc556a14b33722e1863e955d159e42e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c320d59f7d3c966815d65fba2e77a39" id="r_a7c320d59f7d3c966815d65fba2e77a39"><td class="memItemLeft" align="right" valign="top"><a id="a7c320d59f7d3c966815d65fba2e77a39" name="a7c320d59f7d3c966815d65fba2e77a39"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CoordinateSeries</b> (<a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html">PhaseSpace</a> *ps, int nframe_in, int globalpos_scale_bits_in=0, HybridFormat format_in=default_hpc_format)</td></tr>
<tr class="separator:a7c320d59f7d3c966815d65fba2e77a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81c823ab37f2f89a84462d0027ec92d8" id="r_a81c823ab37f2f89a84462d0027ec92d8"><td class="memItemLeft" align="right" valign="top"><a id="a81c823ab37f2f89a84462d0027ec92d8" name="a81c823ab37f2f89a84462d0027ec92d8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CoordinateSeries</b> (const <a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html">PhaseSpace</a> &amp;ps, int nframe_in, int globalpos_scale_bits_in=0, HybridFormat format_in=default_hpc_format)</td></tr>
<tr class="separator:a81c823ab37f2f89a84462d0027ec92d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4684491ff7908ed4fdc9fc1f47d7c4" id="r_a3d4684491ff7908ed4fdc9fc1f47d7c4"><td class="memItemLeft" align="right" valign="top"><a id="a3d4684491ff7908ed4fdc9fc1f47d7c4" name="a3d4684491ff7908ed4fdc9fc1f47d7c4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CoordinateSeries</b> (<a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> *cf, int nframe_in, int globalpos_scale_bits_in=0, HybridFormat format_in=default_hpc_format)</td></tr>
<tr class="separator:a3d4684491ff7908ed4fdc9fc1f47d7c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e322ded64da7c21be6f40942af5424a" id="r_a4e322ded64da7c21be6f40942af5424a"><td class="memItemLeft" align="right" valign="top"><a id="a4e322ded64da7c21be6f40942af5424a" name="a4e322ded64da7c21be6f40942af5424a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CoordinateSeries</b> (const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> &amp;cf, int nframe_in, int globalpos_scale_bits_in=0, HybridFormat format_in=default_hpc_format)</td></tr>
<tr class="separator:a4e322ded64da7c21be6f40942af5424a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6ec4d3677f41ae0403d59f75b450434f" id="r_a6ec4d3677f41ae0403d59f75b450434f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ec4d3677f41ae0403d59f75b450434f">CoordinateSeries</a> (const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateSeries.html">CoordinateSeries</a> &amp;original)=default</td></tr>
<tr class="memdesc:a6ec4d3677f41ae0403d59f75b450434f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the default copy and move constructors, copy and move assignment operators. This object has no const members to trigger implicit deletions and no POINTER-kind <a class="el" href="classstormm_1_1structure_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> objects to repair.  <br /></td></tr>
<tr class="separator:a6ec4d3677f41ae0403d59f75b450434f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37cc035002f3b8fdb20f3b9975920fa3" id="r_a37cc035002f3b8fdb20f3b9975920fa3"><td class="memItemLeft" align="right" valign="top"><a id="a37cc035002f3b8fdb20f3b9975920fa3" name="a37cc035002f3b8fdb20f3b9975920fa3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CoordinateSeries</b> (<a class="el" href="classstormm_1_1trajectory_1_1CoordinateSeries.html">CoordinateSeries</a> &amp;&amp;original)=default</td></tr>
<tr class="separator:a37cc035002f3b8fdb20f3b9975920fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c961e8e244ca576ae88ee7d3fae157" id="r_ae0c961e8e244ca576ae88ee7d3fae157"><td class="memItemLeft" align="right" valign="top"><a id="ae0c961e8e244ca576ae88ee7d3fae157" name="ae0c961e8e244ca576ae88ee7d3fae157"></a>
<a class="el" href="classstormm_1_1trajectory_1_1CoordinateSeries.html">CoordinateSeries</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateSeries.html">CoordinateSeries</a> &amp;other)=default</td></tr>
<tr class="separator:ae0c961e8e244ca576ae88ee7d3fae157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e19c01e1c1a6af1c5747e9eff8938e" id="r_aa8e19c01e1c1a6af1c5747e9eff8938e"><td class="memItemLeft" align="right" valign="top"><a id="aa8e19c01e1c1a6af1c5747e9eff8938e" name="aa8e19c01e1c1a6af1c5747e9eff8938e"></a>
<a class="el" href="classstormm_1_1trajectory_1_1CoordinateSeries.html">CoordinateSeries</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classstormm_1_1trajectory_1_1CoordinateSeries.html">CoordinateSeries</a> &amp;&amp;other)=default</td></tr>
<tr class="separator:aa8e19c01e1c1a6af1c5747e9eff8938e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0468a0a4147cccfa4e0fd7e950e1d2ff" id="r_a0468a0a4147cccfa4e0fd7e950e1d2ff"><td class="memTemplParams" colspan="2">template&lt;typename Toriginal&gt; </td></tr>
<tr class="memitem:a0468a0a4147cccfa4e0fd7e950e1d2ff"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0468a0a4147cccfa4e0fd7e950e1d2ff">CoordinateSeries</a> (const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateSeries.html">CoordinateSeries</a>&lt; Toriginal &gt; &amp;original, int globalpos_scale_bits_in=0, HybridFormat format_in=default_hpc_format)</td></tr>
<tr class="memdesc:a0468a0a4147cccfa4e0fd7e950e1d2ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special copy constructor to take a <a class="el" href="classstormm_1_1structure_1_1CoordinateSeries.html" title="Store the coordinates and box information for a series of frames, in one of several levels of precisi...">CoordinateSeries</a> of one data type into another. The implementation requires a special declaration (template &lt;typename T&gt; template &lt;typename Toriginal&gt;...) with two uses of the template keyword because of the nested nature of these templates. In other contexts template &lt;typename T, typename Toriginal&gt; would suffice.  <br /></td></tr>
<tr class="separator:a0468a0a4147cccfa4e0fd7e950e1d2ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae90cfaaab36b52ef864ee1b02c2fa596" id="r_ae90cfaaab36b52ef864ee1b02c2fa596"><td class="memTemplParams" colspan="2">template&lt;typename Treport&gt; </td></tr>
<tr class="memitem:ae90cfaaab36b52ef864ee1b02c2fa596"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Treport &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae90cfaaab36b52ef864ee1b02c2fa596">getInterlacedCoordinates</a> (int frame_index, int globalpos_bits_out=-1, HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:ae90cfaaab36b52ef864ee1b02c2fa596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the interlaced coordinates of one frame.  <br /></td></tr>
<tr class="separator:ae90cfaaab36b52ef864ee1b02c2fa596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbef19c342882476d4efe534eed4145f" id="r_afbef19c342882476d4efe534eed4145f"><td class="memTemplParams" colspan="2"><a id="afbef19c342882476d4efe534eed4145f" name="afbef19c342882476d4efe534eed4145f"></a>
template&lt;typename Treport&gt; </td></tr>
<tr class="memitem:afbef19c342882476d4efe534eed4145f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Treport &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getInterlacedCoordinates</b> (int frame_index, int low_index, int high_index, int globalpos_bits_out=-1, HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="separator:afbef19c342882476d4efe534eed4145f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a73890c3740e9af7014f2a829a2845694" id="r_a73890c3740e9af7014f2a829a2845694"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a73890c3740e9af7014f2a829a2845694">getBoxDimensions</a> (int frame_index, HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:a73890c3740e9af7014f2a829a2845694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the box dimensions in their pure form for a particular frame.  <br /></td></tr>
<tr class="separator:a73890c3740e9af7014f2a829a2845694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d2326d9433cc11d1cbb1d7514fbd1c6" id="r_a7d2326d9433cc11d1cbb1d7514fbd1c6"><td class="memItemLeft" align="right" valign="top"><a id="a7d2326d9433cc11d1cbb1d7514fbd1c6" name="a7d2326d9433cc11d1cbb1d7514fbd1c6"></a>
const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getBoxDimensions</b> () const</td></tr>
<tr class="separator:a7d2326d9433cc11d1cbb1d7514fbd1c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a646f471e3d9e37cf7396ba47916ba30a" id="r_a646f471e3d9e37cf7396ba47916ba30a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a646f471e3d9e37cf7396ba47916ba30a">extractFrame</a> (<a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> *cf, size_t frame_index, const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;gpu) const</td></tr>
<tr class="memdesc:a646f471e3d9e37cf7396ba47916ba30a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract coordinates to a pre-existing object.  <br /></td></tr>
<tr class="separator:a646f471e3d9e37cf7396ba47916ba30a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa46a1a1b82a6fde240674539b9c0cb5c" id="r_aa46a1a1b82a6fde240674539b9c0cb5c"><td class="memItemLeft" align="right" valign="top"><a id="aa46a1a1b82a6fde240674539b9c0cb5c" name="aa46a1a1b82a6fde240674539b9c0cb5c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>extractFrame</b> (<a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html">PhaseSpace</a> *ps, size_t frame_index, TrajectoryKind kind, CoordinateCycle time_point, const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;gpu) const</td></tr>
<tr class="separator:aa46a1a1b82a6fde240674539b9c0cb5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e389b70f0346791f1be913e0ec4b296" id="r_a8e389b70f0346791f1be913e0ec4b296"><td class="memItemLeft" align="right" valign="top"><a id="a8e389b70f0346791f1be913e0ec4b296" name="a8e389b70f0346791f1be913e0ec4b296"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>extractFrame</b> (<a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html">PhaseSpace</a> *ps, size_t frame_index, TrajectoryKind kind, const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;gpu) const</td></tr>
<tr class="separator:a8e389b70f0346791f1be913e0ec4b296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d914c13c5102abd0b72ea52b7247d61" id="r_a6d914c13c5102abd0b72ea52b7247d61"><td class="memItemLeft" align="right" valign="top"><a id="a6d914c13c5102abd0b72ea52b7247d61" name="a6d914c13c5102abd0b72ea52b7247d61"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>extractFrame</b> (<a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html">PhaseSpace</a> *ps, size_t frame_index, const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;gpu) const</td></tr>
<tr class="separator:a6d914c13c5102abd0b72ea52b7247d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2954f9f57271566ea5a121f0dda23a4e" id="r_a2954f9f57271566ea5a121f0dda23a4e"><td class="memItemLeft" align="right" valign="top"><a id="a2954f9f57271566ea5a121f0dda23a4e" name="a2954f9f57271566ea5a121f0dda23a4e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>extractFrame</b> (<a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> *cf, size_t frame_index, HybridTargetLevel tier) const</td></tr>
<tr class="separator:a2954f9f57271566ea5a121f0dda23a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83db7a66f5418830d70c492d80a71ef9" id="r_a83db7a66f5418830d70c492d80a71ef9"><td class="memItemLeft" align="right" valign="top"><a id="a83db7a66f5418830d70c492d80a71ef9" name="a83db7a66f5418830d70c492d80a71ef9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>extractFrame</b> (<a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html">PhaseSpace</a> *ps, size_t frame_index, TrajectoryKind kind, CoordinateCycle time_point, HybridTargetLevel tier) const</td></tr>
<tr class="separator:a83db7a66f5418830d70c492d80a71ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd85468a2d52076746d39fe2ae47b9f9" id="r_acd85468a2d52076746d39fe2ae47b9f9"><td class="memItemLeft" align="right" valign="top"><a id="acd85468a2d52076746d39fe2ae47b9f9" name="acd85468a2d52076746d39fe2ae47b9f9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>extractFrame</b> (<a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html">PhaseSpace</a> *ps, size_t frame_index, TrajectoryKind kind, HybridTargetLevel tier) const</td></tr>
<tr class="separator:acd85468a2d52076746d39fe2ae47b9f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2c71c70c2fc7e1c3a9cfc825e0b3c5" id="r_a1b2c71c70c2fc7e1c3a9cfc825e0b3c5"><td class="memItemLeft" align="right" valign="top"><a id="a1b2c71c70c2fc7e1c3a9cfc825e0b3c5" name="a1b2c71c70c2fc7e1c3a9cfc825e0b3c5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>extractFrame</b> (<a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html">PhaseSpace</a> *ps, size_t frame_index, HybridTargetLevel tier) const</td></tr>
<tr class="separator:a1b2c71c70c2fc7e1c3a9cfc825e0b3c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa9d6b0e0f3b497416edd03d263ab04da" id="r_aa9d6b0e0f3b497416edd03d263ab04da"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9d6b0e0f3b497416edd03d263ab04da">getFramesHandle</a> (CartesianDimension dim) const</td></tr>
<tr class="memdesc:aa9d6b0e0f3b497416edd03d263ab04da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to one of the coordinate arrays.  <br /></td></tr>
<tr class="separator:aa9d6b0e0f3b497416edd03d263ab04da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54630739eeefbf2efd57bd10914a70d4" id="r_a54630739eeefbf2efd57bd10914a70d4"><td class="memItemLeft" align="right" valign="top"><a id="a54630739eeefbf2efd57bd10914a70d4" name="a54630739eeefbf2efd57bd10914a70d4"></a>
<a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>getFramesHandle</b> (CartesianDimension dim)</td></tr>
<tr class="separator:a54630739eeefbf2efd57bd10914a70d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ace14ee52d196ecf0181858abbf4d2f5c" id="r_ace14ee52d196ecf0181858abbf4d2f5c"><td class="memItemLeft" align="right" valign="top"><a id="ace14ee52d196ecf0181858abbf4d2f5c" name="ace14ee52d196ecf0181858abbf4d2f5c"></a>
const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; double &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>getBoxTransformsHandle</b> () const</td></tr>
<tr class="memdesc:ace14ee52d196ecf0181858abbf4d2f5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the box space transform. Overloading follows from getCoordinateHandle(), above. <br /></td></tr>
<tr class="separator:ace14ee52d196ecf0181858abbf4d2f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a743ca7b68e8050c6a05b15a0f536d12c" id="r_a743ca7b68e8050c6a05b15a0f536d12c"><td class="memItemLeft" align="right" valign="top"><a id="a743ca7b68e8050c6a05b15a0f536d12c" name="a743ca7b68e8050c6a05b15a0f536d12c"></a>
<a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; double &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>getBoxTransformsHandle</b> ()</td></tr>
<tr class="separator:a743ca7b68e8050c6a05b15a0f536d12c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae2a26e5e00a43f1c7b648bb1a14e2eec" id="r_ae2a26e5e00a43f1c7b648bb1a14e2eec"><td class="memItemLeft" align="right" valign="top"><a id="ae2a26e5e00a43f1c7b648bb1a14e2eec" name="ae2a26e5e00a43f1c7b648bb1a14e2eec"></a>
const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; double &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>getInverseTransformsHandle</b> () const</td></tr>
<tr class="memdesc:ae2a26e5e00a43f1c7b648bb1a14e2eec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the inverse transform that takes coordinates back into real space. Overloading follows from getCoordinateHandle(), above. <br /></td></tr>
<tr class="separator:ae2a26e5e00a43f1c7b648bb1a14e2eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7052095bfaf4494cd4fe5a418e2241bf" id="r_a7052095bfaf4494cd4fe5a418e2241bf"><td class="memItemLeft" align="right" valign="top"><a id="a7052095bfaf4494cd4fe5a418e2241bf" name="a7052095bfaf4494cd4fe5a418e2241bf"></a>
<a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; double &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>getInverseTransformsHandle</b> ()</td></tr>
<tr class="separator:a7052095bfaf4494cd4fe5a418e2241bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:afba0997980a1f564ad67bac056bd9256" id="r_afba0997980a1f564ad67bac056bd9256"><td class="memItemLeft" align="right" valign="top"><a id="afba0997980a1f564ad67bac056bd9256" name="afba0997980a1f564ad67bac056bd9256"></a>
const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; double &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>getBoxDimensionsHandle</b> () const</td></tr>
<tr class="memdesc:afba0997980a1f564ad67bac056bd9256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the transform that takes coordinates back into real space. Overloading follows from getCoordinateHandle(), above. <br /></td></tr>
<tr class="separator:afba0997980a1f564ad67bac056bd9256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d538e15d82366acbfef7436ef9056f" id="r_ac7d538e15d82366acbfef7436ef9056f"><td class="memItemLeft" align="right" valign="top"><a id="ac7d538e15d82366acbfef7436ef9056f" name="ac7d538e15d82366acbfef7436ef9056f"></a>
<a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; double &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>getBoxDimensionsHandle</b> ()</td></tr>
<tr class="separator:ac7d538e15d82366acbfef7436ef9056f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a302b0807bb30c15d56de623df9ffd0f2" id="r_a302b0807bb30c15d56de623df9ffd0f2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structstormm_1_1trajectory_1_1CoordinateSeriesReader.html">CoordinateSeriesReader</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a302b0807bb30c15d56de623df9ffd0f2">data</a> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:a302b0807bb30c15d56de623df9ffd0f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the abstract for this object, containing C-style pointers for the most rapid access to any of its member variables.  <br /></td></tr>
<tr class="separator:a302b0807bb30c15d56de623df9ffd0f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8068b63e7969c680b53e30216cf875ba" id="r_a8068b63e7969c680b53e30216cf875ba"><td class="memItemLeft" align="right" valign="top"><a id="a8068b63e7969c680b53e30216cf875ba" name="a8068b63e7969c680b53e30216cf875ba"></a>
<a class="el" href="structstormm_1_1trajectory_1_1CoordinateSeriesWriter.html">CoordinateSeriesWriter</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> (HybridTargetLevel tier=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:a8068b63e7969c680b53e30216cf875ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa2884c54f49573b82903c200d1f1c06c" id="r_aa2884c54f49573b82903c200d1f1c06c"><td class="memItemLeft" align="right" valign="top"><a id="aa2884c54f49573b82903c200d1f1c06c" name="aa2884c54f49573b82903c200d1f1c06c"></a>
const <a class="el" href="structstormm_1_1trajectory_1_1CoordinateSeriesReader.html">CoordinateSeriesReader</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>templateFreeData</b> (HybridTargetLevel tier=HybridTargetLevel::HOST) const</td></tr>
<tr class="memdesc:aa2884c54f49573b82903c200d1f1c06c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the object's abstract, with all templated type pointers cast to void pointers. The true data type can be encoded in a separate 64-bit unsigned integer code (use std::type_index() as seen in <a class="el" href="common__types_8h_source.html">DataTypes/common_types.h</a>). Parameter descriptions and overloading match those in <a class="el" href="classstormm_1_1trajectory_1_1CoordinateSeries.html#a302b0807bb30c15d56de623df9ffd0f2" title="Get the abstract for this object, containing C-style pointers for the most rapid access to any of its...">data()</a> above. <br /></td></tr>
<tr class="separator:aa2884c54f49573b82903c200d1f1c06c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4966d64716fbdc5265b0f09cef389c36" id="r_a4966d64716fbdc5265b0f09cef389c36"><td class="memItemLeft" align="right" valign="top"><a id="a4966d64716fbdc5265b0f09cef389c36" name="a4966d64716fbdc5265b0f09cef389c36"></a>
<a class="el" href="structstormm_1_1trajectory_1_1CoordinateSeriesWriter.html">CoordinateSeriesWriter</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>templateFreeData</b> (HybridTargetLevel tier=HybridTargetLevel::HOST)</td></tr>
<tr class="separator:a4966d64716fbdc5265b0f09cef389c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4786d8334443767edd10617e3d5a0c6f" id="r_a4786d8334443767edd10617e3d5a0c6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4786d8334443767edd10617e3d5a0c6f">importFrame</a> (const <a class="el" href="structstormm_1_1trajectory_1_1CoordinateFrameReader.html">CoordinateFrameReader</a> &amp;cfr, int atom_start, int atom_end, int frame_index=-1)</td></tr>
<tr class="memdesc:a4786d8334443767edd10617e3d5a0c6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import coordinates from a <a class="el" href="classstormm_1_1structure_1_1CoordinateFrame.html" title="Store the coordinates and box information for a frame, only. This abridged struct can serve when the ...">CoordinateFrame</a> or <a class="el" href="classstormm_1_1structure_1_1PhaseSpace.html" title="An object to complement a topology and hold positions, velocities, and forces of all particles in a s...">PhaseSpace</a> object. The original object must have the same number of atoms as the <a class="el" href="classstormm_1_1structure_1_1CoordinateSeries.html" title="Store the coordinates and box information for a series of frames, in one of several levels of precisi...">CoordinateSeries</a> itself, or else a range of atoms within the original coordinate object must be specified that fits the <a class="el" href="classstormm_1_1structure_1_1CoordinateSeries.html" title="Store the coordinates and box information for a series of frames, in one of several levels of precisi...">CoordinateSeries</a>. The default behavior is to push the new coordinates to the back of the list, but any frame index within the bounds of the current list may also be specified.  <br /></td></tr>
<tr class="separator:a4786d8334443767edd10617e3d5a0c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa241dcb548969d2559e15bd8317598b1" id="r_aa241dcb548969d2559e15bd8317598b1"><td class="memItemLeft" align="right" valign="top"><a id="aa241dcb548969d2559e15bd8317598b1" name="aa241dcb548969d2559e15bd8317598b1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>importFrame</b> (const <a class="el" href="structstormm_1_1trajectory_1_1CoordinateFrameReader.html">CoordinateFrameReader</a> &amp;cfr, int frame_index=-1)</td></tr>
<tr class="separator:aa241dcb548969d2559e15bd8317598b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1681cf74991d7857885f3b2db715f3b1" id="r_a1681cf74991d7857885f3b2db715f3b1"><td class="memItemLeft" align="right" valign="top"><a id="a1681cf74991d7857885f3b2db715f3b1" name="a1681cf74991d7857885f3b2db715f3b1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>importFrame</b> (const <a class="el" href="structstormm_1_1trajectory_1_1CoordinateFrameWriter.html">CoordinateFrameWriter</a> &amp;cfw, int atom_start, int atom_end, int frame_index=-1)</td></tr>
<tr class="separator:a1681cf74991d7857885f3b2db715f3b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23490d6d7f3dd9a31948c2e6f381c847" id="r_a23490d6d7f3dd9a31948c2e6f381c847"><td class="memItemLeft" align="right" valign="top"><a id="a23490d6d7f3dd9a31948c2e6f381c847" name="a23490d6d7f3dd9a31948c2e6f381c847"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>importFrame</b> (const <a class="el" href="structstormm_1_1trajectory_1_1CoordinateFrameWriter.html">CoordinateFrameWriter</a> &amp;cfw, int frame_index=-1)</td></tr>
<tr class="separator:a23490d6d7f3dd9a31948c2e6f381c847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a616dad0314ce22498557f0a78e3c89" id="r_a3a616dad0314ce22498557f0a78e3c89"><td class="memItemLeft" align="right" valign="top"><a id="a3a616dad0314ce22498557f0a78e3c89" name="a3a616dad0314ce22498557f0a78e3c89"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>importFrame</b> (const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> &amp;cf, int atom_start, int atom_end, int frame_index=-1)</td></tr>
<tr class="separator:a3a616dad0314ce22498557f0a78e3c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30da6ecf462ab62db878a951575a43ea" id="r_a30da6ecf462ab62db878a951575a43ea"><td class="memItemLeft" align="right" valign="top"><a id="a30da6ecf462ab62db878a951575a43ea" name="a30da6ecf462ab62db878a951575a43ea"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>importFrame</b> (const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> &amp;cf, int frame_index=-1)</td></tr>
<tr class="separator:a30da6ecf462ab62db878a951575a43ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab537f34c144e51f7b66c89a4cf0dba" id="r_a2ab537f34c144e51f7b66c89a4cf0dba"><td class="memItemLeft" align="right" valign="top"><a id="a2ab537f34c144e51f7b66c89a4cf0dba" name="a2ab537f34c144e51f7b66c89a4cf0dba"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>importFrame</b> (const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> *cf, int atom_start, int atom_end, int frame_index=-1)</td></tr>
<tr class="separator:a2ab537f34c144e51f7b66c89a4cf0dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a076a25e3eee2e5a80536ada207514c4e" id="r_a076a25e3eee2e5a80536ada207514c4e"><td class="memItemLeft" align="right" valign="top"><a id="a076a25e3eee2e5a80536ada207514c4e" name="a076a25e3eee2e5a80536ada207514c4e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>importFrame</b> (const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> *cf, int frame_index=-1)</td></tr>
<tr class="separator:a076a25e3eee2e5a80536ada207514c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fccbe6b91263d4e15228c95dcd37418" id="r_a3fccbe6b91263d4e15228c95dcd37418"><td class="memItemLeft" align="right" valign="top"><a id="a3fccbe6b91263d4e15228c95dcd37418" name="a3fccbe6b91263d4e15228c95dcd37418"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>importFrame</b> (const <a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html">PhaseSpace</a> &amp;ps, int atom_start, int atom_end, int frame_index=-1, TrajectoryKind kind=TrajectoryKind::POSITIONS, CoordinateCycle orientation=CoordinateCycle::WHITE)</td></tr>
<tr class="separator:a3fccbe6b91263d4e15228c95dcd37418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf0b48334dc97d3ba7dc739990a09cb0" id="r_abf0b48334dc97d3ba7dc739990a09cb0"><td class="memItemLeft" align="right" valign="top"><a id="abf0b48334dc97d3ba7dc739990a09cb0" name="abf0b48334dc97d3ba7dc739990a09cb0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>importFrame</b> (const <a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html">PhaseSpace</a> &amp;ps, int frame_index=-1, TrajectoryKind kind=TrajectoryKind::POSITIONS, CoordinateCycle orientation=CoordinateCycle::WHITE)</td></tr>
<tr class="separator:abf0b48334dc97d3ba7dc739990a09cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01da5f77a404b4e0b3096bcac4472202" id="r_a01da5f77a404b4e0b3096bcac4472202"><td class="memItemLeft" align="right" valign="top"><a id="a01da5f77a404b4e0b3096bcac4472202" name="a01da5f77a404b4e0b3096bcac4472202"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>importFrame</b> (const <a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html">PhaseSpace</a> *ps, int atom_start, int atom_end, int frame_index=-1, TrajectoryKind kind=TrajectoryKind::POSITIONS, CoordinateCycle orientation=CoordinateCycle::WHITE)</td></tr>
<tr class="separator:a01da5f77a404b4e0b3096bcac4472202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486bcab974ebf1dcc69e2e28862144c4" id="r_a486bcab974ebf1dcc69e2e28862144c4"><td class="memItemLeft" align="right" valign="top"><a id="a486bcab974ebf1dcc69e2e28862144c4" name="a486bcab974ebf1dcc69e2e28862144c4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>importFrame</b> (const <a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html">PhaseSpace</a> *ps, int frame_index=-1, TrajectoryKind kind=TrajectoryKind::POSITIONS, CoordinateCycle orientation=CoordinateCycle::WHITE)</td></tr>
<tr class="separator:a486bcab974ebf1dcc69e2e28862144c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af920851814b2edb599d4c8d2d3bddb8b" id="r_af920851814b2edb599d4c8d2d3bddb8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af920851814b2edb599d4c8d2d3bddb8b">resize</a> (int new_frame_count)</td></tr>
<tr class="memdesc:af920851814b2edb599d4c8d2d3bddb8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the series, allocating new capacity if needed, initializing new frames with the provided coordinate set. ("New" frames are defined as any frames with indices greater than the original maximum index, regardless of whether new capacity was allocated to hold them or if the size simply increased within the existing space available.)  <br /></td></tr>
<tr class="separator:af920851814b2edb599d4c8d2d3bddb8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e362b6c6156f8508d4dacbcfb75bb9" id="r_a73e362b6c6156f8508d4dacbcfb75bb9"><td class="memItemLeft" align="right" valign="top"><a id="a73e362b6c6156f8508d4dacbcfb75bb9" name="a73e362b6c6156f8508d4dacbcfb75bb9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resize</b> (int new_frame_count, const <a class="el" href="structstormm_1_1trajectory_1_1CoordinateFrameReader.html">CoordinateFrameReader</a> &amp;cfr, int atom_start=0, int atom_end=0)</td></tr>
<tr class="separator:a73e362b6c6156f8508d4dacbcfb75bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad851934c1f5b91063f3f2afe371958af" id="r_ad851934c1f5b91063f3f2afe371958af"><td class="memItemLeft" align="right" valign="top"><a id="ad851934c1f5b91063f3f2afe371958af" name="ad851934c1f5b91063f3f2afe371958af"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resize</b> (int new_frame_count, const <a class="el" href="structstormm_1_1trajectory_1_1CoordinateFrameWriter.html">CoordinateFrameWriter</a> &amp;cfw, int atom_start=0, int atom_end=0)</td></tr>
<tr class="separator:ad851934c1f5b91063f3f2afe371958af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e0e6c9eb4b017bb876621837fda666" id="r_a60e0e6c9eb4b017bb876621837fda666"><td class="memItemLeft" align="right" valign="top"><a id="a60e0e6c9eb4b017bb876621837fda666" name="a60e0e6c9eb4b017bb876621837fda666"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resize</b> (int new_frame_count, const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> &amp;cf, int atom_start=0, int atom_end=0)</td></tr>
<tr class="separator:a60e0e6c9eb4b017bb876621837fda666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c50cb0a82a1b4d7de84c7513eff909" id="r_a24c50cb0a82a1b4d7de84c7513eff909"><td class="memItemLeft" align="right" valign="top"><a id="a24c50cb0a82a1b4d7de84c7513eff909" name="a24c50cb0a82a1b4d7de84c7513eff909"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resize</b> (int new_frame_count, <a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> *cf, int atom_start=0, int atom_end=0)</td></tr>
<tr class="separator:a24c50cb0a82a1b4d7de84c7513eff909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7482723f924caf515af54b1d952af0a4" id="r_a7482723f924caf515af54b1d952af0a4"><td class="memItemLeft" align="right" valign="top"><a id="a7482723f924caf515af54b1d952af0a4" name="a7482723f924caf515af54b1d952af0a4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resize</b> (int new_frame_count, const <a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html">PhaseSpace</a> &amp;ps, int atom_start=0, int atom_end=0)</td></tr>
<tr class="separator:a7482723f924caf515af54b1d952af0a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a9287788307d86cd91a7968665d874" id="r_ab4a9287788307d86cd91a7968665d874"><td class="memItemLeft" align="right" valign="top"><a id="ab4a9287788307d86cd91a7968665d874" name="ab4a9287788307d86cd91a7968665d874"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resize</b> (int new_frame_count, <a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html">PhaseSpace</a> *ps, int atom_start=0, int atom_end=0)</td></tr>
<tr class="separator:ab4a9287788307d86cd91a7968665d874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a7037f5778880d412a45e260423dd7c64" id="r_a7037f5778880d412a45e260423dd7c64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7037f5778880d412a45e260423dd7c64">pushBack</a> (const <a class="el" href="structstormm_1_1trajectory_1_1CoordinateFrameReader.html">CoordinateFrameReader</a> &amp;cfr, int atom_start=0, int atom_end=0)</td></tr>
<tr class="memdesc:a7037f5778880d412a45e260423dd7c64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push a coordinate set to the back of the list. This invokes the import member function after reallocating the frame series with 25% spare capacity if the original capacity is insufficient.  <br /></td></tr>
<tr class="separator:a7037f5778880d412a45e260423dd7c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f3338f5c04a952e15c499385e18c0d" id="r_a31f3338f5c04a952e15c499385e18c0d"><td class="memItemLeft" align="right" valign="top"><a id="a31f3338f5c04a952e15c499385e18c0d" name="a31f3338f5c04a952e15c499385e18c0d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pushBack</b> (const <a class="el" href="structstormm_1_1trajectory_1_1CoordinateFrameWriter.html">CoordinateFrameWriter</a> &amp;cfw, int atom_start=0, int atom_end=0)</td></tr>
<tr class="separator:a31f3338f5c04a952e15c499385e18c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277a5fde3a75c2c171010211d31cabf2" id="r_a277a5fde3a75c2c171010211d31cabf2"><td class="memItemLeft" align="right" valign="top"><a id="a277a5fde3a75c2c171010211d31cabf2" name="a277a5fde3a75c2c171010211d31cabf2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pushBack</b> (const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> &amp;cf, int atom_start=0, int atom_end=0)</td></tr>
<tr class="separator:a277a5fde3a75c2c171010211d31cabf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41710998693f266724b995fb11172342" id="r_a41710998693f266724b995fb11172342"><td class="memItemLeft" align="right" valign="top"><a id="a41710998693f266724b995fb11172342" name="a41710998693f266724b995fb11172342"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pushBack</b> (<a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> *cf, int atom_start=0, int atom_end=0)</td></tr>
<tr class="separator:a41710998693f266724b995fb11172342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad400461a634f82645714f6af37597087" id="r_ad400461a634f82645714f6af37597087"><td class="memItemLeft" align="right" valign="top"><a id="ad400461a634f82645714f6af37597087" name="ad400461a634f82645714f6af37597087"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pushBack</b> (const <a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html">PhaseSpace</a> &amp;ps, int atom_start=0, int atom_end=0)</td></tr>
<tr class="separator:ad400461a634f82645714f6af37597087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8ec3a5c3151823697564886a3af8d0" id="r_a0f8ec3a5c3151823697564886a3af8d0"><td class="memItemLeft" align="right" valign="top"><a id="a0f8ec3a5c3151823697564886a3af8d0" name="a0f8ec3a5c3151823697564886a3af8d0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pushBack</b> (<a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html">PhaseSpace</a> *ps, int atom_start=0, int atom_end=0)</td></tr>
<tr class="separator:a0f8ec3a5c3151823697564886a3af8d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T&gt;<br />
class stormm::structure::CoordinateSeries&lt; T &gt;</div><p>Store the coordinates and box information for a series of frames, in one of several levels of precision. Individual frames can be extracted into <a class="el" href="classstormm_1_1structure_1_1CoordinateFrame.html" title="Store the coordinates and box information for a frame, only. This abridged struct can serve when the ...">CoordinateFrame</a>, and <a class="el" href="classstormm_1_1structure_1_1PhaseSpace.html" title="An object to complement a topology and hold positions, velocities, and forces of all particles in a s...">PhaseSpace</a>, and <a class="el" href="classstormm_1_1structure_1_1PhaseSpaceSynthesis.html" title="A fixed-precision representation of coordinates, velocities, and forces to manage a set of simulation...">PhaseSpaceSynthesis</a> objects, or new frames can be added from <a class="el" href="classstormm_1_1structure_1_1CoordinateFrame.html" title="Store the coordinates and box information for a frame, only. This abridged struct can serve when the ...">CoordinateFrame</a> objects. This object is not the <a class="el" href="classstormm_1_1structure_1_1CoordinateFrame.html" title="Store the coordinates and box information for a frame, only. This abridged struct can serve when the ...">CoordinateFrame</a> equivalent of a <a class="el" href="classstormm_1_1structure_1_1PhaseSpaceSynthesis.html" title="A fixed-precision representation of coordinates, velocities, and forces to manage a set of simulation...">PhaseSpaceSynthesis</a> object, however: its purpose is to collect only the coordinates of many frames of a single system at the appropriate level of precision. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a177c3972176420bdd8e125df6f222135" name="a177c3972176420bdd8e125df6f222135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a177c3972176420bdd8e125df6f222135">&#9670;&#160;</a></span>CoordinateSeries() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstormm_1_1trajectory_1_1CoordinateSeries.html">stormm::trajectory::CoordinateSeries</a>&lt; T &gt;::CoordinateSeries </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>natom_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nframe_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnitCellType</td>          <td class="paramname"><span class="paramname"><em>unit_cell_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">UnitCellType::NONE</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>globalpos_scale_bits_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HybridFormat</td>          <td class="paramname"><span class="paramname"><em>format_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">default_hpc_format</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>There are several options for constructing this collection of coordinate frames. </p>
<p>Overloaded:</p><ul>
<li>Allocate to hold a given number of atoms and frames</li>
<li>Create from any of the coordinate file formats (restart and input coordinate formats will create only one frame, but this limit can be increased later)</li>
<li>From an existing <a class="el" href="classstormm_1_1structure_1_1PhaseSpace.html" title="An object to complement a topology and hold positions, velocities, and forces of all particles in a s...">PhaseSpace</a> or <a class="el" href="classstormm_1_1structure_1_1CoordinateFrame.html" title="Store the coordinates and box information for a frame, only. This abridged struct can serve when the ...">CoordinateFrame</a> object (as a pointer or a copy, with the option to make many copies immediately)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">natom_in</td><td>The number of atoms expected </td></tr>
    <tr><td class="paramname">nframe_in</td><td>Initial number of frames to allocate for </td></tr>
    <tr><td class="paramname">unit_cell_in</td><td>The type of unit cell to prepare for (this can be modified after creating the object) </td></tr>
    <tr><td class="paramname">file_name</td><td>File to read from </td></tr>
    <tr><td class="paramname">frame_numbers_in</td><td>Frame numbers of the file to read (default all frames) </td></tr>
    <tr><td class="paramname">replica_count_in</td><td>The number of times to replicate a series of one of more frames read from a file (this is useful for immediately making many copies of a restrart or input coordinates file, which has only one frame) </td></tr>
    <tr><td class="paramname">atom_count_in</td><td>The number of atoms to expect (critical if the input file is an Amber .crd format trajectory, otherwise can be left at zero to be filled in when the file is read) </td></tr>
    <tr><td class="paramname">ps</td><td>Pre-existing object with a complete coordinate set to use as a template. When constructing from a pre-existing <a class="el" href="classstormm_1_1structure_1_1PhaseSpace.html" title="An object to complement a topology and hold positions, velocities, and forces of all particles in a s...">PhaseSpace</a> object, nframe_in indicates a number of copies to allocate for and create. </td></tr>
    <tr><td class="paramname">cf</td><td>Pre-existing object with a complete coordinate set to use as a template. When constructing from a pre-existing <a class="el" href="classstormm_1_1structure_1_1CoordinateFrame.html" title="Store the coordinates and box information for a frame, only. This abridged struct can serve when the ...">CoordinateFrame</a>, nframe_in indicates a number of copies to allocate for and create. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ec4d3677f41ae0403d59f75b450434f" name="a6ec4d3677f41ae0403d59f75b450434f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ec4d3677f41ae0403d59f75b450434f">&#9670;&#160;</a></span>CoordinateSeries() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstormm_1_1trajectory_1_1CoordinateSeries.html">stormm::trajectory::CoordinateSeries</a>&lt; T &gt;::CoordinateSeries </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateSeries.html">CoordinateSeries</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>original</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use the default copy and move constructors, copy and move assignment operators. This object has no const members to trigger implicit deletions and no POINTER-kind <a class="el" href="classstormm_1_1structure_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> objects to repair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">original</td><td>The original object, being copied or moved </td></tr>
    <tr><td class="paramname">other</td><td>The other object, being copied or moved by assignment </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9bf6a44869601feddbfd8bdc02f320f" name="ac9bf6a44869601feddbfd8bdc02f320f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9bf6a44869601feddbfd8bdc02f320f">&#9670;&#160;</a></span>CoordinateSeries() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstormm_1_1trajectory_1_1CoordinateSeries.html">stormm::trajectory::CoordinateSeries</a>&lt; T &gt;::CoordinateSeries </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateSeries.html">CoordinateSeries</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>original</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HybridFormat</td>          <td class="paramname"><span class="paramname"><em>format_in</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A special copy constructor can create an object with an altered memory format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">original</td><td>The original object, being copied or moved </td></tr>
    <tr><td class="paramname">format_in</td><td>The format to apply to the new object. Content is subject to the priority of the deepCopy() function for <a class="el" href="classstormm_1_1structure_1_1Hybrid.html" title="An evolution of GpuBuffer in pmemd.cuda, the Composite array has elements that are accessible from ei...">Hybrid</a> objects, as it is with the <a class="el" href="classstormm_1_1structure_1_1PhaseSpace.html" title="An object to complement a topology and hold positions, velocities, and forces of all particles in a s...">PhaseSpace</a> and <a class="el" href="classstormm_1_1structure_1_1CoordinateFrame.html" title="Store the coordinates and box information for a frame, only. This abridged struct can serve when the ...">CoordinateFrame</a> objects. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0468a0a4147cccfa4e0fd7e950e1d2ff" name="a0468a0a4147cccfa4e0fd7e950e1d2ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0468a0a4147cccfa4e0fd7e950e1d2ff">&#9670;&#160;</a></span>CoordinateSeries() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Toriginal&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstormm_1_1trajectory_1_1CoordinateSeries.html">stormm::trajectory::CoordinateSeries</a>&lt; T &gt;::CoordinateSeries </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstormm_1_1trajectory_1_1CoordinateSeries.html">CoordinateSeries</a>&lt; Toriginal &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>original</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>globalpos_scale_bits_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HybridFormat</td>          <td class="paramname"><span class="paramname"><em>format_in</em></span><span class="paramdefsep"> = </span><span class="paramdefval">default_hpc_format</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Special copy constructor to take a <a class="el" href="classstormm_1_1structure_1_1CoordinateSeries.html" title="Store the coordinates and box information for a series of frames, in one of several levels of precisi...">CoordinateSeries</a> of one data type into another. The implementation requires a special declaration (template &lt;typename T&gt; template &lt;typename Toriginal&gt;...) with two uses of the template keyword because of the nested nature of these templates. In other contexts template &lt;typename T, typename Toriginal&gt; would suffice. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">original</td><td>The original object, being copied or moved </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a302b0807bb30c15d56de623df9ffd0f2" name="a302b0807bb30c15d56de623df9ffd0f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a302b0807bb30c15d56de623df9ffd0f2">&#9670;&#160;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structstormm_1_1trajectory_1_1CoordinateSeriesReader.html">CoordinateSeriesReader</a>&lt; T &gt; <a class="el" href="classstormm_1_1trajectory_1_1CoordinateSeries.html">stormm::trajectory::CoordinateSeries</a>&lt; T &gt;::data </td>
          <td>(</td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the abstract for this object, containing C-style pointers for the most rapid access to any of its member variables. </p>
<p>Overloaded:</p><ul>
<li>Get a read-only abstract from a const coordinate series</li>
<li>Get a writeable abstract from a non-const coordinate series</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tier</td><td>Get pointers to data at the level of the CPU host or GPU device </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ad012d39dcb1d47e753cacbb8ffef92" name="a6ad012d39dcb1d47e753cacbb8ffef92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ad012d39dcb1d47e753cacbb8ffef92">&#9670;&#160;</a></span>exportFrame()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> <a class="el" href="classstormm_1_1trajectory_1_1CoordinateSeries.html">stormm::trajectory::CoordinateSeries</a>&lt; T &gt;::exportFrame </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>frame_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepare a <a class="el" href="classstormm_1_1structure_1_1CoordinateFrame.html" title="Store the coordinates and box information for a frame, only. This abridged struct can serve when the ...">CoordinateFrame</a> object based on one frame of the series, accomplishing any necessary data conversions to put the coordinates back into the familiar double-precision format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame_index</td><td>The frame to extract </td></tr>
    <tr><td class="paramname">tier</td><td>Level at which to retrieve data (if STORMM is compiled to run on a GPU) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7e0a22bf3848c5172e83cbd1290a266" name="af7e0a22bf3848c5172e83cbd1290a266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7e0a22bf3848c5172e83cbd1290a266">&#9670;&#160;</a></span>exportPhaseSpace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstormm_1_1trajectory_1_1PhaseSpace.html">PhaseSpace</a> <a class="el" href="classstormm_1_1trajectory_1_1CoordinateSeries.html">stormm::trajectory::CoordinateSeries</a>&lt; T &gt;::exportPhaseSpace </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>frame_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepare a <a class="el" href="classstormm_1_1structure_1_1PhaseSpace.html" title="An object to complement a topology and hold positions, velocities, and forces of all particles in a s...">PhaseSpace</a> object based on one frame of the series, accomplishing any data conversions needed to put the coordinates back into the familiar double-precision format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame_index</td><td>The frame to extract </td></tr>
    <tr><td class="paramname">tier</td><td>Level at which to retrieve data (if STORMM is compiled to run on a GPU) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75699e5b3e2aa61af103039efe26ab55" name="a75699e5b3e2aa61af103039efe26ab55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75699e5b3e2aa61af103039efe26ab55">&#9670;&#160;</a></span>exportToFile()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstormm_1_1trajectory_1_1CoordinateSeries.html">stormm::trajectory::CoordinateSeries</a>&lt; T &gt;::exportToFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>file_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoordinateFileKind</td>          <td class="paramname"><span class="paramname"><em>output_kind</em></span><span class="paramdefsep"> = </span><span class="paramdefval">CoordinateFileKind::AMBER_CRD</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PrintSituation</td>          <td class="paramname"><span class="paramname"><em>expectation</em></span><span class="paramdefsep"> = </span><span class="paramdefval">PrintSituation::UNKNOWN</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>low_index</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>high_index</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export the contents of this coordinate series to a trajectory file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_name</td><td>Name of the file to write </td></tr>
    <tr><td class="paramname">output_kind</td><td>The format of the file to write (checkpoint files print position and velocity data by obligation, but trajectory files can contain either of these as well as forces) </td></tr>
    <tr><td class="paramname">expectation</td><td>The condition in which the output file is expected to be found </td></tr>
    <tr><td class="paramname">low_index</td><td>The first frame index to export </td></tr>
    <tr><td class="paramname">high_index</td><td>The upper limit of frame indices to export </td></tr>
    <tr><td class="paramname">tier</td><td>Level at which to retrieve data (if STORMM is compiled to run on a GPU) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a646f471e3d9e37cf7396ba47916ba30a" name="a646f471e3d9e37cf7396ba47916ba30a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a646f471e3d9e37cf7396ba47916ba30a">&#9670;&#160;</a></span>extractFrame()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstormm_1_1trajectory_1_1CoordinateSeries.html">stormm::trajectory::CoordinateSeries</a>&lt; T &gt;::extractFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstormm_1_1trajectory_1_1CoordinateFrame.html">CoordinateFrame</a> *</td>          <td class="paramname"><span class="paramname"><em>cf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>frame_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstormm_1_1card_1_1GpuDetails.html">GpuDetails</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gpu</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract coordinates to a pre-existing object. </p>
<p>Overloaded:</p><ul>
<li>Load coordinates into a <a class="el" href="classstormm_1_1structure_1_1CoordinateFrame.html" title="Store the coordinates and box information for a frame, only. This abridged struct can serve when the ...">CoordinateFrame</a> object</li>
<li>Load coordinates into a <a class="el" href="classstormm_1_1structure_1_1PhaseSpace.html" title="An object to complement a topology and hold positions, velocities, and forces of all particles in a s...">PhaseSpace</a> object using the stated point in the time cycle or taking the object's current orientation</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cf</td><td>Coordinate frame into which coordinates shall be placed </td></tr>
    <tr><td class="paramname">ps</td><td>Phase space object into which coordinates shall be placed </td></tr>
    <tr><td class="paramname">frame_index</td><td>Frame to use in coordinate extraction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73890c3740e9af7014f2a829a2845694" name="a73890c3740e9af7014f2a829a2845694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73890c3740e9af7014f2a829a2845694">&#9670;&#160;</a></span>getBoxDimensions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; <a class="el" href="classstormm_1_1trajectory_1_1CoordinateSeries.html">stormm::trajectory::CoordinateSeries</a>&lt; T &gt;::getBoxDimensions </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>frame_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the box dimensions in their pure form for a particular frame. </p>
<p>Overloaded:</p><ul>
<li>Get the dimensions for a specific system on the CPU host or GPU device</li>
<li>Get the dimensions for all systems at both levels</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame_index</td><td>The frame for which to extract the transformation matrix </td></tr>
    <tr><td class="paramname">tier</td><td>Level at which to retrieve data (if STORMM is compiled to run on a GPU) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30333cf52fbac843369caee3a013a9ba" name="a30333cf52fbac843369caee3a013a9ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30333cf52fbac843369caee3a013a9ba">&#9670;&#160;</a></span>getBoxSpaceTransform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; <a class="el" href="classstormm_1_1trajectory_1_1CoordinateSeries.html">stormm::trajectory::CoordinateSeries</a>&lt; T &gt;::getBoxSpaceTransform </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>frame_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the transformation matrix to take coordinates into box (fractional) space. The result should be interpreted as a 3x3 matrix in column-major format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame_index</td><td>The frame for which to extract the transformation matrix </td></tr>
    <tr><td class="paramname">tier</td><td>Level at which to retrieve data (if STORMM is compiled to run on a GPU) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e7c3d7d57f3fa31deaff2df27b8c1a4" name="a4e7c3d7d57f3fa31deaff2df27b8c1a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e7c3d7d57f3fa31deaff2df27b8c1a4">&#9670;&#160;</a></span>getCoordinatePointer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; T &gt; * <a class="el" href="classstormm_1_1trajectory_1_1CoordinateSeries.html">stormm::trajectory::CoordinateSeries</a>&lt; T &gt;::getCoordinatePointer </td>
          <td>(</td>
          <td class="paramtype">CartesianDimension</td>          <td class="paramname"><span class="paramname"><em>dim</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a const pointer to one of the Cartesian coordinate arrays. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>The dimension of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07c34348feecb335e6a346b0a08ed290" name="a07c34348feecb335e6a346b0a08ed290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07c34348feecb335e6a346b0a08ed290">&#9670;&#160;</a></span>getCoordinateReference()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; T &gt; &amp; <a class="el" href="classstormm_1_1trajectory_1_1CoordinateSeries.html">stormm::trajectory::CoordinateSeries</a>&lt; T &gt;::getCoordinateReference </td>
          <td>(</td>
          <td class="paramtype">CartesianDimension</td>          <td class="paramname"><span class="paramname"><em>dim</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a const reference to the one of the Cartesian coordinate arrays. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>The dimension of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9d6b0e0f3b497416edd03d263ab04da" name="aa9d6b0e0f3b497416edd03d263ab04da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9d6b0e0f3b497416edd03d263ab04da">&#9670;&#160;</a></span>getFramesHandle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classstormm_1_1card_1_1Hybrid.html">Hybrid</a>&lt; T &gt; * <a class="el" href="classstormm_1_1trajectory_1_1CoordinateSeries.html">stormm::trajectory::CoordinateSeries</a>&lt; T &gt;::getFramesHandle </td>
          <td>(</td>
          <td class="paramtype">CartesianDimension</td>          <td class="paramname"><span class="paramname"><em>dim</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to one of the coordinate arrays. </p>
<p>Overloaded:</p><ul>
<li>Get a const pointer to the storage array of a const object.</li>
<li>Get a non-const pointer to the storage space of a mutable object.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>Specify coordinate data along one of the Cartesian axes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae90cfaaab36b52ef864ee1b02c2fa596" name="ae90cfaaab36b52ef864ee1b02c2fa596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae90cfaaab36b52ef864ee1b02c2fa596">&#9670;&#160;</a></span>getInterlacedCoordinates()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Treport&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Treport &gt; <a class="el" href="classstormm_1_1trajectory_1_1CoordinateSeries.html">stormm::trajectory::CoordinateSeries</a>&lt; T &gt;::getInterlacedCoordinates </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>frame_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>globalpos_bits_out</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the interlaced coordinates of one frame. </p>
<p>Overloaded:</p><ul>
<li>Get coordinates for all atoms in a frame</li>
<li>Get coordinates for a selected range of atoms in a frame</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame_index</td><td>Index of the frame to access </td></tr>
    <tr><td class="paramname">globalpos_bits_out</td><td>The number of bits after the point to apply if a fixed-precision output is required. Setting this to &lt;= 0 indicates floating point output. </td></tr>
    <tr><td class="paramname">low_index</td><td>The lower atom index of a range </td></tr>
    <tr><td class="paramname">high_index</td><td>The upper atom index of a range </td></tr>
    <tr><td class="paramname">tier</td><td>The level at which to access coordinates </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3fdfc66717964f35c59a537069bde0d1" name="a3fdfc66717964f35c59a537069bde0d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fdfc66717964f35c59a537069bde0d1">&#9670;&#160;</a></span>getInverseTransform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; <a class="el" href="classstormm_1_1trajectory_1_1CoordinateSeries.html">stormm::trajectory::CoordinateSeries</a>&lt; T &gt;::getInverseTransform </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>frame_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HybridTargetLevel</td>          <td class="paramname"><span class="paramname"><em>tier</em></span><span class="paramdefsep"> = </span><span class="paramdefval">HybridTargetLevel::HOST</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the transformation matrix to take coordinates from fractional space back into real space. The result should be interpreted as a 3x3 matrix in column-major format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame_index</td><td>The frame for which to extract the transformation matrix </td></tr>
    <tr><td class="paramname">tier</td><td>Level at which to retrieve data (if STORMM is compiled to run on a GPU) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4786d8334443767edd10617e3d5a0c6f" name="a4786d8334443767edd10617e3d5a0c6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4786d8334443767edd10617e3d5a0c6f">&#9670;&#160;</a></span>importFrame()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstormm_1_1trajectory_1_1CoordinateSeries.html">stormm::trajectory::CoordinateSeries</a>&lt; T &gt;::importFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstormm_1_1trajectory_1_1CoordinateFrameReader.html">CoordinateFrameReader</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>cfr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>atom_start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>atom_end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>frame_index</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import coordinates from a <a class="el" href="classstormm_1_1structure_1_1CoordinateFrame.html" title="Store the coordinates and box information for a frame, only. This abridged struct can serve when the ...">CoordinateFrame</a> or <a class="el" href="classstormm_1_1structure_1_1PhaseSpace.html" title="An object to complement a topology and hold positions, velocities, and forces of all particles in a s...">PhaseSpace</a> object. The original object must have the same number of atoms as the <a class="el" href="classstormm_1_1structure_1_1CoordinateSeries.html" title="Store the coordinates and box information for a series of frames, in one of several levels of precisi...">CoordinateSeries</a> itself, or else a range of atoms within the original coordinate object must be specified that fits the <a class="el" href="classstormm_1_1structure_1_1CoordinateSeries.html" title="Store the coordinates and box information for a series of frames, in one of several levels of precisi...">CoordinateSeries</a>. The default behavior is to push the new coordinates to the back of the list, but any frame index within the bounds of the current list may also be specified. </p>
<p>Overloaded:</p><ul>
<li>Accept all types of single-frame coordinate objects</li>
<li>Accept all atoms or a subset of the atoms that fits the current atom count of the <a class="el" href="classstormm_1_1structure_1_1CoordinateSeries.html" title="Store the coordinates and box information for a series of frames, in one of several levels of precisi...">CoordinateSeries</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cfr</td><td>Coordinates to import. The <a class="el" href="structstormm_1_1structure_1_1CoordinateFrameReader.html" title="Collect C-style pointers for the elements of a read-only CoordinateFrame object.">CoordinateFrameReader</a> is the most basic object available for importation. Both <a class="el" href="classstormm_1_1structure_1_1CoordinateFrame.html" title="Store the coordinates and box information for a frame, only. This abridged struct can serve when the ...">CoordinateFrame</a> and <a class="el" href="classstormm_1_1structure_1_1PhaseSpace.html" title="An object to complement a topology and hold positions, velocities, and forces of all particles in a s...">PhaseSpace</a> objects can create CoordinateFrameReaders or writers, and the writers can be const-ified into readers. </td></tr>
    <tr><td class="paramname">cfw</td><td>Coordinates to import </td></tr>
    <tr><td class="paramname">cf</td><td>Coordinates to import </td></tr>
    <tr><td class="paramname">ps</td><td>Coordinates to import </td></tr>
    <tr><td class="paramname">atom_start</td><td>First atom from the coordinate set to add to a frame of the series </td></tr>
    <tr><td class="paramname">atom_end</td><td>Limit of atoms from the coordinate set to add to a frame of the series </td></tr>
    <tr><td class="paramname">frame_index</td><td>Index of the frame into which the coordinates should be imported. The default value of -1 adds the new coordinates to the end of the list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab43d1eda1a2c6331281ad1ffbcc1899a" name="ab43d1eda1a2c6331281ad1ffbcc1899a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab43d1eda1a2c6331281ad1ffbcc1899a">&#9670;&#160;</a></span>importFromFile()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstormm_1_1trajectory_1_1CoordinateSeries.html">stormm::trajectory::CoordinateSeries</a>&lt; T &gt;::importFromFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>file_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoordinateFileKind</td>          <td class="paramname"><span class="paramname"><em>file_kind</em></span><span class="paramdefsep"> = </span><span class="paramdefval">CoordinateFileKind::UNKNOWN</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame_numbers</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>replica_count</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>frame_index_start</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import coordinates from a file. This function accepts directives to read a subset of the coordinates and integrate them into the series at a specified point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_name</td><td>Name of the file </td></tr>
    <tr><td class="paramname">file_kind</td><td>The kind of coordinate file being read, default UNKNOWN which will lead to automatic deduction of the file type </td></tr>
    <tr><td class="paramname">frame_numbers</td><td>List of frame indices (starting from zero) to import from the file (if the file is too small to hold one or more frames with the requested indices, this is an error) </td></tr>
    <tr><td class="paramname">replica_count_in</td><td>The number of replicas of the frames from this file (default 1). If additional replicas are requested, the whole series will be added in sequence, i.e. frames 3, 5, 8, 9, 3, 5, 8, 9, 3, ... </td></tr>
    <tr><td class="paramname">frame_index_start</td><td>The starting index of the series for incorporating frames found in the file. A negative value in this argument triggers addition to the end of any existing series. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7037f5778880d412a45e260423dd7c64" name="a7037f5778880d412a45e260423dd7c64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7037f5778880d412a45e260423dd7c64">&#9670;&#160;</a></span>pushBack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstormm_1_1trajectory_1_1CoordinateSeries.html">stormm::trajectory::CoordinateSeries</a>&lt; T &gt;::pushBack </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstormm_1_1trajectory_1_1CoordinateFrameReader.html">CoordinateFrameReader</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>cfr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>atom_start</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>atom_end</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push a coordinate set to the back of the list. This invokes the import member function after reallocating the frame series with 25% spare capacity if the original capacity is insufficient. </p>
<p>Overloaded:</p><ul>
<li>Accept all types of single-frame coordinate objects</li>
<li>Accept all atoms or a subset of the atoms that fits the current atom count of the <a class="el" href="classstormm_1_1structure_1_1CoordinateSeries.html" title="Store the coordinates and box information for a series of frames, in one of several levels of precisi...">CoordinateSeries</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cfr</td><td>Coordinates to import. The <a class="el" href="structstormm_1_1structure_1_1CoordinateFrameReader.html" title="Collect C-style pointers for the elements of a read-only CoordinateFrame object.">CoordinateFrameReader</a> is the most basic object available for importation. Both <a class="el" href="classstormm_1_1structure_1_1CoordinateFrame.html" title="Store the coordinates and box information for a frame, only. This abridged struct can serve when the ...">CoordinateFrame</a> and <a class="el" href="classstormm_1_1structure_1_1PhaseSpace.html" title="An object to complement a topology and hold positions, velocities, and forces of all particles in a s...">PhaseSpace</a> objects can create CoordinateFrameReaders or writers, and the writers can be const-ified into readers. </td></tr>
    <tr><td class="paramname">cfw</td><td>Coordinates to import </td></tr>
    <tr><td class="paramname">cf</td><td>Coordinates to import </td></tr>
    <tr><td class="paramname">ps</td><td>Coordinates to import </td></tr>
    <tr><td class="paramname">atom_start</td><td>First atom from the coordinate set to add to a frame of the series </td></tr>
    <tr><td class="paramname">atom_end</td><td>Limit of atoms from the coordinate set to add to a frame of the series </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47b7d452d042d841f28e8b1776ba9eae" name="a47b7d452d042d841f28e8b1776ba9eae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47b7d452d042d841f28e8b1776ba9eae">&#9670;&#160;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstormm_1_1trajectory_1_1CoordinateSeries.html">stormm::trajectory::CoordinateSeries</a>&lt; T &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>new_frame_capacity</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reserve capacity in this series. The new frames will be uninitialized. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_frame_capacity</td><td>The new capacity to prepare for. If such capacity already exists, the function will do nothing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af920851814b2edb599d4c8d2d3bddb8b" name="af920851814b2edb599d4c8d2d3bddb8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af920851814b2edb599d4c8d2d3bddb8b">&#9670;&#160;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstormm_1_1trajectory_1_1CoordinateSeries.html">stormm::trajectory::CoordinateSeries</a>&lt; T &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>new_frame_count</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize the series, allocating new capacity if needed, initializing new frames with the provided coordinate set. ("New" frames are defined as any frames with indices greater than the original maximum index, regardless of whether new capacity was allocated to hold them or if the size simply increased within the existing space available.) </p>
<p>Overloaded:</p><ul>
<li>Accept all types of single-frame coordinate objects</li>
<li>Accept all atoms or a subset of the atoms that fits the current atom count of the <a class="el" href="classstormm_1_1structure_1_1CoordinateSeries.html" title="Store the coordinates and box information for a series of frames, in one of several levels of precisi...">CoordinateSeries</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_frame_count</td><td>The number of new frames that the list shall report holding. This is less than or equal to the capacity; if there is insufficient capacity when <a class="el" href="classstormm_1_1trajectory_1_1CoordinateSeries.html#af920851814b2edb599d4c8d2d3bddb8b" title="Resize the series, allocating new capacity if needed, initializing new frames with the provided coord...">resize()</a> is called, new capacity will be allocated to hold precisely new_frame_count frames. </td></tr>
    <tr><td class="paramname">cfr</td><td>Optional coordinate set to use in initializing new frames. If no coordinates are provided, the series will report holding frames but have undefined values in them. </td></tr>
    <tr><td class="paramname">cfw</td><td>Optional coordinate set to use in initializing new frames </td></tr>
    <tr><td class="paramname">cf</td><td>Optional coordinate set to use in initializing new frames </td></tr>
    <tr><td class="paramname">ps</td><td>Optional coordinate set to use in initializing new frames </td></tr>
    <tr><td class="paramname">atom_start</td><td>First atom from the coordinate set to add to a frame of the series (the default value is zero, to use all atoms) </td></tr>
    <tr><td class="paramname">atom_end</td><td>Limit of atoms from the coordinate set to add to a frame of the series (the default value of zero will trigger an access to atom count from the coordinate object to load all of its atoms) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/Trajectory/<a class="el" href="coordinate__series_8h_source.html">coordinate_series.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2
</small></address>
</div><!-- doc-content -->
</body>
</html>
